<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Cryptography Basics | Whyyy</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="安全基础当在互联网上交换数据时，被传输的数据会经过各种各样的设备和网络后才能到达目的地，正是因为如此，安全技术在互联网时代才显得如此重要。在数据在网络上传输的过程中，存在着4个比较显著的问题。  当A想要向B发送消息时，可能存在第三方X来截获消息的内容，这种问题称为“interception”。 即使A本来要将消息发送给B，也存在X伪装成B来接收消息的可能性；同样的，也存在B相信接收到的消息来自于">
<meta name="keywords" content="programming,hack,golang">
<meta property="og:type" content="article">
<meta property="og:title" content="Cryptography Basics">
<meta property="og:url" content="https://oceanoverflow.github.io/2018/02/05/CryptoBasic/index.html">
<meta property="og:site_name" content="Whyyy">
<meta property="og:description" content="安全基础当在互联网上交换数据时，被传输的数据会经过各种各样的设备和网络后才能到达目的地，正是因为如此，安全技术在互联网时代才显得如此重要。在数据在网络上传输的过程中，存在着4个比较显著的问题。  当A想要向B发送消息时，可能存在第三方X来截获消息的内容，这种问题称为“interception”。 即使A本来要将消息发送给B，也存在X伪装成B来接收消息的可能性；同样的，也存在B相信接收到的消息来自于">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-06-26T08:44:45.318Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cryptography Basics">
<meta name="twitter:description" content="安全基础当在互联网上交换数据时，被传输的数据会经过各种各样的设备和网络后才能到达目的地，正是因为如此，安全技术在互联网时代才显得如此重要。在数据在网络上传输的过程中，存在着4个比较显著的问题。  当A想要向B发送消息时，可能存在第三方X来截获消息的内容，这种问题称为“interception”。 即使A本来要将消息发送给B，也存在X伪装成B来接收消息的可能性；同样的，也存在B相信接收到的消息来自于">
  
  
    <link rel="icon" href="/favicon.png">
  
  
	<!-- If needed, replace your own web font service -->
  <link href="https://fonts.googleapis.com/css?family=Lato:400,400i,700" rel="stylesheet">

  <link rel="stylesheet" href="/icomoon/style.css">
  <link rel="stylesheet" href="/style.css">

</head>

<body>
  <div class="site-wrapper">
    <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<script>document.getElementById("loading-bar").style.width="20%";</script>


<header id="header" class="site-header clearfix">

  <a class="logo square clearfix" href="/">
    <!-- 
      Replace with your own size name, for example:
      <span class="b">A</span>
      <span class="w">B</span>
      <span class="b">C</span>
     -->
    
      <span class="b">
        W
      </span>
    
      <span class="b">
        h
      </span>
    
      <span class="b">
        y
      </span>
    
      <span class="w">
        y
      </span>
    
      <span class="b">
        y
      </span>
    
  </a>
  <a class="me square site-nav-switch clearfix">
    <span class="b">
    	<span class="icon icon-menu"></span>
    </span>
  </a>

</header>

    <script>document.getElementById("loading-bar").style.width="40%";</script>
    <main id="main" class="clearfix">
      <article id="post-CryptoBasic"
  class="article white-box article-type-post"
  itemscope itemprop="blogPost">

  <header class="article-header">
    <h1 class="article-title" itemprop="name">
      Cryptography Basics
    </h1>
    <div class="article-meta">
      Posted on 
      <time class="article-time" datetime="2018-02-05T14:39:55.000Z" itemprop="datePublished">
        Feb 5, 2018
      </time>
    </div>
  </header>

  <div class="article-entry" itemprop="articleBody">
    <h2 id="安全基础"><a href="#安全基础" class="headerlink" title="安全基础"></a>安全基础</h2><p>当在互联网上交换数据时，被传输的数据会经过各种各样的设备和网络后才能到达目的地，正是因为如此，安全技术在互联网时代才显得如此重要。在数据在网络上传输的过程中，存在着4个比较显著的问题。</p>
<ol>
<li>当A想要向B发送消息时，可能存在第三方X来截获消息的内容，这种问题称为“interception”。</li>
<li>即使A本来要将消息发送给B，也存在X伪装成B来接收消息的可能性；同样的，也存在B相信接收到的消息来自于A，但实际上是X伪装成A来发送这条消息，这种问题被称为“spoofing”。</li>
<li>假设A向B发送的消息已经完成了，也存在在消息的发送过程中，X篡改消息的内容的可能性，这种问题被称为“falsification”。除了有意的消息篡改以外，也存在消息在发送的过程中因为传输设备出现异常而出错的可能性。</li>
<li>最后一个问题，就是假设B已经正确地接受到了A发送的消息，但是发送方A出于自己的私心考虑，否认了这条消息是由他自己发出的，当出现这种情况时，互联网将无法成为商业交易或商业合同签署合格的媒介，这种问题被称为“repudiation”。</li>
</ol>
<p>当然上述4个问题并不仅限于人与人的信息交换之间，同时也存在我们日常上网的过程中。下面我们来简单的介绍一下解决上述问题的安全技术。<br>为了解决第一个问题中出现的消息被截获的问题，我们可以使用“加密”技术，解决第二个问题的方法可以是“消息验证码”或者“数字签名”技术。类似的，第三个问题同样也可以使用“消息验证码”或“数字签名”技术。还有“数字签名”技术还可以用于解决第四个问题—“repudiation”。</p>
<p>其实数字签名本身也存在问题，就是它本身自己无法验证签名使用的公钥的拥有者的真实性，所以就出现了“数字证书”来解决数字签名本身的问题。</p>
<h2 id="加密基础"><a href="#加密基础" class="headerlink" title="加密基础"></a>加密基础</h2><p>为什么在现代的互联网世界中我们需要加密技术呢？例如A需要向B发送消息，在消息到达B之前会经过各式各样的设备和网络，所以有很大的可能性消息会被恶意的第三方所截获，因此出于这种原因，在发送消息之前将消息加密就显得非常有必要了。</p>
<p>被加密的数据被称为“秘文”，消息将会以秘文的形式发送给B，B收到A发送过来的秘文后，将其解密后就可以获得原来的消息。将加密的数据还原成数据的原始状态的过程被称为“解密”。当你将数据以加密的形式发送出去时，就可以不必当心恶意的第三方截获到你的数据了，正因为如此，加密技术在现代社会中才显得如此重要。下面，我们来仔细地了解一下在加密过程中涉及到的操作。</p>
<p>我们知道，在计算机中，无论数据的类型是什么，计算机都将他们视为一系列二进制数据，也就是一长串的0和1。所以，尽管存在各种各样的数据格式，例如文本文件，音乐和影像，在计算机中，所有的数据都是以二进制数据进行管理的。同样，在加密的过程中，我们也可以以计算机管理数据那样的方式来思考我们的数据，数据就是一系列有意义的数字，虽然秘文同样也是一串数字，但是由于它们的随机性，计算机并不能正确地解释它们，加密就是通过计算，来将原来对于计算机来说有特定含义的数据转换成计算机无法解释的数据的一个过程。</p>
<p>在加密的过程中，存在一个用于执行计算的一个“密钥”。这个密钥同样也是由数字组成。换一句话说，通过密钥来进行数值计算，加密可以将原本可读的数据转化为不可读的数据。反过来，解密就是通过密钥来进行数值计算，将不可读的数据转化为可读数据的一个过程。我们来通过一个“异或”理解加密和解密的过程，XOR(异或)的结果是根据真值表决定的，我们有：</p>
<p>0 XOR 0 = 0 ；1 XOR 1 = 0；0 XOR 1 = 1；1 XOR 0 = 1</p>
<p>异或操作的一个特点就是 A XOR B = C，B XOR C = A，这意味着如果C是A和B异或的结果，那么你就可以通过C与A和B中任意一个值进行异或操作来获得另外一个数字。将这个知识点用于加密和解密的过程中，我们可以将私钥和数据进行异或操作得到秘文，同理地，将生成的秘文与私钥再进行一次异或操作，我们就可以还原得到原来的明文。从上述过程中我们可以看出，相同的私钥被用于异或加密或解密数据的过程中。</p>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>一个“哈希函数”可以将不同长度的数据映射为定长的一个值，我们可以形象地将哈希函数理解为榨汁机，我们将我们的原始材料（我们的数据）放进榨汁机（哈希函数）得到我们的饮料（哈希值），与榨汁机类似，我们可以将原材料转化为我们的饮料，但是反过来饮料并不能通过一定的操作转化为我们的原材料。类比我们的哈希函数，我们可以将原始数据通过哈希操作转化为哈希值，但是我们不可以使用哈希值得到我们的原始数据，也就是说，哈希是一个不可逆的过程。哈希值其实就是一个数值，但是我们常常使用十六进制来表示。</p>
<p>现在我们仔细地阐述一下哈希函数拥有的特点，第一点就是通过哈希函数得到的输出长度都是固定的，长度固定是针对特定的哈希函数而言的，例如SHA-1哈希函数得到的哈希值的长度都是20字节，这就意味着，即使你的输入数据非常大，但是通过SHA-1哈希之后，你得到的输出都是固定的20字节，类似的，不管你的输入数据有多小，你得到的输出依旧是20字节。哈希函数的第二个特点就是在哈希函数相同的情况下，相同的输入永远得到的是相同的输出。第三个特点也是非常重要的一个特点，就是你输入两个非常类似的数据，即使两个数据只相差1bit，得到的输出相差也会非常大。哈希值不会因为你的输入数据类似而得到相似的输出。第四个特点就是可能会存在输入的数据完全不同，依旧得到两个完全相同的哈希值，虽然这种概率非常小，这种情况被称为“哈希碰撞“。第五个特点就是哈希函数的单向性或者说是不可逆性，你几乎不可能通过哈希值得到原始数据，这也是哈希与加密之间一个非常重要的区别。哈希的最后一个特点就是计算哈希的过程可以非常简单。</p>
<p>我们可以使用MD4，MD5，SHA-0，SHA-1，SHA-2之类的哈希函数，但是在现实生活中，我们最常使用的就是SHA-2。</p>
<h2 id="共享密钥加密"><a href="#共享密钥加密" class="headerlink" title="共享密钥加密"></a>共享密钥加密</h2><p>共享密钥加密在加密和解密的过程中使用相同的私钥。假设A想要通过互联网将一段消息发送给B，在发送给B的过程中消息经过了很多不同的网络和设备。但是，如果A直接将消息以明文的形式发给B，则恶意第三方就非常容易截获该消息。正是因为这样，所以在传输消息的过程中通常需要经过加密处理。利用私钥，将明文加密为密文再进行发送。B利用相同的私钥将接收到的密文解密得到原文。所以，经过加密处理后，即使恶意第三方截取了消息，在不知道密钥的情况下，他也很难知道原文是什么。</p>
<p>利用相同密钥进行加密和解密是共享密钥加密的一个特点，常见的共享密钥加密方法有凯撒加密，AES，DES，OTP等等，其中AES被使用的最为广泛。当然，共享密钥加密本身存在着一个致命的缺陷，假设B收到了A发送的密文，而且在发送的过程中，密文也可能被恶意第三方X所截获，现在存在的问题是，由于A和B可能从来没有直接接触过，B可能实现并不知道A用于加密的密钥，所以在这种情况下，A就需要某种机制把密钥传输给B，就像A向B传输密文一样，A同样需要在互联网上向B传输密钥，B利用接收到的来自A的密钥就可以对密文进行解密。然而，既然是在互联网上传播，恶意第三方X同样有机会截获到密钥，这样一来，X就可以用截获到的密钥对密文进行解密。</p>
<p>在上述过程中 ，我们可以清楚地看到密钥本身传输存在问题，所以，组织A可以会想再通过对密钥本身进行加密后再传输，对于计算机来说，一个密钥仅仅是一段数据，所以我们可以使用新的密钥对老的密钥进行加密生成密文，再对密文进行传输，但是我们现在又需要一个机制来传输新的密钥，这样以来就会陷入一个循环，总结一下，共享密钥加密系统缺乏一个安全传输密钥的机制，这个问题被称为“密钥分发问题”。解决“密钥分发问题”有两种方法：</p>
<ol>
<li>使用如Diffie-Hellman 密钥交换这样的交换协议</li>
<li>使用公钥加密算法</li>
</ol>
<h2 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h2><p>公钥加密与共享密钥加密最大的区别在与公钥加密在加密和解密时候使用的是不同的密钥，用于加密的密钥被称为“公钥”（public key），用于解密的密钥被称为“私钥”（private key），除了使用不同的密钥之外，公钥加密在加密和解密时比共享密钥加密需要花费的时间更长。常用的公钥加密有RSA加密和ECC加密（椭圆曲线加密）。<br>下面我们来了解一下在公钥加密的情况下数据是如何在双方之间交换的。</p>
<p>假设A想要给B发送一段消息，首先，接受者B会生成一对密钥，分别是一个公钥和一个私钥，公钥部分将由B发送给A，A使用从B发送过来的公钥将消息加密，并将加密后的密文发送给B。B利用只有自己拥有的私钥将从A发送过来的密文进行解密，从而得到原始可读的消息，由于只有公钥和秘文在网上传输，而且只通过公钥并不能解密秘文，所以即使恶意的第三方截获了这两个信息，他也并不能解密获得原始消息。所以，公钥加密很好地解决了共享加密中私钥分发的问题。</p>
<p>使用公钥加密的另一个好处就是在一个不确定人数的组织中交换数据非常方便，举一个例子，假设B已经事先准备好一对密钥，即一个公钥和与公钥相对应的私钥。因为公布自己的公钥并不会有什么影响，所以，B将自己的公钥公布在互联网上，另一方面，由于私钥是绝对不能让他人知晓的，所以私钥需要牢牢地守护。</p>
<p>现在有多个个体需要向B发送数据，首先这些个体需要获取事先由B分享的公钥，然后利用公钥将需要发送的数据进行加密，最后将加密后的数据发送给B，B利用自己的私钥分别将收到的密文解密获得原来的数据，所以，在存在多个个体时，我们并不用准备多个公钥，还有一点就是，由于只有消息的接收者才具有用于解密的私钥，所以公钥加密的安全性非常之高。</p>
<p>然而在存在着诸多优点的同时，公钥加密也存在着两个严重的问题。公钥加密存在的第一个问题就是公钥加密所需要花费的时间相对比较长，正是因为这样，公钥加密并不适用于来回交换大量的数据，为了解决这一点，出现了“混合加密”这样的解决方案。</p>
<p>公钥加密的第二个问题在于公钥本身的可靠性。当B生成公钥和私钥时，为了方便起见，将B生成的公钥记为PB，将私钥记为SB，假设存在着恶意的第三方X，想要截获A发向B的数据，同时也生成了一对公私钥，分别记为PX和SX，当B向A发送自己的公钥PB时，X隐蔽地将B的公钥PB替换为自己的公钥PX，并将PX发送给A。由于通过公钥并不能发现公钥的产生者是谁，A并不能发现B的公钥有没有被第三方调包。接着A将自己的数据用公钥PX进行加密，当A将加密后的消息发送给B时，X截获了秘文，由于该秘文是用X的公钥PX加密的，X可以用自己的私钥SX来对秘文进行解密，这样以来，X成功截获了本来该发送给B的消息，接着，X将消息是用B的公钥PB加密后发送给B，由于过程中产生的密文是用B的公钥加密的，所以B可以利用自己的私钥SB对密文进行解密。正是因为B可以正确地对消息进行解密，A和B都无法知道其实消息已经被第三方截获过了。</p>
<p>上述的通过替换公钥来截获消息的攻击方式被称为“中间人攻击”。这种问题的关键就在于A无法验证自己获取的公钥到底是来自B还是来自恶意的第三方X。为了解决“中间人攻击问题”，我们可以使用数字证书来解决这一问题。</p>
<h2 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h2><p>如果使用共享密钥加密，我们会遇到“密钥分发问题”——如何安全地分发密钥，另一方面，如果使用公钥加密，漫长地加密解密问题又降低了信息传输的效率，混合加密的出现就整合了两者共同的优点，规避了两者的缺点。混合加密利用共享密钥加密加解密的高效性，而使用公钥加密来保障共享密钥的安全性。</p>
<p>假设A要向B发送消息，可以利用共享加密方法进行高效地加密操作，因为用于加密的密钥也同样被用于解密，所以A需要把密钥安全地发送给B。其实密钥也是数据的一种形式，通过公钥加密，我们可以安全地将密钥发送给B。接收者B自己生成一对密钥，即一个公钥和一个私钥，B将公钥发送给A，A利用B的公钥对对称密钥进行对称加密处理，加密后的密钥然后再发送给B，B利用自己的私钥对加密后的密钥进行解密处理，这样以来，A就利用公钥加密将密钥安全地发送给B，现在剩下唯一要做的就是将经过对称密钥加密后的密文发送给B，由于共享密钥加密加密解密速度快，B就可以准确快速地接收到原始数据。</p>
<p>上述过程我们可以清楚地看到混合加密整合了公钥加密的高安全性和共享密钥加密的快速加解密特点，混合加密已经被应用到SSL中，用于互联网上安全地交换数据。</p>
<h2 id="消息验证码"><a href="#消息验证码" class="headerlink" title="消息验证码"></a>消息验证码</h2><p>消息验证码实现了两个功能，anthentication和falsification detection。首先，我们来认识一下为什么消息验证码有存在的必要。假设A需要从B那里购置一件商品，A向B发送自己要购买的商品编号“xyz”，然后A将该商品编号加密，假设加密使用了共享密钥进行加密，A先使用某种安全的方法将共享密钥加密方法使用的密钥传递给B，这种密钥交换方法可以是公钥加密或者Diffie-Hellman密钥交换手段。A使用共享密钥对需要发送的消息进行加密，这里的消息就是我们需要发送的商品编号，加密后得到的密文被发送给B，B得到密文后使用共享密钥进行解密后得到明文即A发送的商品编号，这个传输过程看起来好像并没有什么问题，但是现实生活中可能发生这样的事情，当A向B发送经过加密后的密文时，恶意第三方X将密文在传输过程中进行篡改，当B收到被篡改后的密文然后解密后，得到的商品编号却变成了“123”，而B并不知道商品编号已经被篡改过了，B将商品“123”而不是“xyz”发送给A。</p>
<p>因为加密无非就是对原有数据进行数值计算，所以，解密的过程也可以在被篡改过的数据上进行，但是如果原消息是一个比较长的消息，而经过篡改后的密文解密后变成了一些没有实际意义的消息，那么消息的接收方可能会察觉到消息已经被篡改过了，但是是一些人类无法直接识别的消息例如上述的商品编号，那么就很难察觉出消息是否被篡改过了。所以，为了检测消息是否已经被恶意第三方篡改过，除了加密之外再增加一些手段就变得非常有必要了。</p>
<p>消息验证码就是为了检测消息有无被篡改而出现的一种解决方案。下面我们来仔细看一看消息验证码是如何工作的。当A将加密后的密文发送给B之前，A同时生成一个用于消息验证码的密钥，然后A将该密钥以安全的方法发送给B，然后A利用该密钥和密文以特定算法生成一个值，这个由密钥和密文组合生成的值就被称为“消息验证码”，通常被简写为“MAC”，MAC值可以简单的理解为密钥和密文组合起来的哈希值，我们可以使用各种各样的方法来生成MAC值，例如HMAC，OMAC，CMAC等等，现实生活中HMAC被使用的最为广泛，生成MAC值以后，A连同密文和MAC值一同发送给B，B接收到以后，需要根据MAC值检测密文有无被第三方篡改，B和A一样，根据密文和密钥来重新生成MAC值，这样以来，根据A发送过来的MAC和B自己重新生成的MAC进行比较，如果两者相同则说明密文并没有被他人篡改，B剩下仅仅需要将密文解密得到原文。</p>
<p>那么如果在A将密文发送给B的过程中，恶意第三方X将密文篡改的情况下会怎么样呢，假设在A将密文和MAC值发送给B的过程中，X篡改了密文，然而B收到以后重新计算MAC值，B会发现自己计算的MAC值和A发送的MAC值并不相同，这样以来，B就可以判断密文，MAC值或者两者都已经被篡改过了，在这种情况下，B可以选择将密文抛弃然后再重新请求A再次发送相同的密文。</p>
<p>是否存在X将密文和MAC值同时改变从而让B重新计算出来的MAC值和被传输的MAC值一致的可能呢？由于X不知道用于生成MAC值的密钥，所以即使X能篡改传输中的消息，X也无法做到让两者的MAC值一致，所以B在重新计算MAC值时发现与被篡改后消息一起携带的MAC值不一样时，B就可以清楚地知道该消息已经被别人做过手脚了。</p>
<p>经过上面的解释，我们可以清楚地看到使用消息验证码，或者MAC可以避免消息在传输的过程中被他人篡改，然而，消息验证码同时也存在着一些缺陷。由于A和B共享一对用于加密明文的密钥和用于生成MAC值的密钥，如果A可以加密消息和生成MAC值的话，那么B也可以还原这样的操作，B同样也可以加密消息和生成MAC值，换一句话说，你并不能区分原文是由A还是B生成的，那么假设A是恶意的，在A将消息发送给B后，A可以声称该消息是由B伪造生成的，这样A就否认了该消息是由他自己发送的，为了防止这种否认现象的出现，我们需要采取另外一种技术，也就是下面会讲的”数字签名“技术。</p>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名可以保证消息的不可否认性。数字签名除了完成了消息验证码实现了的authentication和falsification检测的功能之外，还实现了让消息的真实发送者无法否认这条消息是由他发送出的功能，这就是不可否认性。在仔细了解数字签名的工作原理之前，我们先回顾一下消息验证码。使用消息验证码的系统中，为了验证消息的发送者是真实的密钥拥有者，会将MAC值附着到要发送的消息上，为了方便起见，这里的消息以明文形式传输，A先以某种安全的方法将用于生成MAC的密钥发送给B，然后再将明文和MAC值发送给B，B根据收到的明文和密钥重新生成MAC值，然后再确认两者的MAC值是否相同，如果确认成功，那么就说明A是真实的发送者并且发送的明文没有经过他人篡改，然而由于消息验证码采用的是共享的密钥，依旧存在拥有该密码的组织伪装成为消息发送者的可能性，比如说，当A把一条消息发送给B之后，B却声称自己才是这条消息的创建者。还有一点就是，由于采用的是共享密钥来生成MAC值，那么当A与除了B之外的其他个体进行消息交流时，则需要生成一个新的密钥。</p>
<p>为了解决消息验证码内在的问题，我们引入数字签名技术，数字签名技术不采用MAC，而是采用只有消息的真实发送者才能产生的数据为基础的技术，而这产生的数据就被称为“数字签名”。例如A要发送一段消息“abc”，A会生成一段只能由A生成的签名，所以，当A发送的带有原消息和签名的数据被接收方接收到时，接收方就可以保证发送方一定是A。消息的接收方B，可以判断数字签名来自发送者A，但是他们自己并不能生成这些数字签名。与消息验证码相对比，由于数字签名并没有使用共享密钥，所以A可以向不同的组织或个体发送相同的数字签名。</p>
<p>我们知道用于生成MAC值的密钥是两方共享的，而当生成数字签名时，我们使用了和公钥加密系统类似的一个过程。我们在这里简单地回顾一下公钥加密的过程，首先如果A有消息要发送给B，接收方B会事先生成一对密钥，分别是公钥P和私钥S，B将公钥P传递给A，A使用B的公钥去加密自己的数据，然后再将加密后的密文发送给B，B利用只有自己才拥有的私钥S对密文进行解密，整个过程结束。所以在公钥加密中公钥被用于加密而私钥被用于解密，正是因为如此，任何人都可以使用公钥进行加密，但因为只有B才拥有私钥，故只有B才能进行解密。</p>
<p>但如果我们将公钥加密的操作反向进行会怎么样呢，将私钥用于加密，而将公钥用于解密，在这种情况下，假设只有A才有私钥，只有他们才能加密数据，而加密生成的数据可以被任何持有对应公钥的人进行解密，但这样的加密手段没有任何意义，但是如果换一种角度去看的话，我们就可以理解为密文的生成者必定是持有私钥的A而不会是其他个体。<br>下面我们来仔细了解一下数字签名的整个流程。首先A准备需要发送的数据，以及一对公私钥，注意到由消息的发送者准备公私钥是与公钥加密不同的地方之一，在公钥加密中公私钥是由消息的接收方所准备的。A将自己的公钥发送给B，然后A利用自己的私钥对消息进行签名，签名结果就被用来当作数字签名，A将消息和数字签名一同发送给B，B利用A的公钥对数字签名进行验证，如果验证的消息与收到的消息一致，那么整个交换的过程就结束了。</p>
<p>用A的私钥生成的数字签名，可以用A的公钥进行验证，但是该签名却只能由A生成，所以我们就可以确认A才是消息的发送者并且发送的消息没有被别人篡改过，而且，由于A的签名不能有除了A以外的组织例如B生成，因为B只有公钥，所以数字签名同时也实现了不可否认性这一功能。</p>
<p>然而，和公钥加密类似，加密和解密与签名和验证都需要花费很多的时间，所以，我们不直接对消息进行签名，为了减少计算所需要的时间，我们首先生成消息对应的哈希值，然后对哈希值进行签名操作再得到数字签名，然后将原消息和利用哈希值得到的数字签名发送给B，同样的，B利用收到的消息计算哈希值，并利用公钥对收到的数字签名进行解密操作得到另一个哈希值，如果这两个哈希值相同，那么说明整个过程没有出错，利用数字签名进行交换的过程也算结束了。</p>
<p>数字签名技术提供了authentication，falsification detection和repudiation prevention功能，但是它本身依旧存在着一个问题，消息和数字签名的接收方B，会无条件地认为A一定是消息和数字签名的发送方，但是事实上，很可能存在恶意第三方X伪装成A进行数据交换，存在这个问题的根本原因就在于数字签名和公钥加密都使用了一个公钥和一个私钥，我们并不能确定这个公钥到底属于谁，因为公钥中并没有包含它的归属方的信息，所以B使用的公钥很可能并不来自A，而是来自恶意第三方X的公钥，这个问题我们可以用“数字证书”这一技术来解决。</p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>公钥加密体系和数字签名存在的共同的问题就是无法确定公钥的归属者，所以，当A需要将自己的公钥发送给B时，恶意第三方X可以在不让A和B发现的情况下将A的公钥替换为自己的公钥。数字证书就是为了解决无法确定公钥归属者这一问题而出现的解决方案。下面我们来了解一下数字证书是如何工作的，假设组织A拥有一对公私钥，分别记为PA和SA，并且决定将PA发送给组织B。组织A需要向CA(certification authority)发起请求，让CA颁布一个证明公钥PA属于组织A的证书。那什么是CA呢，CA就是用于管理数字证书的一个组织，一般来说，任何人都可以称为CA，但是最好还是相信由政府或者大型公司这个信用度高的组织担任的CA。同样的，每个CA自身也拥有一对公私钥，组织A向CA提供自己的个人信息，例如公钥PA，电子邮箱等等。当CA收到由组织A提供的信息时，CA利用自己私钥对组织A提供的数据进行签名，得到数字签名，然后生成的数字签名和A提供的消息一起生成一个文件来发送给A，这个文件就变成了A的数字证书。</p>
<p>从现在开始，A就不向B直接发送自己的公钥PA了，取而代之的，A向B发送来自CA生成的数字证书，在那之后，B向CA索取它的公钥，并利用CA的公钥验证A发送的数字证书的真实性。数字证书中的数字签名仅仅可以用产生该数字证书的CA的公钥来验证，换句话说，如果验证不出问题，那就可以说明该数字证书确实是由该CA颁布的，然后就可以提取出数字证书中A的公钥PA了，经过这个过程，组织A向组织B传输公钥的过程就算完成了。</p>
<p>让我们看看这种公钥传递方式是否存在问题，假设一个冒充A的恶意第三方X试图传递自己的公钥。但是，B没有理由相信一个没有作为数字证书发送的公钥。那么当X冒充A在认证机构注册公钥时会发生什么？在这种情况下，X无法访问A的电子邮件账户，因此X无法获得发行证书。X只能创建使用X的电子邮件地址的证书。因此，他们无法获得属于A的证书。通过使用数字证书系统，可以验证公钥的所有者。早些时候我们说B收到了证书颁发机构的公钥，但是现在存在一个问题，B收到的公钥（PC）是否真的是由认证机构创建的？因为没有办法确认是谁自己创建了公钥，它可能是由X伪装为认证机构创建的。换句话说，我们在公钥加密中发现的同样的问题也出现在这里。实际上，认证机构的这个公钥（PC）也作为数字证书被交付，并且“签名”认证机构的数字证书的一方是更高等级的认证机构。认证机构形成了一个树形结构，高级权威机构为较低级别的机构创建数字签名。</p>
<p>为了了解这个认证机构的树状结构是如何运作的，比方说，我们有一个社会广泛信任的认证机构Y，即使新公司G想要作为认证机构开始服务，它在社会上也是没有信誉的。因此，G公司需要拥有Y公司颁发的数字证书。当然，Y公司会检查以确保G公司能够充分履行认证机构的职责。在这之后，G公司就可以宣称自己是一家赢得Y公司信任的公司。通过这样做，更大的组织可以确保小型组织的信任，形成有组织的树状结构。那么，谁在认证机构树的顶部？最高级别的证书颁发机构被称为“根证书颁发机构（root CA）”，并且自己证明其自身的有效性。另外，如果根证书颁发机构本身不是一个值得信赖的组织，它颁发的证书也不会被使用。因此，其中现在相当一部分CA是已经具有社会公信力的组织，如大公司和政府机构。</p>

  </div>
  
  <div class="article-tags">
    
  </div>
    
  

</article>

      <script>document.getElementById("loading-bar").style.width="60%";</script>
    </main>
    
<footer id="footer" class="clearfix">
	
  <div>&copy; <a href="https://oceanoverflow.github.io">Whyyy</a> Theme by <a href="http://artifact.me/" target="_blank">Art Chen</a>.</div>
  <div>Powered by <a href="https://hexo.io/" rel="external">Hexo</a>.</div>
</footer>


    <script>document.getElementById("loading-bar").style.width="80%";</script>
    <div class="overlay"></div>
  </div>
  <div class="site-sidebar">

	
	
	<div class="sidebar-switch clearfix "
		style="display: none">
		<a class="dark-btn active" data-toggle="toc">
	    <span class="icon icon-list"></span>
	    <span class="text">Index</span>
	  </a>
	  <a class="dark-btn" data-toggle="bio">
	    <span class="icon icon-person"></span>
	    <span class="text">Bio</span>
	  </a>
	</div>

	<div class="site-toc "
		style="display: none">
		
	    <div class="no-index">No Index</div>
	  
  </div>
  
	<div class="site-bio show"
		style="display: block">
		
	  <!-- About Me -->
	  <div class="about-me clearfix">
	    <div class="avatar">
	      <img src="/img/avatar.png" />
	    </div>
	    <div class="info">
	      <a class="name dark-btn" href="/about">
	        Yangyi, Yi
	      </a>
	    </div>
	    <div class="info">
	      <span class="item desc">
	        Pieces of Valuable Programming Knowledges
	      </span>
	    </div>
	  </div>
	
	  <!-- Social Icons -->
	  <div class="social clearfix">
	    
	      
	        <a href="/atom.xml" class="feed"
	          target="_blank" rel="external">
	          <span class="icon icon-feed"></span>
	        </a>
	      
	        <a href="https://github.com/oceanoverflow" class="github"
	          target="_blank" rel="external">
	          <span class="icon icon-github"></span>
	        </a>
	      
	    
	  </div>
	
	  <!-- Home & Bottom -->
	  <div class="shortcuts clearfix">
	    <div class="bk">
	      <a href="#header" class="dark-btn window-nav">
	        <span class="icon icon-chevron-thin-up"></span>
	        <span class="text">Back to Top</span>
	      </a>
	    </div>
	    <div class="bk">
	      <a href="#footer" class="dark-btn window-nav">
	        <span class="icon icon-chevron-thin-down"></span>
	        <span class="text">Go to Bottom</span>
	      </a>
	    </div>
	  </div>

	</div>

</div>

  <!-- Universal Search -->

<script type="text/javascript">
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
</script>

<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.js"><\/script>')</script>

<script src="/js/search.js"></script>
<script src="/js/app.js"></script>

<!-- Disqus -->



<!-- Swiftype -->
<!-- Please replace with your own swiftype settings -->
<!--
<script type="text/javascript">
  /* Swiftype */
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','FHMeAyBdVccJECstf-XJ','2.0.0');
</script>
-->

  <script>document.getElementById("loading-bar").style.width="100%";</script>
</body>
</html>
