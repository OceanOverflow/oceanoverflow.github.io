<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Whyyy</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://oceanoverflow.github.io/"/>
  <updated>2018-06-01T13:42:30.973Z</updated>
  <id>https://oceanoverflow.github.io/</id>
  
  <author>
    <name>Yangyi, Yi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Semaphore</title>
    <link href="https://oceanoverflow.github.io/2018/06/01/Semaphore/"/>
    <id>https://oceanoverflow.github.io/2018/06/01/Semaphore/</id>
    <published>2018-06-01T13:07:44.000Z</published>
    <updated>2018-06-01T13:42:30.973Z</updated>
    
    <content type="html"><![CDATA[<p>现在要完成一个非常简单的任务，给定很多图片的 <code>URL</code> ，将它们下载到本地，你会怎么做？</p><h2 id="Sequential"><a href="#Sequential" class="headerlink" title="Sequential"></a>Sequential</h2><p>如果你想也不想，就写下了下面这种代码，说明你是一个能干活的程序员，但这并不意味着你是一个优秀的程序员。下面的代码虽然没有什么致命的错误，但是效率非常低，程序运行时 <code>CPU</code> 大部分时间都在等待网络 <code>I/O</code> 而处于空闲状态，导致 <code>CPU</code> 的利用率非常低。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, task := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">    <span class="keyword">if</span> err := Do(idx, task); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h2><p>这种完全由相互独立的子任务组成的任务，被称为 <em>embarrassingly parallel</em> ，这种问题可以通过并行的方法提高程序的性能，而且并行程度越高，性能越好，在程序中我们通过添加 <code>go</code> 这个关键字来创建多个 <code>goroutine</code> ，使多个子任务并发执行，以减少网络 <code>I/O</code> 延迟，提高 <code>CPU</code> 的利用率 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> idx, task := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, v <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">if</span> err := Do(i, v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(idx, task)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><h2 id="Parallel-with-Semaphore"><a href="#Parallel-with-Semaphore" class="headerlink" title="Parallel with Semaphore"></a>Parallel with Semaphore</h2><p>但是通过创建多个 <code>goroutine</code> 提高并行度从而提高性能的方法有其局限性，例如一次性创建过多的网络连接，超出了进程打开文件的数量限制时，程序就会报错。所以我们需要限制单位时间内并行程序的个数，通过信号量（ <code>semaphore</code> ）来限制并行度。在 <code>golang</code> 中，我们可以使用容量为 n 的 <code>buffered channel</code> 来模拟 <code>counting semaphore</code> ，这样以来在每个子任务执行前需要通过 <code>sem &lt;- struct{}{}</code> 来获取执行许可，如果 <code>sem</code> 通道已满，说明当前已经有n个子任务正在执行，该操作就会阻塞等待，直到通道空闲。当任务执行完成后，使用 <code>&lt;-sem</code> 释放执行许可。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sem := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">8</span>) <span class="comment">// 8 jobs at once</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> idx, task := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, v <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> err := Do(i, v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">        &lt;-sem</span><br><span class="line">    &#125;(idx, task)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(sem)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在要完成一个非常简单的任务，给定很多图片的 &lt;code&gt;URL&lt;/code&gt; ，将它们下载到本地，你会怎么做？&lt;/p&gt;
&lt;h2 id=&quot;Sequential&quot;&gt;&lt;a href=&quot;#Sequential&quot; class=&quot;headerlink&quot; title=&quot;Sequenti
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Memory Mapped File</title>
    <link href="https://oceanoverflow.github.io/2018/05/31/MemoryMappedFile/"/>
    <id>https://oceanoverflow.github.io/2018/05/31/MemoryMappedFile/</id>
    <published>2018-05-31T11:05:38.000Z</published>
    <updated>2018-05-31T12:01:30.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Memory-Mapped-File"><a href="#Memory-Mapped-File" class="headerlink" title="Memory Mapped File"></a>Memory Mapped File</h1><p>内存映射文件( <code>memory mapped file</code> )与磁盘上的文件存在直接的对应关系。内存映射 <code>I/O</code> 将磁盘上的文件映射到用户进程地址空间中，这样，当我们从映射内存中获取字节时，会读取文件的相应字节。同样的，当我们将数据存储在映射内存中时，相应的字节会自动写入文件中。这样以来就可以在不使用 <code>read()</code> 或 <code>write()</code> 系统调用的情况下执行 <code>I/O</code> 操作 。</p><p><img src="http://www.tutorialsdaddy.com/wp-content/uploads/2016/11/linux-mmap.png" alt="mmap"></p><h2 id="mmap-amp-munmap"><a href="#mmap-amp-munmap" class="headerlink" title="mmap &amp; munmap"></a>mmap &amp; munmap</h2><p><code>mmap</code> 系统调用将文件或设备映射到内存中，当调用成功时，它会返回映射内存的起始地址。第一个参数 <code>addr</code> 表示文件要映射到内存中的虚拟地址，一般都为 <code>NULL</code> ，表示由内核决定合适的映射地址。第二个参数 <code>len</code> 指定映射的大小（以字节为单位），通常情况下，内核创建的映射内存的大小是内存页面大小的整数倍。第三个参数 <code>prot</code> 指定访问权限，可以是 <code>PROT_READ</code>，<code>PROT_WRITE</code> ，<code>PROT_EXEC</code> 。第四个参数 <code>flags</code> 可以是 <code>MAP_PRIVATE</code>，<code>MAP_SHARED</code> 。第五个参数 <code>fd</code> 标识映射文件的文件描述符。第六个参数 <code>offset</code> 指定了文件映射的起点。为了映射整个文件，我们将 <code>offset</code> 指定为0，将 <code>len</code> 指定为整个文件的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">mmap(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">munmap(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len);</span><br></pre></td></tr></table></figure><p>Golang中系统调用参数有些许不同，但本质是一样的。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> syscall</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mmap</span><span class="params">(fd <span class="keyword">int</span>, offset <span class="keyword">int64</span>, length <span class="keyword">int</span>, prot <span class="keyword">int</span>, flags <span class="keyword">int</span>)</span> <span class="params">(data []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Munmap</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(err error)</span></span></span><br></pre></td></tr></table></figure><h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><p>当然了，如果光介绍 <code>mmap</code> 这个系统调用就太无聊了，我们下面来看一下 <code>mmap</code> 能帮助我们干什么事情，如果你玩树莓派的话，我们可以用 <code>mmap</code> 来写一个 <code>GPIO</code> 驱动。</p><p><img src="https://cdn.shopify.com/s/files/1/2187/3161/products/450ba4cc5f96d682fde154a5e569ebf4_1024x.png?v=1520446011" alt="RasberryPi"></p><p>在树莓派的 <code>/dev</code> 目录下存在 <code>mem</code> 和 <code>gpiomem</code> 这两个文件。通过 <code>mmap</code> <code>/dev/gpiomem</code> 文件我们可以在没有 <code>root</code> 权限的情况下访问 <code>GPIO</code> 寄存器。打开 <code>/dev/gpiomem</code> 设备文件并使用 <code>mmap()</code> 函数可将 <code>GPIO</code> 寄存器映射到进程内存空间中去。<code>/dev/mem</code> 代表整个系统的内存空间。<code>/dev/gpiomem</code> 仅允许访问 <code>GPIO</code> 外设寄存器， <code>/dev/mem</code> 允许访问所有外设寄存器以及所有内存，相对来说更加危险。为了保护内存空间，最好使用 <code>/dev/gpiomem</code> 而非 <code>/dev/mem</code> 来控制 <code>GPIO</code> 寄存器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">          Rev 2 and 3 Raspberry Pi </span><br><span class="line">+-----+---------+----------+---------+-----+</span><br><span class="line">| BCM |   Name  | Physical | Name    | BCM |</span><br><span class="line">+-----+---------+----++----+---------+-----+ </span><br><span class="line">|     |    3.3v |  1 || 2  | 5v      |     |</span><br><span class="line">|   2 |   SDA 1 |  3 || 4  | 5v      |     | </span><br><span class="line">|   3 |   SCL 1 |  5 || 6  | 0v      |     |</span><br><span class="line">|   4 | GPIO  7 |  7 || 8  | TxD     | 14  |</span><br><span class="line">|     |      0v |  9 || 10 | RxD     | 15  | </span><br><span class="line">|  17 | GPIO  0 | 11 || 12 | GPIO  1 | 18  | </span><br><span class="line">|  27 | GPIO  2 | 13 || 14 | 0v      |     |</span><br><span class="line">|  22 | GPIO  3 | 15 || 16 | GPIO  4 | 23  |</span><br><span class="line">|     |    3.3v | 17 || 18 | GPIO  5 | 24  |  </span><br><span class="line">|  10 |    MOSI | 19 || 20 | 0v      |     |  </span><br><span class="line">|   9 |    MISO | 21 || 22 | GPIO  6 | 25  | </span><br><span class="line">|  11 |    SCLK | 23 || 24 | CE0     | 8   |</span><br><span class="line">|     |      0v | 25 || 26 | CE1     | 7   | </span><br><span class="line">|   0 |   SDA 0 | 27 || 28 | SCL 0   | 1   | </span><br><span class="line">|   5 | GPIO 21 | 29 || 30 | 0v      |     |</span><br><span class="line">|   6 | GPIO 22 | 31 || 32 | GPIO 26 | 12  |</span><br><span class="line">|  13 | GPIO 23 | 33 || 34 | 0v      |     |</span><br><span class="line">|  19 | GPIO 24 | 35 || 36 | GPIO 27 | 16  |</span><br><span class="line">|  26 | GPIO 25 | 37 || 38 | GPIO 28 | 20  |</span><br><span class="line">|     |      0v | 39 || 40 | GPIO 29 | 21  |</span><br><span class="line">+-----+---------+----++----+---------+-----+</span><br></pre></td></tr></table></figure><p>如果通过 <code>/dev/mem</code> 访问 <code>GPIO</code> 外设寄存器，那么我们需要确定其内存中的基地址，我们通过读取 <code>/proc/device-tree/soc/ranges</code> 来确定基地址。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    bcm2835Base = <span class="number">0x20000000</span></span><br><span class="line">    gpioOffset  = <span class="number">0x200000</span></span><br><span class="line">    memLength = <span class="number">4096</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gpioBase <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    memLock sync.Mutex</span><br><span class="line">    gpioMem  []<span class="keyword">byte</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    base := getBase()</span><br><span class="line">    gpioBase = base + gpioOffset </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBase</span><span class="params">()</span> <span class="params">(base <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    base = bcm2835Base</span><br><span class="line">    ranges, err := os.Open(<span class="string">"/proc/device-tree/soc/ranges"</span>)</span><br><span class="line">    <span class="keyword">defer</span> ranges.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">    n, err := ranges.ReadAt(b, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">if</span> n != <span class="number">4</span> || err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    buf := bytes.NewReader(b)</span><br><span class="line">    <span class="keyword">var</span> out <span class="keyword">uint32</span></span><br><span class="line">    err = binary.Read(buf, binary.BigEndian, &amp;out)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int64</span>(out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>Open</code> 函数通过映射 <code>/dev/mem</code> 文件来将 <code>GPIO</code> 寄存器映射到内存中，这样以来我们就可以通过直接改变 <code>gpioMem</code> 的值来操控 <code>GPIO</code> 寄存器了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// Open fd for rw mem access; try dev/mem first (need root)</span></span><br><span class="line">    file, err := os.OpenFile(<span class="string">"/dev/mem"</span>, os.O_RDWR|os.O_SYNC, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> os.IsPermission(err) &#123;</span><br><span class="line">        <span class="comment">// try gpiomem otherwise (some extra functions like clock and pwm setting wont work)</span></span><br><span class="line">        file, err = os.OpenFile(<span class="string">"/dev/gpiomem"</span>, os.O_RDWR|os.O_SYNC, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// FD can be closed after memory mapping</span></span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    memLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> memLock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Memory map GPIO registers to slice</span></span><br><span class="line">    gpioMem, err = syscall.Mmap(</span><br><span class="line">        <span class="keyword">int</span>(file.Fd()),</span><br><span class="line">        gpioBase,</span><br><span class="line">        memLength,</span><br><span class="line">        syscall.PROT_READ|syscall.PROT_WRITE,</span><br><span class="line">        syscall.MAP_SHARED,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Close</code> 函数使用 <code>syscall.Munmap</code> 系统调用来解除内存映射。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    memLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> memLock.Unlock()</span><br><span class="line">    <span class="keyword">if</span> err := syscall.Munmap(mem); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Memory-Mapped-File&quot;&gt;&lt;a href=&quot;#Memory-Mapped-File&quot; class=&quot;headerlink&quot; title=&quot;Memory Mapped File&quot;&gt;&lt;/a&gt;Memory Mapped File&lt;/h1&gt;&lt;p&gt;内存映射文件
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Protocol Multiplexer</title>
    <link href="https://oceanoverflow.github.io/2018/05/29/ProtocolMultiplexer/"/>
    <id>https://oceanoverflow.github.io/2018/05/29/ProtocolMultiplexer/</id>
    <published>2018-05-29T11:50:23.000Z</published>
    <updated>2018-05-29T13:22:16.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Protocol-Multiplexer"><a href="#Protocol-Multiplexer" class="headerlink" title="Protocol Multiplexer"></a>Protocol Multiplexer</h1><p>假设我们要实现一个 <code>RPC</code> 框架并且每个客户端与服务器只维护一根 <code>TCP</code> 连接，但客户端可能会同时发出很多 <code>RPC</code> 请求，服务器收到请求处理后将结果返还给客户端，现在问题来了，由于只有一根 <code>TCP</code> 连接，客户端收到的结果可能是乱序的，我们该如何将请求和答复对应起来呢，如果采取同步的方法倒是不用担心乱序的问题，但是效率肯定非常低，同步导致系统大部分时间在等待 <code>I/O</code> ，为了提高 <code>CPU</code> 的利用率，我们可以采用多路复用的方法。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ProtocolMux <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Init initializes the mux to manage messages to the given service.</span></span><br><span class="line">    Init(Service)</span><br><span class="line">    <span class="comment">// Call makes a request with the given message and returns the reply.</span></span><br><span class="line">    <span class="comment">// Multiple goroutines may call Call concurrently.</span></span><br><span class="line">    Call(Msg) Msg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Service</code> 接口仅仅指明了服务需要实现的接口，这些服务实际就是对网络库的封装，可以是 <code>TCP</code> 或者 <code>UDP</code> ，<code>Send</code> 和 <code>Recv</code> 方法不能在并发条件下使用，并发使用可能会导致数据竞争。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// ReadTag returns the muxing identifier in the request or reply message.</span></span><br><span class="line">    <span class="comment">// Multiple goroutines may call ReadTag concurrently.</span></span><br><span class="line">    ReadTag(Msg) <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">// Send sends a request message to the remote service.</span></span><br><span class="line">    <span class="comment">// Send must not be called concurrently with itself.</span></span><br><span class="line">    Send(Msg)</span><br><span class="line">    <span class="comment">// Recv waits for and returns a reply mesasge from the remote service.</span></span><br><span class="line">    <span class="comment">// Recv must not be called concurrently with itself.</span></span><br><span class="line">    Recv(Msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现多路复用的核心就在于使用 <code>pending</code> 这个 <code>map</code> 来存储还未收到答复的请求，每一个请求都有自己独一无二的标签（例如请求的序列号），每个标签对应一个答复，答复用通道 <code>chan Msg</code> 来表示，当收到该标签对应的答复时，该通道返回结果（ <code>&lt;-done</code> ），这样就可以保证请求和答复一一对应，而不用关心接收消息先后顺序的问题了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mux <span class="keyword">struct</span> &#123;</span><br><span class="line">    srv     Service</span><br><span class="line">    send    <span class="keyword">chan</span> Msg</span><br><span class="line">    mu      sync.Mutex</span><br><span class="line">    pending <span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">chan</span>&lt;- Msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mux)</span> <span class="title">Init</span><span class="params">(srv Service)</span></span> &#123;</span><br><span class="line">    m.srv = srv</span><br><span class="line">    m.pending = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">chan</span> Msg)</span><br><span class="line">    <span class="keyword">go</span> m.sendLoop()</span><br><span class="line">    <span class="keyword">go</span> m.recvLoop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sendLoop</code> 负责消息的发送，而 <code>recvLoop</code> 则会对接受到的答复进行判断标签操作，并将 <code>pending</code> 中这个标签对应的通道取出，然后向这个通道发消息从而告知对应的 <code>Call</code> 函数该请求已经处理完。这两个方法就是复用机制的体现，因为它们底层只使用一个连接来处理多个请求。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mux)</span> <span class="title">sendLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> args := <span class="keyword">range</span> m.send &#123;</span><br><span class="line">        m.srv.Send(args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mux)</span> <span class="title">recvLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        reply := m.srv.Recv()</span><br><span class="line">        tag := m.srv.Tag(reply)</span><br><span class="line">   </span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        done := m.pending[tag]</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"unexpected reply"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        done &lt;- reply</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>Call</code> 方法，整个调用过程是阻塞的，先通过 <code>ReadTag</code> 获取 <code>Msg</code> 的标签，并新建一个通道 <code>done := make(chan Msg, 1)</code> ，作为将来事件完成时的通知。并将该通道存储到 <code>pending</code> 中，通过 <code>m.send &lt;- args</code> 将消息发送到 <code>send</code> 中，<code>sendLoop</code> 会执行真正的发送操作，最后阻塞，等待结果返回（ <code>&lt;-done</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mux)</span> <span class="title">Call</span><span class="params">(args Msg)</span> <span class="params">(reply Msg)</span></span> &#123;</span><br><span class="line">    tag := m.srv.ReadTag(args)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> Msg, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> m.pending[tag] != <span class="literal">nil</span> &#123;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"mux: duplicate call tag"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    m.pending[tag] = done</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line">    </span><br><span class="line">    m.send &lt;- args</span><br><span class="line">    <span class="keyword">return</span> &lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Protocol-Multiplexer&quot;&gt;&lt;a href=&quot;#Protocol-Multiplexer&quot; class=&quot;headerlink&quot; title=&quot;Protocol Multiplexer&quot;&gt;&lt;/a&gt;Protocol Multiplexer&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Shredder &amp; Gluer</title>
    <link href="https://oceanoverflow.github.io/2018/05/28/Shredder-Gluer/"/>
    <id>https://oceanoverflow.github.io/2018/05/28/Shredder-Gluer/</id>
    <published>2018-05-28T03:38:22.000Z</published>
    <updated>2018-05-28T04:01:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shredder-amp-Gluer"><a href="#Shredder-amp-Gluer" class="headerlink" title="Shredder &amp; Gluer"></a>Shredder &amp; Gluer</h1><p>有时候我们需要向服务器上传一个很大的文件，但是无奈网络不稳定，再加上使用的软件不支持断点续传，经常会出现文件上传到一半出错，无奈只能从头再来，可以说是非常烦恼了。还有的时候服务器明确规定了单次上传文件的大小，手头又没有啥好的软件可以帮助我们进行文件的分割和合并操作，只好自己写一个。</p><p>要是一个人被砍了头，手，脚，再把这几个肢体合并起来大概率这人也是废了（在医学水平没有极大进步的情况下），但是对于一个文件来说则不同，无论什么格式的文件，其实本质上都是一大堆字节，如果我们在固定的地方进行切割，最后再在被切割的地方合并的话，这个文件还是可以被正常使用的。</p><h2 id="Get-Basic-Info"><a href="#Get-Basic-Info" class="headerlink" title="Get Basic Info"></a>Get Basic Info</h2><p>在对文件切割之前，我们需要获得文件的基本信息，即文件的大小或者说是字节数，还需要决定切割后每个单位的大小，知道了这两个参数之后，就可以算出所有分割块的数量了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">"some_very_big_file"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">fileInfo, err := f.Stat()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fileSize := fileInfo.Size()</span><br><span class="line">partSize := <span class="number">1</span> &lt;&lt; <span class="number">28</span></span><br><span class="line">concurrency := <span class="keyword">int</span>(fileSize / <span class="keyword">int64</span>(partSize))</span><br><span class="line"><span class="keyword">if</span> remainder := fileSize % <span class="keyword">int64</span>(partSize); remainder != <span class="number">0</span> &#123;</span><br><span class="line">    concurrency++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Shredder"><a href="#Shredder" class="headerlink" title="Shredder"></a>Shredder</h2><p>利用 <code>io.NewSectionReader</code> 可以读取文件特定偏移的数据，然后利用<code>buffo.NewReader</code> 来缓冲读数据，利用 <code>bufio.NewWriter</code> 来缓冲写数据提高效率，最后利用 <code>io.Copy(bw, br)</code> 将文件特定部分复制到新文件中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(concurrency)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; concurrency; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        sr := io.NewSectionReader(f, <span class="keyword">int64</span>(i * partSize), <span class="keyword">int64</span>(partSize))</span><br><span class="line">        br := bufio.NewReader(sr)</span><br><span class="line">        partFile, err := os.Create(<span class="string">"partFile_"</span> + strconv.Itoa(i))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        bw := bufio.NewWriter(partFile)</span><br><span class="line">        io.Copy(bw, br)</span><br><span class="line">    &#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><h2 id="Gluer"><a href="#Gluer" class="headerlink" title="Gluer"></a>Gluer</h2><p>合并与分割互为逆操作，因为我们对上面分割后的文件采取了顺序命名操作，所以可以根据编号的顺序，利用 <code>Seek</code> 方法指定合并文件的写偏移地址，通过 <code>bufio.NewReader</code> 对分割文件进行缓冲读操作，同理利用 <code>bufio.NewWriter</code> 对合并文件进行缓冲写操作，通过 <code>io.Copy(bw, br)</code> 将分割文件放入最终合并文件的正确位置。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">matches, err := filepath.Glob(<span class="string">"partFile_*"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mergedFile, err := os.Create(<span class="string">"mergedFile"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> matches &#123;</span><br><span class="line">    ss := strings.Split(v, <span class="string">"_"</span>)</span><br><span class="line">    i, err := strconv.Atoi(ss[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    mergedFile.Seek(<span class="keyword">int64</span>(i * partSize), os.SEEK_SET)</span><br><span class="line">    f, err := os.Open(v)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    br := bufio.NewReader(f)</span><br><span class="line">    bw := bufio.NewWriter(mergedFile)</span><br><span class="line">    io.Copy(bw, br)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Shredder-amp-Gluer&quot;&gt;&lt;a href=&quot;#Shredder-amp-Gluer&quot; class=&quot;headerlink&quot; title=&quot;Shredder &amp;amp; Gluer&quot;&gt;&lt;/a&gt;Shredder &amp;amp; Gluer&lt;/h1&gt;&lt;p&gt;有时
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TUN/TAP</title>
    <link href="https://oceanoverflow.github.io/2018/05/27/TUNTAP/"/>
    <id>https://oceanoverflow.github.io/2018/05/27/TUNTAP/</id>
    <published>2018-05-27T06:05:03.000Z</published>
    <updated>2018-05-27T06:07:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TUNTAP"><a href="#TUNTAP" class="headerlink" title="TUNTAP"></a>TUNTAP</h1><p><a href="http://tuntaposx.sourceforge.net/" target="_blank" rel="noopener">TUN/TAP</a> 为我们在 <code>macOS</code> 下面提供了虚拟网络接口（ <code>TUN/TAP</code> ），其本质是字符设备（ <code>character special file</code> ）。因为在 <code>Unix</code> 中一切皆文件，所以我们可以像操作文件一样操作这两种设备。</p><p><img src="https://1.bp.blogspot.com/-mnxh0kXQeKI/V10lx7q7H4I/AAAAAAAALYs/i427R0SfAQckApSz3piMDu7LiJnPzzu4gCLcB/s1600/tuntap.png" alt="TUNTAP"></p><p><code>TUN</code> 模拟网络层设备，它可以操作第3层数据包例如 <code>IP</code> 数据包。 <code>TAP</code> 模拟链路层设备，用于操作第2层数据包例如以太网帧。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxDevices = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrBusy        = errors.New(<span class="string">"device is already in use"</span>)</span><br><span class="line">  ErrNotReady    = errors.New(<span class="string">"device is not ready"</span>)</span><br><span class="line">  ErrExhausted   = errors.New(<span class="string">"no devices are available"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="keyword">string</span></span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">    io.ReadWriteCloser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tun</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(Interface, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> newTUN(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tap</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(Interface, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> newTAP(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TUN/TAP</code> 在 <code>/dev</code>目录下，以 <code>/dev/tunX</code> 和 <code>/dev/tapX</code> 的形式存在，<code>X</code> 从0到15。每个字符设备都与同名的网络接口关联。网络接口只有在相应的字符设备被程序打开时才会创建，并且在字符设备关闭时将被删除。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> device <span class="keyword">struct</span> &#123;</span><br><span class="line">    n <span class="keyword">string</span></span><br><span class="line">    f *os.File</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> d.n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> d.n &#125;</span><br></pre></td></tr></table></figure><p>新创建设备时，我们像正常打开文件一样使用 <code>TUN</code> 或者 <code>TAP</code> 设备，如果设备已经被占用，则报 <code>ErrBusy</code> 错误。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newDevice</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(Interface, error)</span></span> &#123;</span><br><span class="line">    file, err := os.OpenFile(name, os.O_EXCL|os.O_RWWR, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> isBusy(err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrBusy</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> &amp;device&#123;n: name, f: file&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBusy</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> perr, ok := err.(*os.PathError); ok &#123;</span><br><span class="line">        <span class="keyword">if</span> code, ok := perr.Err.(syscall.Errno); ok &#123;</span><br><span class="line">            <span class="keyword">if</span> code == <span class="number">0x10</span> || code == <span class="number">0x11</span> &#123;</span><br><span class="line">                <span class="comment">// device busy || exclusive lock</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tunX</code> 是 <code>IP</code> 隧道设备，可用于与内核交换 <code>IP</code> 数据包。使用 <code>read()</code> 获取单个数据包，使用 <code>write()</code> 可以将数据包写入 <code>/dev/tunX</code> 设备中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTUN</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(Interface, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := o; i &lt; maxDevices; i++ &#123;</span><br><span class="line">            iface, err := newDevice(<span class="string">"/dev/tun"</span> + strconv.Itoa(i))</span><br><span class="line">            <span class="keyword">if</span> err == ErrBusy &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ErrExhausted</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newDevice(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tapX</code> 是 <code>ethertap</code> 设备，为内核的以太网层提供接口。每次从 <code>/dev/tapX</code> 字符设备中读取或写入一个数据包。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTAP</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(Interface, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := o; i &lt; maxDevices; i++ &#123;</span><br><span class="line">            iface, err := newDevice(<span class="string">"/dev/tap"</span> + strconv.Itoa(i))</span><br><span class="line">            <span class="keyword">if</span> err == ErrBusy &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ErrExhausted</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newDevice(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于字符设备，可以像操作正常文件一样进行读/写操作来向设备写入数据包或者获取数据包。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    n, err := d.f.Read(p)</span><br><span class="line">    <span class="keyword">if</span> isNotReady(err) &#123;</span><br><span class="line">        err = ErrNotReady</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    n, err := d.f.Write(p)</span><br><span class="line">    <span class="keyword">if</span> isNotReady(err) &#123;</span><br><span class="line">        err = ErrNotReady </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isNotReady</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> perr, ok := err.(*os.PathError); ok &#123;</span><br><span class="line">        <span class="keyword">if</span> code, ok := perr.Err.(syscall.Errno); ok &#123;</span><br><span class="line">            <span class="keyword">if</span> code == <span class="number">0x05</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123; </span><br><span class="line">    <span class="keyword">return</span> d.f.Close() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TUNTAP&quot;&gt;&lt;a href=&quot;#TUNTAP&quot; class=&quot;headerlink&quot; title=&quot;TUNTAP&quot;&gt;&lt;/a&gt;TUNTAP&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://tuntaposx.sourceforge.net/&quot; target=&quot;_b
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Try Lock</title>
    <link href="https://oceanoverflow.github.io/2018/05/26/TryLock/"/>
    <id>https://oceanoverflow.github.io/2018/05/26/TryLock/</id>
    <published>2018-05-26T14:05:27.000Z</published>
    <updated>2018-05-26T14:11:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Try-Lock"><a href="#Try-Lock" class="headerlink" title="Try Lock"></a>Try Lock</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;...&#125;</span><br><span class="line"><span class="comment">// Lock locks m. </span></span><br><span class="line"><span class="comment">// If the lock is already in use, the calling goroutine</span></span><br><span class="line"><span class="comment">//  blocks until the mutex is available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">// <span class="title">Unlock</span> <span class="title">unlocks</span> <span class="title">m</span>. </span></span><br><span class="line"><span class="function">// <span class="title">It</span> <span class="title">is</span> <span class="title">a</span> <span class="title">run</span>-<span class="title">time</span> <span class="title">error</span> <span class="title">if</span> <span class="title">m</span> <span class="title">is</span> <span class="title">not</span> <span class="title">locked</span> <span class="title">on</span> <span class="title">entry</span> <span class="title">to</span> <span class="title">Unlock</span>. </span></span><br><span class="line"><span class="function">// </span></span><br><span class="line"><span class="function">// <span class="title">A</span> <span class="title">locked</span> <span class="title">Mutex</span> <span class="title">is</span> <span class="title">not</span> <span class="title">associated</span> <span class="title">with</span> <span class="title">a</span> <span class="title">particular</span> <span class="title">goroutine</span>. </span></span><br><span class="line"><span class="function">// <span class="title">It</span> <span class="title">is</span> <span class="title">allowed</span> <span class="title">for</span> <span class="title">one</span> <span class="title">goroutine</span> <span class="title">to</span> <span class="title">lock</span> <span class="title">a</span> <span class="title">Mutex</span> <span class="title">and</span> <span class="title">then</span></span></span><br><span class="line"><span class="function">// <span class="title">arrange</span> <span class="title">for</span> <span class="title">another</span> <span class="title">goroutine</span> <span class="title">to</span> <span class="title">unlock</span> <span class="title">it</span>.</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><code>sync.Mutex</code> 提供了 <code>Lock</code> 和 <code>Unlock</code> 两个方法分别对应上锁和解锁操作，如果锁已经被占据了，<code>Lock</code> 方法会阻塞相应的 <code>goroutine</code> 。在 <code>C</code> 中也有互斥锁的实现，但除了一般的上锁操作和解锁操作，它还多了一种方法 —— <code>pthread_mutex_trylock</code> ，也就是<code>TryLock</code> ， <code>pthread_mutex_trylock</code> 语义与 <code>pthread_mutex_lock</code> 类似，不同的是在锁已经被占据时返回 <code>EBUSY</code> 而不是挂起等待。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// lock a mutex, If the mutex is already locked, </span></span><br><span class="line"><span class="comment">// the calling thread will block until the mutex becomes available.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// unlock a mutex</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// attempt to lock a mutex without blocking</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>下面我们自己来实现一个 <code>golang</code> 版本的 <code>try lock</code> 。实现互斥锁的关键就在于原子操作，保证即使有多个 <code>CPU</code> 存在的情况下，也不能同时执行同一条指令。利用 <code>sync/atomic</code> 库下面的方法可以轻松实现对一个数的原子操作。</p><p>我们实现的互斥锁中有两个东西，首先是一个 <code>v int32</code> ，因为是互斥锁，所以初始化为1，还有一个 <code>ch</code> 通道用于唤醒阻塞等待的 <code>goroutine</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    v <span class="keyword">int32</span></span><br><span class="line">    ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m.v = <span class="number">1</span></span><br><span class="line">    m.ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Lock</code> 方法获取一个锁，如果锁被占据了，则一直阻塞等待( <code>&lt;-m.ch</code> )，等待其他 <code>goroutine</code> 唤醒，相当于 <code>PV</code> 操作中的 <code>P</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;m.v, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> v := atomic.LoadInt32(&amp;m.v); v &gt;= <span class="number">0</span> &amp;&amp; atomic.SwapInt32(&amp;m.v, <span class="number">-1</span>) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        &lt;-m.ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Unlock</code> 方法释放 <code>Mutex</code> ，如果当前有因为等待该锁而被阻塞的<code>goroutine</code> （说明 <code>atomic.SwapInt32(&amp;m.v, 1) != 0</code> ），则执行 <code>m.ch &lt;- struct{}{}</code> 将阻塞的 <code>goroutine</code> 唤醒，对应 <code>PV</code> 操作中的 <code>V</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.SwapInt32(&amp;m.v, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> m.ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>Lock</code> 方法会在锁可用之前阻塞调用该方法的 <code>goroutine</code> ，<code>TryLoad</code> 方法并不会阻塞，通过 <code>atomic.LoadInt32(&amp;m.v)</code> 来查看当前资源是否可用，如果不可用(说明 <code>v &lt;= 0</code> )，则返回 <code>false</code> ，如果 <code>atomic.CompareAndSwapInt32(&amp;m.v, 1, 0)</code> 返回 <code>true</code> ，说明资源可用直接上锁。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">TryLock</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    v := atomic.LoadInt32(&amp;m.v)</span><br><span class="line">    <span class="keyword">if</span> v &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> atomic.CompareAndSwapInt32(&amp;m.v, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Try-Lock&quot;&gt;&lt;a href=&quot;#Try-Lock&quot; class=&quot;headerlink&quot; title=&quot;Try Lock&quot;&gt;&lt;/a&gt;Try Lock&lt;/h1&gt;&lt;figure class=&quot;highlight golang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Concurrent Prime Sieve</title>
    <link href="https://oceanoverflow.github.io/2018/05/25/ConcurrentPrimeSieve/"/>
    <id>https://oceanoverflow.github.io/2018/05/25/ConcurrentPrimeSieve/</id>
    <published>2018-05-25T06:36:04.000Z</published>
    <updated>2018-05-25T10:43:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Concurrent-Prime-Sieve"><a href="#Concurrent-Prime-Sieve" class="headerlink" title="Concurrent Prime Sieve"></a>Concurrent Prime Sieve</h1><p>本科刚学编程的时候经常遇到判断一个数是不是素数之类的编程题，当时基础比较差，用的方法也相当简单粗暴，直接采用枚举法判断，虽然简单但是效率很低，时间复杂度为 <code>O(n^2)</code> ，后来慢慢了解了神奇的埃氏筛法，只用 <code>O(nlglgn)</code> 的时间复杂度就可以完成，效率大幅度提高，如果对埃氏筛不了解的童鞋可以看看这篇文章 <a href="http://empslocal.ex.ac.uk/people/staff/mrwatkin/sieve.htm" target="_blank" rel="noopener">sieve of Eratosthenes</a>。</p><p><img src="http://empslocal.ex.ac.uk/people/staff/mrwatkin/bridge1.jpg" alt="Sieve"></p><p>一般的埃氏筛实现都是单线程的，并不能完全发挥现在多核 <code>CPU</code> 的全部性能，下面给出了 <code>Golang</code> 并发版本的埃氏筛实现。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span> ;; i++ &#123;</span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(in, out <span class="keyword">chan</span> <span class="keyword">int</span>, prime <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i := &lt;-in</span><br><span class="line">        <span class="keyword">if</span> i % prime != <span class="number">0</span> &#123;</span><br><span class="line">            out &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> generate(ch)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        prime := &lt;-ch</span><br><span class="line">        fmt.Println(prime)</span><br><span class="line">        out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">        <span class="keyword">go</span> filter(ch, out, prime)</span><br><span class="line">        ch = out</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>并发版本的埃氏筛代码行数虽然不多，然而实现还是比较 <code>tricky</code> 的，谁要是第一遍就看懂算我输（你要是天才的话当我没说过）。</p><p><img src="https://talks.golang.org/2012/concurrency/images/gophereartrumpet.jpg" alt="channel"></p><p>首先要起一个 <code>goroutine</code> ，记为 <code>G</code> ， 用于生成2以后的整数，并放到通道中（记为 <code>out0</code> ）供别的 <code>goroutine</code> 读取。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> generate(ch)          <span class="comment">// ch &lt;- i</span></span><br></pre></td></tr></table></figure><p>进入第一个 <code>for</code> 循环，从上面的通道中取出第一个数2，毫无疑问，2为素数，所以创建一个通道 <code>out1</code> ，并起一个 <code>goroutine</code> ，记为 <code>filter1</code> ，用于过滤所有2的整数倍的数，此时通道数据流的走向为 <code>G -&gt; out1</code> ，只有通过 <code>filter1</code> 筛选的数才有资格进入 <code>out1</code> 中，此时将 <code>ch</code> 设为 <code>out1</code> （ <code>ch</code> 用于记录该链上的最后一个通道），第一个循环结束。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prime := &lt;-ch             <span class="comment">// &lt;-ch</span></span><br><span class="line">fmt.Println(prime)        <span class="comment">// 输出2 </span></span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)     <span class="comment">// 记作out1</span></span><br><span class="line"><span class="keyword">go</span> filter(ch, out, prime) <span class="comment">// ch -&gt; out1</span></span><br><span class="line">ch = out                  <span class="comment">// ch = out1</span></span><br><span class="line">        ^</span><br><span class="line">        |</span><br><span class="line">      +----+ </span><br><span class="line">G ---&gt;|out1|---&gt;</span><br><span class="line">      +----+    </span><br><span class="line">        %<span class="number">2</span></span><br><span class="line">        ^</span><br><span class="line">        |</span><br><span class="line">        ch</span><br></pre></td></tr></table></figure><p>进入第二个 <code>for</code> 循环，因为此时 <code>ch</code> 为 <code>out1</code> ，尝试去 <code>out1</code> 中取，3由 <code>G</code> 产生，然后经过 <code>filter1</code> 后成功进入 <code>out1</code> ，说明3是素数，此时我们再创建一个通道 <code>out2</code> ，并且再起一个 <code>goroutine</code> ，记为 <code>filter2</code> ，该 <code>goroutine</code> 会过滤所有3的整数倍的数，此时通道数据流的走向为 <code>G -&gt; out1 -&gt; out2</code> ，只有成功经过 <code>filter1,filter2</code> 筛选的数才能进入通道 <code>out2</code> 中，将 <code>ch</code> 设为 <code>out2</code> ，第二个循环结束。当<code>G</code> 中产生4，并尝试在这个链上移动时，当它经过 <code>filter1</code> 时，由于4是2的整数倍，说明不是素数，不符合要求，4出局。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prime := &lt;-ch             <span class="comment">// &lt;-out1</span></span><br><span class="line">fmt.Println(prime)        <span class="comment">// 输出3</span></span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)     <span class="comment">// 记作out2</span></span><br><span class="line"><span class="keyword">go</span> filter(ch, out, prime) <span class="comment">// out1 -&gt; out2</span></span><br><span class="line">ch = out                  <span class="comment">// ch = out2</span></span><br><span class="line"></span><br><span class="line">        ^         ^</span><br><span class="line">        |         |</span><br><span class="line">      +----+    +----+    </span><br><span class="line">G ---&gt;|out1|---&gt;|out2|---&gt;</span><br><span class="line">      +----+    +----+ </span><br><span class="line">        %<span class="number">2</span>        %<span class="number">3</span></span><br><span class="line">                   ^</span><br><span class="line">                   |</span><br><span class="line">                   ch</span><br></pre></td></tr></table></figure><p>进入第三个 <code>for</code> 循环，同样的，此时 <code>ch</code> 为 <code>out2</code> ，尝试去 <code>out2</code> 中取，5由 <code>G</code> 产生，经过 <code>filter1,filter2</code> 后成功进入 <code>out2</code> ，说明5为素数，此时我们再创建一个通道 <code>out3</code> ，并且再起一个 <code>goroutine</code> ，记为 <code>filter3</code> ，该 <code>goroutine</code> 会过滤所有5的整数倍的数，此时通道数据流的走向为 <code>G -&gt; out1 -&gt; out2 -&gt; out3</code> ，只有成功经过 <code>filter1,filter2,filter3</code> 筛选的数才能进入通道 <code>out3</code> 中，将 <code>ch</code> 设为 <code>out3</code> ，第三个循环结束。当 <code>G</code> 中产生6，并尝试在这个链上移动时，经过 <code>filter1</code> 时，由于6是2的整数倍，说明不是素数，不符合要求，同样出局。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prime := &lt;-ch             <span class="comment">// &lt;-out2</span></span><br><span class="line">fmt.Println(prime)        <span class="comment">// 输出5</span></span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)     <span class="comment">// 记作out3</span></span><br><span class="line"><span class="keyword">go</span> filter(ch, out, prime) <span class="comment">// out2 -&gt; out3</span></span><br><span class="line">ch = out                  <span class="comment">// ch=out3</span></span><br><span class="line"></span><br><span class="line">        ^         ^         ^</span><br><span class="line">        |         |         |</span><br><span class="line">      +----+    +----+    +----+    </span><br><span class="line">G ---&gt;|out1|---&gt;|out2|---&gt;|out3|---&gt;</span><br><span class="line">      +----+    +----+    +----+</span><br><span class="line">        %<span class="number">2</span>        %<span class="number">3</span>        %<span class="number">5</span>        </span><br><span class="line">                            ^</span><br><span class="line">                            |</span><br><span class="line">                            ch</span><br></pre></td></tr></table></figure><p>进入第四个 <code>for</code> 循环，此时 <code>ch</code> 为 <code>out3</code> ，尝试去 <code>out3</code> 中取，7由 <code>G</code> 产生，然后经过 <code>filter1,filter2,filter3</code> 筛选后成功进入 <code>out3</code> ，说明7是素数，此时我们再创建一个通道 <code>out4</code> ，并且再起一个 <code>goroutine</code> ，记为 <code>filter4</code> ，该 <code>goroutine</code> 会过滤所有7的整数倍的数，此时通道数据流的走向为 <code>G -&gt; out1 -&gt; out2 -&gt; out3 -&gt; out4</code> ，只有成功经过 <code>filter1,filter2,filter2,filter4</code> 筛选的数才能进入通道 <code>out4</code> 中，将 <code>ch</code> 设为 <code>out4</code> ，第四个循环结束。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prime := &lt;-ch             <span class="comment">// &lt;-out3</span></span><br><span class="line">fmt.Println(prime)        <span class="comment">// 输出7</span></span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)     <span class="comment">// 记作out4</span></span><br><span class="line"><span class="keyword">go</span> filter(ch, out, prime) <span class="comment">// out3 -&gt; out4</span></span><br><span class="line">ch = out                  <span class="comment">// ch=out4</span></span><br><span class="line"></span><br><span class="line">        ^         ^         ^         ^</span><br><span class="line">        |         |         |         |</span><br><span class="line">      +----+    +----+    +----+    +----+</span><br><span class="line">G ---&gt;|out1|---&gt;|out2|---&gt;|out3|---&gt;|out4|---&gt;</span><br><span class="line">      +----+    +----+    +----+    +----+</span><br><span class="line">        %<span class="number">2</span>        %<span class="number">3</span>        %<span class="number">5</span>        %<span class="number">7</span>            </span><br><span class="line">                                      ^</span><br><span class="line">                                      |</span><br><span class="line">                                      ch</span><br></pre></td></tr></table></figure><p>以此类推，并发版本素数筛的本质就是构建 <code>DaisyChain</code> ，每个数经过 <code>DaisyChain</code> 层层筛选后，如果最终保留，说明该数为素数，作为 <code>DaisyChain</code> 的最后一层加入，如此往复，就可以达到快速筛选素数的目的了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Concurrent-Prime-Sieve&quot;&gt;&lt;a href=&quot;#Concurrent-Prime-Sieve&quot; class=&quot;headerlink&quot; title=&quot;Concurrent Prime Sieve&quot;&gt;&lt;/a&gt;Concurrent Prime Sie
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Single Flight</title>
    <link href="https://oceanoverflow.github.io/2018/05/24/SingleFlight/"/>
    <id>https://oceanoverflow.github.io/2018/05/24/SingleFlight/</id>
    <published>2018-05-24T05:46:36.000Z</published>
    <updated>2018-05-24T06:06:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Single-Flight"><a href="#Single-Flight" class="headerlink" title="Single Flight"></a>Single Flight</h1><h2 id="SingleFlight"><a href="#SingleFlight" class="headerlink" title="SingleFlight"></a>SingleFlight</h2><p>很多人闲来无事就喜欢刷票圈逛微博，所有的消息看完一遍之后，就开启疯狂下拉刷新模式，希望能第一时间看到什么劲爆的消息。对于应用的使用者，这倒没什么，但是如果连续多次下拉刷新操作都分别对应一次服务器请求的话，那么服务器估计就得扑街了，所以我们需要限制在一定时间内同一个请求的数量，以避免无用的请求。</p><p>我们需要实现一种机制，对于特定的请求，在该请求触发之后但还没有返回结果之前，对于之后所有相同的请求，无论多少个，都不会真正触发，而是等待第一个请求返回，然后共用一个结果。</p><p><code>SingleFlight</code> 就可以帮助我们实现上述的要求，我们使用结构体 <code>call</code> 来表示特定请求返回的结果，在 <code>SingleFlight</code> 结构体中使用一个 <code>map</code> 来存储不同的请求结果，也就是一个请求对应一个<code>call</code>，并用锁保护 <code>map</code> 的读写。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SingleFlight <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="keyword">string</span>]*call</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">    wg  sync.WaitGroup</span><br><span class="line">    val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    err error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说，<code>call</code> 是一些所需时间长，消耗资源多的操作的返回结果（例如<code>HTTP</code> 请求）。<code>Do</code> 方法就保证对于同一个请求，在结果未返回之前，后面相同的请求都不会真正进行，而是等待第一个请求的结果。在函数运行时需要检测当前 <code>map</code> 是否为空，如果为空则 <code>make</code> 一个，然后检查是否有相同的请求正在进行，如果有则使用 <code>c.wg.Wait</code> 来等待执行结果。要是这个请求是该时间段内第一个请求，则将它加入 <code>map</code> 中，然后通过 <code>c.wg.Add</code> 来增加 <code>WaitGroup</code> 应该等待的 <code>goroutine</code> 个数，当函数执行完成之后，通过 <code>c.wg.Done</code> 来广播告知他人，此时任何调用<code>c.wg.Wait</code> 的地方都会解除阻塞，并返回该结果。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sf *SingleFlight)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    sf.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sf.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        sf.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> c, ok := sf.m[key]; ok &#123;</span><br><span class="line">        sf.Unlock()</span><br><span class="line">        c.wg.Wait()</span><br><span class="line">        <span class="keyword">return</span> c.val, c.err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">new</span>(call)</span><br><span class="line">    c.wg.Add(<span class="number">1</span>)</span><br><span class="line">    sf.m[key] = c</span><br><span class="line">    sf.Unlock()</span><br><span class="line"></span><br><span class="line">    c.val, c.err = fn()</span><br><span class="line">    c.wg.Done()</span><br><span class="line">    </span><br><span class="line">    sf.Lock()</span><br><span class="line">    <span class="built_in">delete</span>(sf.m, key)</span><br><span class="line">    sf.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c.val, c.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p><code>SingleFlight</code> 机制主要是靠 <code>WaitGroup</code> 实现，一般来说，因为<code>main routine</code> 不会等待 <code>goroutine</code> 执行完成，所以需要某种机制等待所有的<code>goroutine</code> 执行完成，使用 <code>WaitGroup</code> 就可以帮助我们达到这样的目的。</p><p><code>WaitGroup</code> 的本质就是一个计数器，当每起一个新的 <code>goroutine</code> 时，我们调用 <code>wg.Add(1)</code> 来增加计数器的数量，当该 <code>goroutine</code> 执行完毕时，利用 <code>wg.Done()</code> 可以将计数器减一，调用 <code>Wait()</code> 方法的地方会一直阻塞 <code>main routine</code> ，只有当计数器为0时，<code>wg</code> 才会解除阻塞，此时程序才可以继续执行下去。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</span></span><br><span class="line">    <span class="comment">// 64-bit atomic operations require 64-bit alignment, but 32-bit</span></span><br><span class="line">    <span class="comment">// compilers do not ensure it. So we allocate 12 bytes and then use</span></span><br><span class="line">    <span class="comment">// the aligned 8 bytes in them as state.</span></span><br><span class="line">    state1 [<span class="number">12</span>]<span class="keyword">byte</span></span><br><span class="line">    sema   <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> urls = []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"http://www.golang.org/"</span>,</span><br><span class="line">    <span class="string">"http://www.google.com/"</span>,</span><br><span class="line">    <span class="string">"http://www.somestupidname.com/"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">    <span class="comment">// Increment the WaitGroup counter.</span></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// Launch a goroutine to fetch the URL.</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Decrement the counter when the goroutine completes</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done() </span><br><span class="line">    <span class="comment">// Fetch the URL.</span></span><br><span class="line">    http.Get(url)</span><br><span class="line">    &#125;(url)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Wait for all HTTP fetches to complete.</span></span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Single-Flight&quot;&gt;&lt;a href=&quot;#Single-Flight&quot; class=&quot;headerlink&quot; title=&quot;Single Flight&quot;&gt;&lt;/a&gt;Single Flight&lt;/h1&gt;&lt;h2 id=&quot;SingleFlight&quot;&gt;&lt;a href
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LRU</title>
    <link href="https://oceanoverflow.github.io/2018/05/24/LRU/"/>
    <id>https://oceanoverflow.github.io/2018/05/24/LRU/</id>
    <published>2018-05-23T16:23:40.000Z</published>
    <updated>2018-05-23T16:29:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Least-Recently-Used"><a href="#Least-Recently-Used" class="headerlink" title="Least Recently Used"></a>Least Recently Used</h1><p>最近最少使用（ <code>Least Recently Used</code> ）也就是 <code>LRU</code> 算法是内存页面置换算法的一种，使用该算法可以在有限的资源内提高内存访问的速度，它利用了著名的局部性原理，更具体的说是时间局部性，也就是说如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</p><p>例如我们有3个物理块，访问序列为 <code>7，0，1，2，0，3，0</code></p><ul><li>访问7时，LRU缺失，此时LRU未满，放入7，此时淘汰顺序为7</li><li>访问0时，LRU缺失，此时LRU未满，放入0，此时淘汰顺序为7，0</li><li>访问1时，LRU缺失，此时LRU未满，放入1，此时淘汰顺序为7，0 ，1</li><li>访问2时，LRU缺失，此时LRU已满，驱逐7，放入2，此时淘汰顺序为0，1，2</li><li>访问0时，LRU命中，更新淘汰顺序，此时淘汰循序为1，2，0</li><li>访问3时，LRU缺失，此时LRU已满，驱逐1，放入3，此时淘汰顺序为2，0，3</li><li>访问0时，LRU命中，更新淘汰顺序，此时淘汰顺序为0，3，2</li></ul><p><img src="https://i.ytimg.com/vi/4wVp97-uqr0/maxresdefault.jpg" alt="LRU"></p><p>我们利用链表（ <code>*list.List</code> ）维护其淘汰顺序，利用 <code>map</code> 作为其存储引擎（作为物质基础）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;---------------------------------------------------------&gt;</span><br><span class="line">newest                                               oldest</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Key <span class="keyword">interface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    key Key</span><br><span class="line">    value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">    MaxEntries <span class="keyword">int</span></span><br><span class="line">    OnEvicted  <span class="function"><span class="keyword">func</span><span class="params">(key Key, value <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">ll</span>         *<span class="title">list</span>.<span class="title">List</span></span></span><br><span class="line"><span class="function">    <span class="title">cache</span>      <span class="title">map</span>[<span class="title">interface</span></span>&#123;&#125;]*list.Element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(maxEntries <span class="keyword">int</span>)</span> *<span class="title">Cache</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Cache&#123;</span><br><span class="line">        MaxEntries: maxEntries,</span><br><span class="line">        ll:         list.New(),</span><br><span class="line">        cache:      <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*list.Element),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们经常需要判断当前的 <code>LRU</code> 缓存是否存满，所以我们构造一个<code>helper function</code> 来获取当前缓存的容量。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.cache == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c.ll.Len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>淘汰顺序在两种情况下会更新，一是新增元素时，如果元素在 <code>LRU</code> 缓存中不存在，则将它放在链表的头部（ <code>PushFront</code> ），如果存在，则直接将其移到链表的头部（ <code>MoveToFront</code> ）。二是在获取元素时，如果元素存在，则直接将其移到链表的头部（ <code>MoveToFront</code> ）。这样一来我们就能确保最新的东西在链表头，最老的东西在链表尾。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Add</span><span class="params">(key Key, value interfacfe&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.cache == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.cache = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;*list.Element])</span><br><span class="line">        c.ll = list.New()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ee, ok := c.cache[key]; ok &#123;</span><br><span class="line">        c.ll.MoveToFront(ee)</span><br><span class="line">        ee.Value.(*entry).value = value</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ele := c.ll.PushFront(&amp;entry&#123;key, value&#125;)</span><br><span class="line">    c.cache[key] = ele</span><br><span class="line">    <span class="keyword">if</span> c.MaxEntries != <span class="number">0</span> &amp;&amp; c.ll.Len() &gt; c.MaxEntries &#123;</span><br><span class="line">        c.RemoveOldest()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Get</span><span class="params">(key Key)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.cache == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ele, hit := c.cache[key]; hit &#123;</span><br><span class="line">        c.ll.MoveToFront(ele)</span><br><span class="line">        <span class="keyword">return</span> ele.Value.(*entry).value, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RemoveOldest</code> 将最老的元素淘汰，也就是说将链表中最后一项移除，并将<code>map</code> 中对应的元素删除。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">RemoveOldest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.cache == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ele := c.ll.Back()</span><br><span class="line">    <span class="keyword">if</span> ele != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.removeElement(ele)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">removeElement</span><span class="params">(e *list.Element)</span></span> &#123;</span><br><span class="line">    c.ll.Remove(e)</span><br><span class="line">    kv := e.Value.(*entry)</span><br><span class="line">    <span class="built_in">delete</span>(c.cache, kv.key)</span><br><span class="line">    <span class="keyword">if</span> c.OnEvicted != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.OnEvicted(kv.key, kv.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清除 <code>LRU</code> 缓存只需要将链表和 <code>map</code> 设为 <code>nil</code> 就可以了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.OnEvicted != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, e := <span class="keyword">range</span> c.cache &#123;</span><br><span class="line">            kv := e.Value.(*entry)</span><br><span class="line">            c.OnEvicted(kv.key, kv.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.ll = <span class="literal">nil</span></span><br><span class="line">    c.cache = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Least-Recently-Used&quot;&gt;&lt;a href=&quot;#Least-Recently-Used&quot; class=&quot;headerlink&quot; title=&quot;Least Recently Used&quot;&gt;&lt;/a&gt;Least Recently Used&lt;/h1&gt;&lt;p&gt;最近
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Heartbeat</title>
    <link href="https://oceanoverflow.github.io/2018/05/23/Heartbeat/"/>
    <id>https://oceanoverflow.github.io/2018/05/23/Heartbeat/</id>
    <published>2018-05-23T09:52:18.000Z</published>
    <updated>2018-05-23T09:55:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Heartbeat"><a href="#Heartbeat" class="headerlink" title="Heartbeat"></a>Heartbeat</h1><p>在一个分布式集群中，个别节点出现宕机的情况并不少见，例如在一个只有一个主节点，和多个从节点的集群中，从节点发生宕机对整个系统影响倒不算太大，如果主节点宕机，系统将不能正常运行，所以必须有一个机制检测各个节点是否正常运行。</p><p>心跳机制是设计高可用性分布式系统的重要技术。心跳机制通过周期性地向其他节点发送心跳消息并等待确认来检测集群中的节点状态。当节点状态发生变化时，会通知发送心跳检测消息的节点。如果发送心跳检测消息的节点在一段时间内未收到确认，则该节点将被视为失败。这是心跳机制的基本原理。</p><p>在设计心跳时，需要考虑心跳是单向，还是双向的，单向的心跳可以保证当发送方出现问题时，接收方在一定的时间内可以检测到，而双向则可以保证双方都可以检测到对方是否出现问题。</p><p>下面我们来实现一个单向的心跳检测机制，这里存在一个主节点和多个从节点，主节点会向连接到自己的从节点定期发送心跳消息，如果从节点在规定时间内没有收到来自主节点的心跳消息，则认为主节点发生异常，然后进行相应的超时处理流程（如自己参与选举成为主节点等）。</p><h2 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h2><p>在主节点中我们维护连接到主节点的从节点的信息，使用用一个数组保存，当节点加入或者退出系统时候，分别调用 <code>Add</code> 和 <code>Del</code> 方法进行增删。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Master <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    n      <span class="keyword">int</span></span><br><span class="line">    slaves []*Slave</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">Add</span><span class="params">(s *Slave)</span></span> &#123;</span><br><span class="line">    s.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.Unlock()</span><br><span class="line">    s.n++</span><br><span class="line">    s.slaves = <span class="built_in">append</span>(s.slaves, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">Del</span><span class="params">(s *Slave)</span></span> &#123;</span><br><span class="line">    s.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.Unlock()</span><br><span class="line">    n := <span class="built_in">make</span>([]*Slave, <span class="built_in">len</span>(s.slaves)<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> m.slaves &#123;</span><br><span class="line">        <span class="keyword">if</span> x != s &#123;</span><br><span class="line">            n = <span class="built_in">append</span>(n, x)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    s.n--</span><br><span class="line">    s.slaves = n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦从节点与主节点建立连接，主节点会通过 <code>heartbeatLoop</code> 向从节点定时发送心跳消息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    s := &amp;slave&#123;</span><br><span class="line">        conn: conn,</span><br><span class="line">        connectTime: time.Now()</span><br><span class="line">    &#125;</span><br><span class="line">    m.Add(s)</span><br><span class="line">    log.Println(<span class="string">"Connected: "</span>, conn.RemoteAddr)</span><br><span class="line">    <span class="keyword">go</span> s.heartbeatLoop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Slave"><a href="#Slave" class="headerlink" title="Slave"></a>Slave</h2><p><code>slave</code> 是主节点维护的从节点的信息，<code>connectTime</code> 表示从节点第一次连接的时间，<code>exit chan struct{}</code> 用于接收退出信号，例如当从节点退出该集群时或者从节点发生宕机时，通过该机制停止向从节点发送心跳信息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slave <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    conn        net.Conn</span><br><span class="line">    connectTime time.Time</span><br><span class="line">    exit        <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>hearbeatLoop</code> 方法中，通过 <code>time.NewTicker</code> 来设置一个定时器，每隔一秒钟向从节点发送心跳消息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *slave)</span> <span class="title">heartbeatLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.conn.Close()</span><br><span class="line">        ticker.Stop()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> t := &lt;-ticker.C:</span><br><span class="line">            s.Lock()</span><br><span class="line">            c.conn.Write([]<span class="keyword">byte</span>(fmt.Sprintf(<span class="string">"heartbeat %d"</span>, time.Now())))</span><br><span class="line">            s.Unlock()</span><br><span class="line">        <span class="keyword">case</span> &lt;-s.exit:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *slave)</span> <span class="title">stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.exit &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Main-Routine"><a href="#Main-Routine" class="headerlink" title="Main Routine"></a>Main Routine</h2><h2 id="master-main"><a href="#master-main" class="headerlink" title="master main"></a>master main</h2><p>主节点通过监听相应的端口，处理与自己连接的请求，对于每个连接请求，都会起一个新的 <code>goroutine</code> 分别处理。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":8080"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> l.Close()</span><br><span class="line">    m := &amp;Master&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> m.handleConnection(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="slave-main"><a href="#slave-main" class="headerlink" title="slave main"></a>slave main</h2><p>从节点会接收来自主节点的心跳消息，并通过 <code>time.NewTimer</code> 来设置一个定时器，如果在规定的时间内没有收到来自主节点的消息，则说明心跳超时，怀疑主节点出现异常，如果在规定的时间内收到心跳消息，则通过<code>timer.Reset</code> 来重置定时器。一般来说，心跳超时的时间是心跳发送周期的3倍左右。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:8080"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timer := time.NewTimer(<span class="number">3</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    msgChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100</span>)</span><br><span class="line">            n, err := conn.Read(b)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(err)</span><br><span class="line">            &#125;</span><br><span class="line">            msgChan &lt;- <span class="keyword">string</span>(b[:n])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(conn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> m := &lt;-msgChan:</span><br><span class="line">            fmt.Println(m)</span><br><span class="line">        <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">            fmt.Println(<span class="string">"Timed out"</span>)</span><br><span class="line">            <span class="comment">// do something here</span></span><br><span class="line">            &lt;-msgChan</span><br><span class="line">        &#125;</span><br><span class="line">        timer.Reset(<span class="number">3</span> * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Heartbeat&quot;&gt;&lt;a href=&quot;#Heartbeat&quot; class=&quot;headerlink&quot; title=&quot;Heartbeat&quot;&gt;&lt;/a&gt;Heartbeat&lt;/h1&gt;&lt;p&gt;在一个分布式集群中，个别节点出现宕机的情况并不少见，例如在一个只有一个主节点，和多个
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Bitwise Operation</title>
    <link href="https://oceanoverflow.github.io/2018/05/22/BitwiseOperation/"/>
    <id>https://oceanoverflow.github.io/2018/05/22/BitwiseOperation/</id>
    <published>2018-05-22T11:28:38.000Z</published>
    <updated>2018-05-22T11:41:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bitwise-Operation"><a href="#Bitwise-Operation" class="headerlink" title="Bitwise Operation"></a>Bitwise Operation</h1><p>在计算机刚出现时的远古年代（其实也就几十年）， CPU ，内存和网络带宽都是非常珍贵的资源，在处理或者发送数据时，为了尽可能地节约资源，程序员都需要尽可能控制数据的大小，例如布尔值能用一个比特表示就绝不使用一个字节。</p><p>一般网络协议的头部通过指定特定比特来表示特定的意思，还有在很多 <code>low-level</code> 的系统编程中，位运算也非常常见。所以，位运算可以说是程序员的必备技能了，下面让我们来看几种基本的位运算吧。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> op <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BitwiseOperation <span class="keyword">interface</span> &#123;</span><br><span class="line">    AND(<span class="keyword">byte</span>, <span class="keyword">byte</span>) <span class="keyword">byte</span></span><br><span class="line">    ANDNOT(<span class="keyword">byte</span>, <span class="keyword">byte</span>) <span class="keyword">byte</span></span><br><span class="line">    OR(<span class="keyword">byte</span>, <span class="keyword">byte</span>) <span class="keyword">byte</span></span><br><span class="line">    XOR(<span class="keyword">byte</span>. <span class="keyword">byte</span>) <span class="keyword">byte</span> </span><br><span class="line">    NOT(<span class="keyword">byte</span>) <span class="keyword">byte</span>  </span><br><span class="line">    SHIFT_LEFT(<span class="keyword">byte</span>, <span class="keyword">uint</span>) <span class="keyword">byte</span></span><br><span class="line">    SHIFT_RIGHT(<span class="keyword">byte</span>, <span class="keyword">uint</span>) <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="amp-AND"><a href="#amp-AND" class="headerlink" title="&amp; (AND)"></a>&amp; (AND)</h2><p><code>AND</code> 运算符可以有选择性地将数的某位清零，除此之外，还可以检测数的奇偶性（1 &amp; a == 1）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0xAC // 10101100</span><br><span class="line">&amp; 0xF0 // 11110000</span><br><span class="line">= 0xA0 // 10100000</span><br><span class="line">          ^ ^</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (op *bitwiseOp) AND(x byte, y byte) byte &#123;</span><br><span class="line">    return x &amp; y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="amp-AND-NOT"><a href="#amp-AND-NOT" class="headerlink" title="&amp;^ (AND NOT)"></a>&amp;^ (AND NOT)</h2><p>与 <code>AND</code> 类似，<code>AND NOT</code> 也可以将特定的位清0，但是 <code>AND NOT</code> 的语义更加符合正常思维，写起来也更加直观。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   0xAB // 10101011</span><br><span class="line">&amp;^ 0x03 // 00000011</span><br><span class="line">=  0xA8 // 10101000</span><br><span class="line">           ^ ^ ^</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *op)</span> <span class="title">ANDNOT</span><span class="params">(x <span class="keyword">byte</span>, y <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp;^ y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OR"><a href="#OR" class="headerlink" title="| (OR)"></a>| (OR)</h2><p><code>OR</code> 操作可以有选择性地将一个字节的某几个比特设为1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0x00 // 00000000</span><br><span class="line">| 0xC4 // 11000100</span><br><span class="line">= 0xC4 // 11000100</span><br><span class="line">          ^^   ^</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *op)</span> <span class="title">OR</span><span class="params">(x <span class="keyword">byte</span>, y <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x | y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（XOR-NOT）"><a href="#（XOR-NOT）" class="headerlink" title="^ （XOR | NOT）"></a>^ （XOR | NOT）</h2><h3 id="Binary-XOR"><a href="#Binary-XOR" class="headerlink" title="Binary ^ (XOR)"></a>Binary ^ (XOR)</h3><p>使用 <code>XOR</code> 可以将位从一个值切换到另一个（toggle），除此之外，<code>XOR</code> 还可以用于比较两个数的符号是否相同。当 <code>(a ^ b) ≥ 0</code> 时，表示两个整数a，b具有相同的符号（或当 <code>(a ^ b) &lt; 0</code> 时表示符号相反）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0xCEFF // 1100111011111111</span><br><span class="line">^ 0xFF00 // 1111111100000000</span><br><span class="line">= 0x31FF // 0011000111111111</span><br><span class="line">              ^^   ^^^^^^^^^</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *op)</span> <span class="title">XOR</span><span class="params">(x <span class="keyword">byte</span>, y <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x ^ y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Unary-NOT"><a href="#Unary-NOT" class="headerlink" title="Unary ^ (NOT)"></a>Unary ^ (NOT)</h3><p>与其他语言（c / c ++，Java，Python，Javascript等）不同，Go没有专门的取反位运算符，但它可以用 <code>^</code> 来表示 <code>NOT</code>， 也就是按位取反。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^ 0x0F // 00001111</span><br><span class="line">= 0xF0 // 11110000</span><br><span class="line">          ^^^^</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *op)</span> <span class="title">NOT</span><span class="params">(x <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ^x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SHIFT"><a href="#SHIFT" class="headerlink" title="SHIFT"></a>SHIFT</h2><p><code>Shift</code> 操作可以和 <code>&amp;</code>  <code>|</code>  <code>&amp;^</code> 这三个操作符组合起来使用。</p><ul><li><code>a | ( 1&lt;&lt; 2)</code></li></ul><p><code>|</code> 与 <code>&lt;&lt;</code> 运算符组合可以用于设置a中的第n位。</p><ul><li><code>a &amp; (1 &lt;&lt; 2)</code></li></ul><p>或者将 <code>＆</code> 和 <code>&lt;&lt;</code> 运算符组合来测试第n位是否被设置。</p><ul><li><code>a &amp;^ (1 &lt;&lt; 2)</code></li></ul><p>使用 <code>＆^</code> 和 <code>&lt;&lt;</code>，我们可以取消设置值的第n位。</p><p>使用左右移位运算符还可以完成效率更高的乘法和除法。</p><h3 id="gt-gt-Shift-Right"><a href="#gt-gt-Shift-Right" class="headerlink" title="&gt;&gt; (Shift Right)"></a>&gt;&gt; (Shift Right)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     0x78 // 01111000</span><br><span class="line">              ^^^^</span><br><span class="line">&gt;&gt; 1 0x3C // 00111100  </span><br><span class="line">               ^^^^</span><br><span class="line">&gt;&gt; 2 0x1E // 00011110</span><br><span class="line">                ^^^^</span><br><span class="line">&gt;&gt; 3 0x0F // 00001111</span><br><span class="line">                 ^^^^</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *op)</span> <span class="title">SHIFT_RIGHT</span><span class="params">(x <span class="keyword">byte</span>, n <span class="keyword">uint</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;&gt; n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lt-lt-Shift-Left"><a href="#lt-lt-Shift-Left" class="headerlink" title="&lt;&lt; (Shift Left)"></a>&lt;&lt; (Shift Left)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     0x03 // 00000011</span><br><span class="line">                   ^^</span><br><span class="line">&lt;&lt; 1 0x60 // 00000110</span><br><span class="line">                  ^^</span><br><span class="line">&lt;&lt; 2 0xC0 // 00001100</span><br><span class="line">                 ^^</span><br><span class="line">&lt;&lt; 3 0x18 // 00011000</span><br><span class="line">                ^^</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *op)</span> <span class="title">SHIFT_LEFT</span><span class="params">(x <span class="keyword">byte</span>, n <span class="keyword">uint</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Bitwise-Operation&quot;&gt;&lt;a href=&quot;#Bitwise-Operation&quot; class=&quot;headerlink&quot; title=&quot;Bitwise Operation&quot;&gt;&lt;/a&gt;Bitwise Operation&lt;/h1&gt;&lt;p&gt;在计算机刚出现时的远
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GUID</title>
    <link href="https://oceanoverflow.github.io/2018/05/22/GUID/"/>
    <id>https://oceanoverflow.github.io/2018/05/22/GUID/</id>
    <published>2018-05-22T03:49:08.000Z</published>
    <updated>2018-05-22T03:51:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GUID"><a href="#GUID" class="headerlink" title="GUID"></a>GUID</h1><p>在点外卖或者网上购物的时候，每个订单中都会有一串独一无二的数字，但是处理订单的服务器肯定不止一台，如何保证多台服务器，也就是说一个计算机集群中，在相互独立的情况下（不沟通自己生成的订单号的信息）不生成相同的订单号码呢，下面我们就来介绍一种全球唯一标识符（ <code>GUID</code> ）的生成算法。</p><p>这里我们的 <code>GUID</code> 共64比特。<code>sequence</code> 部分占12比特，<code>nodeID</code> 占10比特，偏移10比特，时间戳 <code>timestamp</code> 占剩余的42比特，偏移22比特。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------------------+----------+------------+</span><br><span class="line">|                timestamp                  |nodeIDBits|sequenceBits|</span><br><span class="line">+-------------------------------------------+----------+------------+</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    nodeIDBits = <span class="keyword">uint64</span>(<span class="number">10</span>)</span><br><span class="line">    sequenceBits = <span class="keyword">uint64</span>(<span class="number">12</span>)</span><br><span class="line">    nodeIDShift = sequenceBits</span><br><span class="line">    timestampShift = sequenceBits + nodeIDBits</span><br><span class="line">    sequenceMask   = <span class="keyword">int64</span>(<span class="number">-1</span>) ^ (<span class="keyword">int64</span>(<span class="number">-1</span>) &lt;&lt; sequenceBits)</span><br><span class="line"></span><br><span class="line">    twepoch = <span class="keyword">int64</span>(<span class="number">1288834974288</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrIDBackwards = errors.New(<span class="string">"ID went backward"</span>)</span><br><span class="line">    ErrTimeBackwards = errors.New(<span class="string">"time has gone backwards"</span>)</span><br><span class="line">    ErrSequenceExpired = errors.New(<span class="string">"sequence expired"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>下面我们定义一个生成 <code>guid</code> 的工厂， <code>guid</code> 由 <code>timestamp</code>  ，<code>nodeID</code> 和 <code>sequence</code> 这三个部分构成，每个工厂有自己的 <code>nodeID</code>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> guid <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> guidFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Metex</span><br><span class="line">    nodeID        <span class="keyword">int64</span></span><br><span class="line">    sequence      <span class="keyword">int64</span></span><br><span class="line">    lastTimestamp <span class="keyword">int64</span></span><br><span class="line">    lastID        guid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGUIDFactory</span><span class="params">(nodeID <span class="keyword">int64</span>)</span> *<span class="title">guidFactory</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;guidFactory&#123;</span><br><span class="line">        nodeID: nodeID,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在利用工厂模式生成 <code>GUID</code> 时，首先计算当前时间戳，并且除以1048576（2的20次方），这样是为了去除时间的假随机部分，如果新生成的<code>timestamp</code> 小于 <code>lastTimestamp</code> ，则返回 <code>ErrTimeBackwards</code> 错误，对于相同的时间戳，我们的 <code>sequence</code> 采取递增策略，如果 <code>sequence</code> 达到最大值后归0，则返回 <code>ErrSequenceExpired</code> 错误，如果时间戳不相同，则令 <code>sequence</code> 重新从0开始，最后使三部分拼接组成一个新的 <code>guid</code> ，如果生成的 <code>guid</code> 小于 <code>lastID</code> ，则返回 <code>ErrIDBackwards</code> 错误，如果正常则返回结果。整个计算的过程需要由锁来保护。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *guidFactory)</span> <span class="title">Create</span><span class="params">()</span> <span class="params">(guid, error)</span></span> &#123;</span><br><span class="line">    f.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// divide by 1048576, giving pseudo-milliseconds</span></span><br><span class="line">    ts := time.Now().UnixNano() &gt;&gt; <span class="number">20</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ts &lt; f.lastTimestamp &#123;</span><br><span class="line">        f.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, ErrTimeBackwards</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> f.lastTimestamp == ts &#123;</span><br><span class="line">        f.sequence = (f.sequence + <span class="number">1</span>) &amp; sequenceMask</span><br><span class="line">        <span class="keyword">if</span> f.sequence == <span class="number">0</span> &#123;</span><br><span class="line">            f.Unlock()</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, ErrSequenceExpired</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        f.sequence = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f.lastTimestamp = ts</span><br><span class="line"></span><br><span class="line">    id := guid(((ts - twepoch) &lt;&lt; timestampShift) |</span><br><span class="line">        (f.nodeID &lt;&lt; nodeIDShift) |</span><br><span class="line">        f.sequence)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> id &lt;= f.lastID &#123;</span><br><span class="line">        f.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, ErrIDBackwards</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f.lastID = id</span><br><span class="line"></span><br><span class="line">    f.Unlock()</span><br><span class="line"></span><br><span class="line">    return id, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便结果的表示，我们会将10进制转换为16进制，利用标准库中的 <code>hex</code> 就可以轻松实现了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g guid)</span> <span class="title">Hex</span><span class="params">()</span> <span class="title">MessageID</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> h MessageID</span><br><span class="line">    <span class="keyword">var</span> b [<span class="number">8</span>]<span class="keyword">byte</span></span><br><span class="line">    </span><br><span class="line">    b[<span class="number">0</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">56</span>)</span><br><span class="line">    b[<span class="number">1</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">48</span>)</span><br><span class="line">    b[<span class="number">2</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">40</span>)</span><br><span class="line">    b[<span class="number">3</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">32</span>)</span><br><span class="line">    b[<span class="number">4</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">24</span>)</span><br><span class="line">    b[<span class="number">5</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">16</span>)</span><br><span class="line">    b[<span class="number">6</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">8</span>)</span><br><span class="line">    b[<span class="number">7</span>] = <span class="keyword">byte</span>(g)</span><br><span class="line"></span><br><span class="line">    hex.Encode(h[:], b[:])</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GUID&quot;&gt;&lt;a href=&quot;#GUID&quot; class=&quot;headerlink&quot; title=&quot;GUID&quot;&gt;&lt;/a&gt;GUID&lt;/h1&gt;&lt;p&gt;在点外卖或者网上购物的时候，每个订单中都会有一串独一无二的数字，但是处理订单的服务器肯定不止一台，如何保证多台服务器，也就是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mpg123</title>
    <link href="https://oceanoverflow.github.io/2018/05/21/mpg123/"/>
    <id>https://oceanoverflow.github.io/2018/05/21/mpg123/</id>
    <published>2018-05-21T11:12:06.000Z</published>
    <updated>2018-05-21T11:17:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mpg123"><a href="#mpg123" class="headerlink" title="mpg123"></a>mpg123</h1><p>日常生活中，我们都是使用网易云音乐之类的音乐软件听歌，但是你有没有想过，作为程序员，该如何使用命令行来听（zhuang）歌（bi）呢？今天就让我们来实现这个功能吧。</p><p>写代码，一般需要搞清楚三点，输入，输出和算法。如果使用命令行听歌，输入很明确，肯定是音频数据流，数据一般可以通过网上获取，那么输出呢，肯定就是我们耳朵中听到的声音，这两点都比较简单。关键是处理数据和输出数据的算法，之前并没有怎么搞过音乐格式编码和解码之类的东西，不过不要慌，已经有强大的 <code>mpg123</code> 这个命令行工具帮我们搞定这类事情了。</p><p><code>mpg123</code> 需要额外安装，<code>macOS</code> 用户可以使用 <code>homebrew</code> 进行安装。<code>mpg123</code> 可以帮助我们处理 <code>MPEG 1.0/2.0/2.5</code> 格式的数据流，并使用系统默认的音屏设备播放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpg123 [ options ] file-or-URL...</span><br></pre></td></tr></table></figure><p>上面是它的简单使用，<code>[options]</code> 代表额外选项，真正的参数可以是本地音频文件地址或者 <code>URL</code> 地址。一般来说 <code>file/URL</code> 都需要是 <code>MPEG</code> 格式的音频比特流（ <code>audio bit stream</code> ）。</p><p>问题的关键解决之后，下面就可以利用它写一个简单的音乐播放器了，这里播放器具有两种状态，<code>Stopped</code> 和 <code>Playing</code> ，播放器的核心操作依赖 <code>mpg123</code> 实现，<code>exec.Cmd</code> 用于代表这个命令。除此之外，还需要指定输入和输出，输入（ <code>io.ReadCloser</code> ）可以来自 <code>HTTP</code> 得到的数据流，而输出（ <code>io.WriteCloser</code> ）则是该命令的输入管道。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> State <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Stopped State = <span class="literal">iota</span></span><br><span class="line">    Playing</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Player <span class="keyword">struct</span> &#123;</span><br><span class="line">    state      State</span><br><span class="line">    currentURL <span class="keyword">string</span></span><br><span class="line">    mpg123     *exec.Cmd</span><br><span class="line">    src        io.ReadCloser</span><br><span class="line">    dst        io.WriteCloser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为播放音乐需要 <code>mpg123</code> 这个依赖，所以，在程序运行时需要检查其是否存在，<code>exec.LookPath</code> 会在系统路径（ <code>$PATH</code> ）下面寻找，如果不存在，则返回 <code>error</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPlayer</span><span class="params">()</span> <span class="params">(*Player, error)</span></span> &#123;</span><br><span class="line">    _, err := exec.LookPath(<span class="string">"mpg123"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    p := &amp;Player&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> p, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令行听歌的关键还是在于对数据流的处理，通过 <code>io.Copy</code> 方法将数据流进行重定向。 </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stream</span><span class="params">(dst io.WriteCloser, src io.ReadCloser)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> dst.Close()</span><br><span class="line">    <span class="keyword">defer</span> src.Close()</span><br><span class="line">    io.Copy(dst, src)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>mpg123</code> 需要读取音频数据流，在构造命令时，我们使用 <code>-</code> 来指定<code>mpg123</code> 从标准输入中获取数据（ <code>exec.Command(&quot;mpg123&quot;, &quot;-q&quot;, &quot;-&quot;)</code> ），通过 <code>StdinPipe()</code> 方法可以获得连接到此命令的标准输入管道。输入的数据流可以利用 <code>http.Get</code> 获取，然后再利用上述 <code>stream</code> 方法将数据流重定向到 <code>mpg123</code> 的标准输入（ <code>stdin</code> ）中去，这样就可以实现音乐播放了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Player)</span> <span class="title">Play</span><span class="params">(URL <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p.state == Playing &#123;</span><br><span class="line">        p.Stop()</span><br><span class="line">        <span class="keyword">return</span> p.Play(URL)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mpg123 := exec.Command(<span class="string">"mpg123"</span>, <span class="string">"-q"</span>, <span class="string">"-"</span>)</span><br><span class="line">    stdin, err := mpg123.StdinPipe()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        stdin.Close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    err = mpg123.Start()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        stdin.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response, err := http.Get(URL)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.state = Playing</span><br><span class="line">    p.currentURL = URL</span><br><span class="line">    p.mpg123 = mpg123</span><br><span class="line">    p.src = response.Body</span><br><span class="line">    p.dst = stdin</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> stream(p.dst, p.src)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个音乐播放器自然少不了暂停操作。因为输入和输出分别是 <code>io.ReadCloser</code> 和 <code>io.WriteCloser</code> 类型，所以都可以调用 <code>Close</code> 方法来将它们关闭。除此之外还需要将对应的 <code>mpg123</code> 的进程停掉（ <code>p.mpg123.Process.Kill()</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Player)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p.state == Stopped &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    p.state = Stopped</span><br><span class="line">    p.src.Close()</span><br><span class="line">    p.src = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    p.dst.Close()</span><br><span class="line">    p.mpg123.Process.Kill()</span><br><span class="line">    p.mpg123.Wait()</span><br><span class="line">    p.mpg123.Handler = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下最后一个问题就是如何获取各大平台音乐的链接地址，下面给获取网易云音乐歌曲外链地址的方法，这里的参数 <code>id</code> 表示音乐的 <code>id</code> ，其他平台获取方法也应该类似，感兴趣的读者可以自行寻找。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMusicLink</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    s := <span class="string">"http://music.163.com/song/media/outer/url?id=%d.mp3"</span></span><br><span class="line">    addr = fmt.Sprintf(s, id)</span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mpg123&quot;&gt;&lt;a href=&quot;#mpg123&quot; class=&quot;headerlink&quot; title=&quot;mpg123&quot;&gt;&lt;/a&gt;mpg123&lt;/h1&gt;&lt;p&gt;日常生活中，我们都是使用网易云音乐之类的音乐软件听歌，但是你有没有想过，作为程序员，该如何使用命令行来听（z
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Future</title>
    <link href="https://oceanoverflow.github.io/2018/05/20/Future/"/>
    <id>https://oceanoverflow.github.io/2018/05/20/Future/</id>
    <published>2018-05-20T06:04:59.000Z</published>
    <updated>2018-05-20T06:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p><code>Future</code> 是 <code>java</code> 中比较常见的并发编程解决方案，它采用异步的方式，尽可能减少运行时代码阻塞，很大程度上提高了程序的运行效率，在<code>golang</code> 中我们可以利用 <code>goroutine</code> ， <code>chan</code> 机制和 <code>for select</code> 轻松实现类似的功能。</p><p>其实 <code>Future</code> 的本质就是异步计算的结果，我们用 <code>item interface{}</code> 来放置 <code>Future</code> 的结果，通过读取 <code>triggered</code> 的值来判断异步计算是否已经返回。</p><p><code>New</code> 方法用于构造 <code>Future</code> 任务，它通过监听 <code>Completer</code> 通道来获取异步执行的结果，如果监听超时，则停止监听，返回错误。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Future <span class="keyword">struct</span> &#123;</span><br><span class="line">    triggered <span class="keyword">bool</span></span><br><span class="line">    item      <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    err       error</span><br><span class="line">    lock      sync.Mutex</span><br><span class="line">    wg        sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Completer &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(completer Completer, timeout time.Duration)</span> *<span class="title">Future</span></span> &#123;</span><br><span class="line">    f := &amp;Future&#123;&#125;</span><br><span class="line">    f.wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> listen(f, completer, timeout)</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>listen</code> 是获得异步计算结果的核心，如果 <code>Completer</code> 通道返回，则通过 <code>set</code> 方法设置计算结果，并标记 <code>triggered</code> 为 <code>true</code> ，如果监听超时，则同样标记 <code>triggered</code> 为 <code>true</code> ，但此时应该返回一个错误而非正确的计算结果。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">(f *Future, ch Completer, timeout time.Duration)</span></span> &#123;</span><br><span class="line">    t := time.NewTicker(timeout)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> item := &lt;-ch:</span><br><span class="line">        f.set(item, <span class="literal">nil</span>)</span><br><span class="line">        t.Stop()</span><br><span class="line">    <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">        f.set(<span class="literal">nil</span>, fmt.Errorf(<span class="string">`timeout after %f seconds`</span>, timeout.Seconds()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>Future</code> 返回结果的时机并不确定， 所以我们需要一种方式得知结果是否已经返回，<code>IsDone</code> 方法通过查询 <code>triggered</code> 是否为 <code>true</code> 来得知结果是否已经返回 ，也就是查询事件是否已经触发，这里结果返回和发生超时都可以触发事件。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Future)</span> <span class="title">IsDone</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    done := f.triggered</span><br><span class="line">    f.lock.Unlock()</span><br><span class="line">    <span class="keyword">return</span> done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以无论是结果返回，还是超时发生，我们都要通过 <code>set</code> 方法对 <code>Future</code> 进行设置，来标记 <code>Future</code> 事件完成。设置完通过 <code>f.wg.Done()</code> 来通知所有等待此结果的监听者。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Future)</span> <span class="title">set</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    f.triggered = <span class="literal">true</span></span><br><span class="line">    f.item = item</span><br><span class="line">    f.err = err</span><br><span class="line">    f.lock.Unlock()</span><br><span class="line">    f.wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>Get</code> 方法用于获得 <code>Future</code> 执行的结果，如果此时 <code>Future</code> 已经触发，那么可以直接返回结果，但是如果此时 <code>triggered</code> 为 <code>false</code> ，也就是说那两件事件中一件都没有发生，此时我们只能傻傻地等待（ <code>f.wg.Wait()</code> ） ，直到别人广播（ <code>f.wg.Done()</code> ）来告知事件已经发生。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Future)</span> <span class="title">Get</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    <span class="keyword">if</span> f.triggered &#123;</span><br><span class="line">        f.lock.Unlock()</span><br><span class="line">        <span class="keyword">return</span> f.item, f.err</span><br><span class="line">    &#125;</span><br><span class="line">    f.lock.Unlock()</span><br><span class="line">    </span><br><span class="line">    f.wg.Wait()</span><br><span class="line">    <span class="keyword">return</span> f.item, f.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是应用 <code>Future</code> 的简单例子。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">completer := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">f := New(completer, time.Duration(<span class="number">30</span>*time.Minute))</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    result, err = f.Get()</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">completer &lt;- <span class="string">`test`</span></span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Future&quot;&gt;&lt;a href=&quot;#Future&quot; class=&quot;headerlink&quot; title=&quot;Future&quot;&gt;&lt;/a&gt;Future&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Future&lt;/code&gt; 是 &lt;code&gt;java&lt;/code&gt; 中比较常见的并发编程解决方案
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ADB</title>
    <link href="https://oceanoverflow.github.io/2018/05/19/ADB/"/>
    <id>https://oceanoverflow.github.io/2018/05/19/ADB/</id>
    <published>2018-05-19T07:38:54.000Z</published>
    <updated>2018-05-19T07:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ADB"><a href="#ADB" class="headerlink" title="ADB"></a>ADB</h1><p>安卓手机相对 <code>iPhone</code> 来说生态系统更加开放，可以做各种各样酷酷的事情，例如通过自己电脑上的命令行来刷刷朋友圈之类的，下面我们来看看如何通过 <code>adb</code> 这个神器来控制我们的安卓机吧。</p><p><code>adb</code> ，全称是 <code>Android Debug Bridge</code> ，也就是安卓调试桥，实际上就是一个命令行工具（并没有这么简单），通过它，我们就可以使用一系列命令来控制我们的手机了。</p><h2 id="adb-架构"><a href="#adb-架构" class="headerlink" title="adb 架构"></a>adb 架构</h2><p>为了更好的理解，我们先来看一下 <code>adb</code> 的基本架构，在整个架构中存在三个重要的组件，<code>client</code> ，<code>ADB Server</code> 和 <code>ADB Daemon</code> 。各个组件之间通过 <code>TCP/IP</code> 或者 <code>USB</code> 进行通信来交流信息。</p><p><img src="https://3.bp.blogspot.com/-IWnB96a3IpI/WmYNlJ_lJ5I/AAAAAAAAADg/6CUlgATGJtYVwrJeTq5lzo1PxAQb2oJtQCLcBGAs/s640/android_buffer_adb_command.png" alt="ADB"></p><ul><li><p>client<br>客户端，用于向 <code>ADB Server</code> 发送命令的工具，可以是命令行工具（ <code>Terminal</code> ）或者是 <code>Android Studio</code> ，存在于我们自己电脑上。</p></li><li><p>ADB Server<br>电脑上的客户端和手机中守护进程之间的中介，类似一座桥（这就是为什么<code>adb</code> 叫做桥的原因了），主要负责两者之间的通信，在本地计算机上作为后台进程运行。我们可以通过 <code>grep</code>  <code>ps</code> 命令的输出，来发现守护进程 <code>adb</code> 正在监听的 <code>TCP</code> 端口。 </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps -e | grep adb</span><br><span class="line">adb -L tcp:5037 fork-server server --reply-fd 4</span><br></pre></td></tr></table></figure><ul><li>ADB Daemon<br>存在于手机之上的守护进程，负责接受并处理来自 <code>ADB Server</code> 的消息。类似的，我们可以通过 <code>adb shell ps | grep adbd</code> 来寻找手机上的<code>adbd</code> 进程及相应的 <code>pid</code> 。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell ps | grep adbd</span><br><span class="line">shell        13336     1   14532    812 0     0 S adbd</span><br></pre></td></tr></table></figure><p>也就是说 <code>client</code> 和 <code>adb server</code> 存在于宿主机之上，采用传统的 <code>C/S</code> 模型，而 <code>adb server</code> 通过 <code>TCP</code> 或 <code>USB</code> 来向手机上的 <code>adb daemon</code> 发送消息。</p><h2 id="adb-通信"><a href="#adb-通信" class="headerlink" title="adb 通信"></a>adb 通信</h2><p>通信肯定会涉及到协议，只有通信的双方都遵守协议才能顺利运行，下面是 <code>abd</code> 协议报文的基本结构，与 <code>HTTP</code> 协议类似，<code>abd</code> 协议同样也处于应用层。传输层既可以采用 <code>USB</code> 来传送，也可以使用我们熟悉的 <code>TCP/IP</code> 。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned command; /* command identifier constant /</span><br><span class="line">unsigned arg1; / first argument /</span><br><span class="line">unsigned arg2; / second argument /</span><br><span class="line">unsigned data_length; / length of payload (0 is allowed) /</span><br><span class="line">unsigned data_crc32; / crc32 of data payload /</span><br><span class="line">unsigned magic; / command ^ 0xffffffff */</span><br></pre></td></tr></table></figure><p>也就是说 <code>adb server</code> 和 <code>adb daemon</code> 之间可以通过两种传输协议来发送 <code>adb</code> 协议报文。</p><h3 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h3><p>采用 <code>USB</code> 进行传输时，我们需要先将手机通过数据线连接到电脑上，注意手机需要进入开发者模式，并且通过相应的权限设置，如果连接成功的话，在命令行中输入 <code>adb devices</code> 就可以看到连接的设备了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">988a1b30374e494a52device</span><br></pre></td></tr></table></figure><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>当然除了 <code>USB</code> 这种传统方式的话，我们还可以利用酷酷的 <code>TCP/IP</code> 进行通信，首先也是通过 <code>USB</code> 连接手机和电脑，并确保两者连接到同一个局域网，在命令行中输入 <code>adb tcpip 5555</code> 使得 <code>adb daemon</code> 监听 <code>5555</code> 端口，然后通过 <code>adb connect &lt;IP_OF_YOUR_ANDROID_PHONE&gt;</code> 命令来连接我们的手机，这里 <code>&lt;IP_OF_YOUR_ANDROID_PHONE&gt;</code> 代表手机的 <code>IP</code> 地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb tcpip 5555</span><br><span class="line">$ adb connect &lt;IP_OF_YOUR_ANDROID_PHONE&gt;</span><br></pre></td></tr></table></figure><p>如果连接成功，再使用 <code>adb devices</code> 命令会获得以下输出，这里的输出和上面有写不同，这里会输出 <code>192.168.1.101:5555</code> ，这样就说明我们已经成功连接，可以拔掉我们的数据线进行通信了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">192.168.1.101:5555device</span><br></pre></td></tr></table></figure><h2 id="adb-常用命令"><a href="#adb-常用命令" class="headerlink" title="adb 常用命令"></a>adb 常用命令</h2><p>正确连接上了我们的手机之后，我们就可以干各种很酷的事情了。</p><h3 id="获取版本信息"><a href="#获取版本信息" class="headerlink" title="获取版本信息"></a>获取版本信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell getprop ro.build.version.release</span><br></pre></td></tr></table></figure><h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb push [source] [destination]</span><br><span class="line">$ adb pull [device file location] [location file location]</span><br></pre></td></tr></table></figure><h3 id="screenshot-和-screenrecord"><a href="#screenshot-和-screenrecord" class="headerlink" title="screenshot 和 screenrecord"></a>screenshot 和 screenrecord</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell screencap -p /sdcard/screenshot.png</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell screenrecord /sdcard/notabletologin.mp4</span><br></pre></td></tr></table></figure><h3 id="手势模拟"><a href="#手势模拟" class="headerlink" title="手势模拟"></a>手势模拟</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell swipe x1 y1 x2 y2</span><br></pre></td></tr></table></figure><h3 id="模拟基本操作"><a href="#模拟基本操作" class="headerlink" title="模拟基本操作"></a>模拟基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Home btn</span><br><span class="line">$ adb shell input keyevent 3 </span><br><span class="line">// Back btn</span><br><span class="line">$ adb shell input keyevent 4 </span><br><span class="line">// Call</span><br><span class="line">$ adb shell input keyevent 5 </span><br><span class="line">// End call</span><br><span class="line">$ adb shell input keyevent 6 </span><br><span class="line">// Turn Android device ON and OFF. It will toggle device to on/off status.</span><br><span class="line">$ adb shell input keyevent 26  </span><br><span class="line">// Camera</span><br><span class="line">$ adb shell input keyevent 27 </span><br><span class="line">// Open browser</span><br><span class="line">$ adb shell input keyevent 64 </span><br><span class="line">// Enter</span><br><span class="line">$ adb shell input keyevent 66 </span><br><span class="line">// Delete (backspace)</span><br><span class="line">$ adb shell input keyevent 67 </span><br><span class="line">// Contacts</span><br><span class="line">$ adb shell input keyevent 207 </span><br><span class="line">// Brightness down/up</span><br><span class="line">$ adb shell input keyevent 220 / 221 </span><br><span class="line">// Cut/Copy/Paste</span><br><span class="line">$ adb shell input keyevent 277 / 278 /279 </span><br><span class="line">// https://developer.android.com/reference/android/view/KeyEvent.html</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ADB&quot;&gt;&lt;a href=&quot;#ADB&quot; class=&quot;headerlink&quot; title=&quot;ADB&quot;&gt;&lt;/a&gt;ADB&lt;/h1&gt;&lt;p&gt;安卓手机相对 &lt;code&gt;iPhone&lt;/code&gt; 来说生态系统更加开放，可以做各种各样酷酷的事情，例如通过自己电脑上的命令行来刷
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Connection Limiter</title>
    <link href="https://oceanoverflow.github.io/2018/05/15/ConnectionLimiter/"/>
    <id>https://oceanoverflow.github.io/2018/05/15/ConnectionLimiter/</id>
    <published>2018-05-15T02:18:24.000Z</published>
    <updated>2018-05-15T11:36:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Connection-Limiter"><a href="#Connection-Limiter" class="headerlink" title="Connection Limiter"></a>Connection Limiter</h1><p>作为服务提供商，我们肯定是希望越多客户使用我们的服务越好，为此我们不惜花大价钱雇程序员来搞高并发服务器编程，砸很多的钱买最好的服务器，但是总有些无良用户想要和我们作对，搞很多 <code>HTTP</code> 连接请求恶意占用服务器的资源，导致其他用户的服务体验下降，从而最终导致客户的流失，这种情况我们肯定是希望极力避免的。</p><p>一般来说，正常的客户端（人为操作）不会在短时间内对同一服务发送过多的请求，只有想要实施恶意攻击行为的客户端（例如爬虫）才会同时发送很多请求来占用服务器的资源。为了避免这种情况的发生，我们需要限制同一个 <code>IP</code> 地址的请求数量。</p><p>实现连接限制的思路比较简单，我们通过一个 <code>map</code> 来记录来自同一个 <code>IP</code> 地址的 <code>HTTP</code> 请求的个数，如果在正常范围内，则给予该客户端正常的服务，如果超过上限，此时该客户端被怀疑正在进行爬虫之类的非善意行为，对此我们返回一个错误并拒绝服务该请求。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ConnLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    connections      <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span></span><br><span class="line">    maxConnections   <span class="keyword">int64</span></span><br><span class="line">    totalConnections <span class="keyword">int64</span></span><br><span class="line">    next             http.Handler</span><br><span class="line">    errHandler       ErrorHandler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(next http.Handler, maxConnections <span class="keyword">int64</span>)</span> <span class="params">(*ConnLimiter, error)</span></span> &#123;</span><br><span class="line">    cl := &amp;ConnLimiter &#123;</span><br><span class="line">        maxConnections: maxConnections,</span><br><span class="line">        connections: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>),</span><br><span class="line">        next: next,</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> cl.errHandler == <span class="literal">nil</span> &#123;</span><br><span class="line">        cl.errHandler = defaultErrHandler</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cl, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们是对同一个<code>IP</code> 地址设置连接限制，故对于每个请求，通过读取请求 <code>http.Request</code> 中的 <code>RemoteAddr</code> 来获取 <code>IP</code> 地址。但是上有政策，下游对策，很多写爬虫的人通过代理 <code>IP</code> 池来规避这种审查，这里我们先不讨论如何处理这种情况。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">extractClientIP</span><span class="params">(req *http.Request)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">    vals := strings.SplitN(req.RemoteAddr, <span class="string">":"</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(vals[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, <span class="number">0</span>, fmt.Errorf(<span class="string">"Failed to parse client IP: %v"</span>, req.RemoteAddr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vals[<span class="number">0</span>], <span class="number">1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还需要定义当同一个 <code>IP</code> 地址的连接数量超过最高连接数量的错误 <code>MaxConnError</code> 以及处理该错误的方法。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MaxConnError <span class="keyword">struct</span> &#123;</span><br><span class="line">    max <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MaxConnError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"max connections reached: %d"</span>, m.max)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConnErrHandler <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConnErrHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    statusCode := http.StatusInternalServerError</span><br><span class="line">    w.WriteHeader(statusCode)</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(http.StatusText(statusCode)))   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultErrHandler = &amp;ConnErrHandler&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>acquire</code> 和 <code>release</code> 方法在加锁的条件下对 <code>map</code> 进行操作，这是因为在并发情况下对同一个数据进行读写操作时，会发生数据竞争的情况，所以需要使用 <code>sync.Mutex</code> 来对数据读写进行保护。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl *ConnLimiter)</span> <span class="title">acquire</span><span class="params">(token <span class="keyword">string</span>, amount <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    cl.Lock()</span><br><span class="line">    <span class="keyword">defer</span> cl.Unlock()</span><br><span class="line"></span><br><span class="line">    connections := cl.connections[token]</span><br><span class="line">    <span class="keyword">if</span> connections &gt;= cl.maxConnections &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;MaxConnError&#123;max: cl.maxConnections&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cl.connections[token] += amount</span><br><span class="line">    cl.totalConnections += amount</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl *ConnLimiter)</span> <span class="title">release</span><span class="params">(token <span class="keyword">string</span>, amount <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    cl.Lock()</span><br><span class="line">    <span class="keyword">defer</span> cl.Unlock()</span><br><span class="line"></span><br><span class="line">    cl.connections[token] -= amount</span><br><span class="line">    cl.totalConnections -= amount</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> cl.connections[token] == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(cl.connections, token)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在提供服务（ <code>ServeHTTP</code> ）之前，我们通过 <code>acquire</code> 判断该客户端是否有资格获得服务，如果有资格则使用正常的 <code>handler</code> 来处理，否则则使用 <code>errHandler</code> 来处理，最后服务完了需要将相关资源释放（ <code>release</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl *ConnLimiter)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    token, amount, err := extractClientIP(r)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Errorf(<span class="string">"failed to extract source of the connection: %v"</span>, err)</span><br><span class="line">        cl.errHandler.ServeHTTP(w, r)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = cl.acquire(token, amount); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Debugf(<span class="string">"limiting request source %s: %v"</span>, token, err)</span><br><span class="line">        cl.errHandler.ServeHTTP(w, r)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> cl.release(token, amount)</span><br><span class="line"></span><br><span class="line">    cl.next.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl *ConnLimiter)</span> <span class="title">Wrap</span><span class="params">(h http.Handler)</span></span> &#123;</span><br><span class="line">    cl.next = h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Connection-Limiter&quot;&gt;&lt;a href=&quot;#Connection-Limiter&quot; class=&quot;headerlink&quot; title=&quot;Connection Limiter&quot;&gt;&lt;/a&gt;Connection Limiter&lt;/h1&gt;&lt;p&gt;作为服务提供
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Terminal UI</title>
    <link href="https://oceanoverflow.github.io/2018/05/14/TerminalUI/"/>
    <id>https://oceanoverflow.github.io/2018/05/14/TerminalUI/</id>
    <published>2018-05-14T14:49:04.000Z</published>
    <updated>2018-05-15T11:43:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Terminal-UI"><a href="#Terminal-UI" class="headerlink" title="Terminal UI"></a>Terminal UI</h1><p>之前用命令行版本的网易云音乐来听歌（ <code>musicbox</code> ，在 <code>github</code> 上可以搜索到），觉得实在是太 <code>geek</code> 了，但它是用 <code>python</code> 写的，略微容易崩，所以决定试着用 <code>golang</code> 仿造一个，第一步肯定是模仿它的 <code>UI</code> 了，在浏览器中我们用三元老 <code>HTML/CSS/JS</code> 可以很容易撸出一套能看的前端界面来，但估计没几个人知道命令行版本的 <code>UI</code> 应该怎么搞，其实说实话我也不知道，大概搜了一下，发现用 <code>termui</code> 这个库就可以比较轻松撸出一个与 <code>musicbox</code> 类似的界面了，下面我们来看一下如何用代码来实现吧。</p><h2 id="termui-安装"><a href="#termui-安装" class="headerlink" title="termui 安装"></a>termui 安装</h2><p>一般来说我们可以使用 <code>go get</code> 来进行获取安装，但最好使用 <code>dep</code> 来帮助我们管理项目的相关依赖。</p><p><code>go get -u github.com/gizak/termui</code></p><p>然后在代码中 <code>import</code> 就可以了。</p><p><code>import &quot;github.com/gizak/termui&quot;</code></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在使用 <code>termui</code> 时需要先进行初始化（ <code>termui.Init()</code> ），并且最后还要释放资源 <code>defer termui.Close()</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">err := termui.Init()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> termui.Close()</span><br></pre></td></tr></table></figure><h2 id="界面相关数据准备"><a href="#界面相关数据准备" class="headerlink" title="界面相关数据准备"></a>界面相关数据准备</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">strs := []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"   0. 排行榜"</span>,</span><br><span class="line">    <span class="string">"   1. 艺术家"</span>,</span><br><span class="line">    <span class="string">"   2. 新碟上架"</span>,</span><br><span class="line">    <span class="string">"   3. 精选歌单"</span>,</span><br><span class="line">    <span class="string">"   4. 我的歌单"</span>,</span><br><span class="line">    <span class="string">"   5. 主播电台"</span>,</span><br><span class="line">    <span class="string">"   6. 每日推荐"</span>,</span><br><span class="line">    <span class="string">"   7. 私人FM"</span>,</span><br><span class="line">    <span class="string">"   8. 搜索"</span>,</span><br><span class="line">    <span class="string">"   9. 帮助"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">off := []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"   0. 排行榜"</span>,</span><br><span class="line">    <span class="string">"   1. 艺术家"</span>,</span><br><span class="line">    <span class="string">"   2. 新碟上架"</span>,</span><br><span class="line">    <span class="string">"   3. 精选歌单"</span>,</span><br><span class="line">    <span class="string">"   4. 我的歌单"</span>,</span><br><span class="line">    <span class="string">"   5. 主播电台"</span>,</span><br><span class="line">    <span class="string">"   6. 每日推荐"</span>,</span><br><span class="line">    <span class="string">"   7. 私人FM"</span>,</span><br><span class="line">    <span class="string">"   8. 搜索"</span>,</span><br><span class="line">    <span class="string">"   9. 帮助"</span>,</span><br><span class="line">&#125;</span><br><span class="line">on := []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"[-&gt; 0. 排行榜](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 1. 艺术家](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 2. 新碟上架](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 3. 精选歌单](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 4. 我的歌单](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 5. 主播电台](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 6. 每日推荐](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 7. 私人FM](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 8. 搜索](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 9. 帮助](fg-cyan)"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义界面参数"><a href="#定义界面参数" class="headerlink" title="定义界面参数"></a>定义界面参数</h2><p>在使用 <code>termui</code> 时，我们需要确定界面元素及其属性，以及它在命令行中的排版，其实 <code>UI</code> 就是对数据的一种呈现，反正就是你觉得怎么好看就怎么来。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls := termui.List()</span><br><span class="line">ls.Items = strs</span><br><span class="line">ls.ItemFgColor = termui.ColorWhite</span><br><span class="line">ls.BorderLabel = <span class="string">"网易云音乐"</span></span><br><span class="line">ls.Height = <span class="number">12</span></span><br><span class="line">ls.Width = <span class="number">20</span></span><br><span class="line">ls.Y = <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="termui对事件的处理"><a href="#termui对事件的处理" class="headerlink" title="termui对事件的处理"></a>termui对事件的处理</h2><p><code>termui</code> 对事件的处理和 <code>HTTP</code> 处理事件的做法类似，我们需要对不同的事件注册回调函数，例如检测到用户输入 <code>q</code> ，我们注册一个类似的回调函数就可以了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">termui.Handle(<span class="string">"/sys/kbd/q"</span>, <span class="function"><span class="keyword">func</span><span class="params">(termui.Event)</span></span> &#123;</span><br><span class="line">    termui.StopLoop()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>相关事件可以是键盘输入，界面点击，窗口伸缩甚至可以是自定义事件。相关事件触发后，对应的数据可能会发生改变，这样以来用户界面就需要发生改变，我们可以使用 <code>termui.Render</code> 对界面重新进行渲染。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cursor := <span class="number">0</span></span><br><span class="line">termui.Render(ls)</span><br><span class="line">termui.Handle(<span class="string">"/sys/kbd/j"</span>, <span class="function"><span class="keyword">func</span><span class="params">(termui.Event)</span></span> &#123;</span><br><span class="line">    strs[cursor%<span class="built_in">len</span>(strs)] = off[cursor%<span class="built_in">len</span>(strs)]</span><br><span class="line">    cursor++</span><br><span class="line">    <span class="keyword">if</span> cursor == <span class="built_in">len</span>(strs) &#123;</span><br><span class="line">        cursor = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    strs[cursor%<span class="built_in">len</span>(strs)] = on[cursor%<span class="built_in">len</span>(strs)]</span><br><span class="line">    termui.Render(ls)</span><br><span class="line">&#125;)</span><br><span class="line">termui.Handle(<span class="string">"/sys/kbd/k"</span>, <span class="function"><span class="keyword">func</span><span class="params">(termui.Event)</span></span> &#123;</span><br><span class="line">    strs[cursor%<span class="built_in">len</span>(strs)] = off[cursor%<span class="built_in">len</span>(strs)]</span><br><span class="line">    cursor--</span><br><span class="line">    <span class="keyword">if</span> cursor &lt; <span class="number">0</span> &#123;</span><br><span class="line">        cursor = <span class="built_in">len</span>(strs) - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    strs[cursor%<span class="built_in">len</span>(strs)] = on[cursor%<span class="built_in">len</span>(strs)]</span><br><span class="line">    termui.Render(ls)</span><br><span class="line">&#125;)</span><br><span class="line">termui.Loop()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Terminal-UI&quot;&gt;&lt;a href=&quot;#Terminal-UI&quot; class=&quot;headerlink&quot; title=&quot;Terminal UI&quot;&gt;&lt;/a&gt;Terminal UI&lt;/h1&gt;&lt;p&gt;之前用命令行版本的网易云音乐来听歌（ &lt;code&gt;musicbox&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Job Dispatcher</title>
    <link href="https://oceanoverflow.github.io/2018/05/13/JobDispatcher/"/>
    <id>https://oceanoverflow.github.io/2018/05/13/JobDispatcher/</id>
    <published>2018-05-13T13:34:24.000Z</published>
    <updated>2018-05-30T05:40:07.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Job-Dispatcher"><a href="#Job-Dispatcher" class="headerlink" title="Job Dispatcher"></a>Job Dispatcher</h1><p>当处理大量计算密集型任务时，为了提高工作效率，常常会引入多台服务器同时进行处理，但是不同的服务器之间并不清楚自己该处理哪个任务，也就是说服务器自己并不能保证自己处理的任务和别人的任务是不一样的。为了解决上述问题，我们引入 <code>Job Dispatcher</code> 模型。</p><p>我们把处理任务的服务器称为 <code>Worker</code> ，而把分配任务的服务器称为<code>Dispatcher</code> 或者 <code>Master</code> 。<code>Dispatcher</code> 负责给当前处于空闲状态的 <code>Worker</code> 分配任务 （ <code>Job</code> ），当其处理完分配的任务之后，为了不让自己的 <code>CPU</code> 闲置，<code>Worker</code> 会通知 <code>Dispather</code> 自己是可用的（ <code>available</code> ） ，然后 <code>Dispatcher</code> 就可以继续向 <code>Worker</code> 分配任务，直到所有任务全都完成。这样的模型非常 <code>scalable</code> ，引入的 <code>Worker</code> 数量越多，任务完成得越快。</p><h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><p>一个任务我们用结构体 <code>Job</code> 来表示，现在对于此结构体中有什么我们并不关心，这个需要由业务逻辑具体定义。</p><p> <code>Worker</code> 中有三个 <code>channel</code> ，分别用于暂停，接收任务和通知 <code>Dispatcher</code> 任务完成用的。</p><p><code>Worker</code> 肯定需要某种机制停止退出，我们用一个 <code>exit chan struct{}</code> 通道来接收停止信号，如果该通道中收到了停止信号，也就可以说明今天的任务已经全部完成了，<code>Worker</code> 可以回家休息了。</p><p><code>Jobs chan Job</code> 通道很简单，当然就是用于接受任务的啦，相对来说，任务可是做不完的，一个任务做完下一个任务就马不停蹄的赶来了，所以用通道来表示可以说是再合适不过了。</p><p>最后来看一下最复杂的一个通道 <code>WorkerPool chan chan Job</code> ，这啥玩意啊，通道的通道？想想就头大，外层的通道的中包含了 <code>chan Job</code> ，也就是上面说过的 <code>Jobs</code> 通道，其实就代表 <code>Worker</code> 本身， 如果一个 <code>Job</code> 处理完了， <code>Worker</code> 就会处于空闲状态，所以就可以把它放在 <code>WorkerPool</code> 中等待 <code>Dispatcher</code> 来调度了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">    Payload <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">    WorkerPool <span class="keyword">chan</span> <span class="keyword">chan</span> Job</span><br><span class="line">    Jobs       <span class="keyword">chan</span> Job</span><br><span class="line">    exit       <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorker</span><span class="params">(workerPool <span class="keyword">chan</span> <span class="keyword">chan</span> Job)</span> *<span class="title">Worker</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Worker&#123;</span><br><span class="line">        WorkerPool: workerPool,</span><br><span class="line">        Jobs:       <span class="built_in">make</span>(<span class="keyword">chan</span> Job),</span><br><span class="line">        exit:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Stop</code> 方法向 <code>exit</code> 通道发送信号，这样一来 <code>Start</code> 方法中的 <code>select</code> 语句的第二个 <code>case</code> 就会被执行，<code>Worker</code> 就可以退出了。在 <code>Start</code> 方法中，<code>w.WorkerPool &lt;- w.Jobs</code> 会向 <code>WorkerPool</code> 中注册它自己，也就相当于向 <code>Dispatcher</code> 申明自己已经处于空闲状态，随时等待被调度。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            w.WorkerPool &lt;- w.Jobs</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> job := &lt;- w.Jobs:</span><br><span class="line">                <span class="comment">// do some heavy job here</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-w.exit:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        w.exit &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h2><p>所有的任务都是从外界来的（此处我们选择从 <code>JobQueue</code> 中读取），任务到来时并不会直接分配给 <code>Worker</code> ，而是先经过 <code>Dispatcher</code> 的魔爪，<code>Dispatcher</code> 会先判断哪个 <code>Worker</code> 处于空闲状态，然后再分配给空闲的 <code>Worker</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> JobQueue <span class="keyword">chan</span> Job</span><br></pre></td></tr></table></figure><p><code>Dispatcher</code> 结构体中的 <code>WorkerPool chan chan Job</code> 是任务调度实现的核心，我们上述 <code>Worker</code> 中的和 <code>Dispatcher</code> 中的其实是一个东西，<code>Worker</code> 中的是对 <code>Dispatcher</code> 中的一个引用而已。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dispatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">    WorkerPool <span class="keyword">chan</span> <span class="keyword">chan</span> Job</span><br><span class="line">    MaxWorkers <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDispatcher</span><span class="params">(maxWorkers <span class="keyword">int</span>)</span> *<span class="title">Dispatcher</span></span> &#123;</span><br><span class="line">    pool := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> Job, maxWorkers)</span><br><span class="line">    <span class="keyword">return</span> &amp;Dispatcher&#123;</span><br><span class="line">        WorkerPool: pool,</span><br><span class="line">        MaxWorkers: maxWorkers,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Run</code> 方法中起了 <code>MaxWorkers</code> 个 <code>Worker</code> 等待 <code>Dispatcher</code> 给自己分配任务。</p><p>在 <code>dispatch</code> 方法中，<code>Dispatcher</code> 会不断的从 <code>JobQueue</code> 中读取任务，并在 <code>WorkerPool</code> 中选取一个空闲的 <code>Worker</code> （ <code>worker := &lt;-d.WorkerPool</code> ），然后将任务分配给它（ <code>worker &lt;- job</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dispatcher)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; d.MaxWorkers; i++ &#123;</span><br><span class="line">        worker := NewWorker(d.WorkerPool)</span><br><span class="line">        worker.Start()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> d.dispatch()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dispatcher)</span> <span class="title">dispatch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> job := &lt;- JobQueue:</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(job Job)</span></span> &#123;</span><br><span class="line">                worker := &lt;-d.WorkerPool</span><br><span class="line">                worker &lt;- job</span><br><span class="line">            &#125;(job)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Work-scheduler"><a href="#Work-scheduler" class="headerlink" title="Work scheduler"></a>Work scheduler</h2><ul><li>Use a buffered channel as a concurrent blocking queue.</li><li>Use coroutines to let independent concerns run independently </li><li>Use the race detector for development and even production.</li><li>Think carefully before introducing unbounded queuing</li><li>Close a channel to signal that no more values will be sent.</li><li>Know why and when each communication will proceed.</li><li>Make sure you know why and when each goroutine will exit.</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Schedule</span><span class="params">(servers []<span class="keyword">string</span>, numTask <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">         call <span class="keyword">func</span>(srv <span class="keyword">string</span>, task <span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">    work := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, numTask)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    runTasks := <span class="function"><span class="keyword">func</span><span class="params">(srv <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> task := <span class="keyword">range</span> work &#123;</span><br><span class="line">            <span class="keyword">if</span> call(srv, task) &#123;</span><br><span class="line">                done &lt;- <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                work &lt;- task</span><br><span class="line">            &#125;             </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> srv := &lt;-servers:</span><br><span class="line">                <span class="keyword">go</span> runTasks(srv)</span><br><span class="line">            <span class="keyword">case</span> &lt;-exit:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> task := <span class="number">0</span>; task &lt; numTask; task++ &#123;</span><br><span class="line">        work &lt;- task</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numTask; i++ &#123;</span><br><span class="line">        &lt;-done</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(work)</span><br><span class="line">    exit &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Job-Dispatcher&quot;&gt;&lt;a href=&quot;#Job-Dispatcher&quot; class=&quot;headerlink&quot; title=&quot;Job Dispatcher&quot;&gt;&lt;/a&gt;Job Dispatcher&lt;/h1&gt;&lt;p&gt;当处理大量计算密集型任务时，为了提高工作效率
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Reverse Proxy</title>
    <link href="https://oceanoverflow.github.io/2018/05/12/ReverseProxy/"/>
    <id>https://oceanoverflow.github.io/2018/05/12/ReverseProxy/</id>
    <published>2018-05-12T13:30:04.000Z</published>
    <updated>2018-05-15T11:57:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reverse-Proxy"><a href="#Reverse-Proxy" class="headerlink" title="Reverse Proxy"></a>Reverse Proxy</h1><p>在正常的 <code>HTTP</code> 服务流程中，客户端向服务器发送 <code>HTTP</code> 请求，服务器收到后会向客户端返回一个 <code>HTTP</code> 答复。但在实际生产环境中，真正处理请求的服务器和客户端之间通常还会引入一个中介，也就是反向代理服务器，在引入了反向代理服务器之后，客户端会先将请求发送给反向代理服务器，反向代理收到该 <code>HTTP</code> 请求后，并不会自己亲自处理该请求，而是将请求转发给真正的处理业务逻辑的服务器，让它去处理，业务逻辑服务器处理完之后，会先将答复返回给反向代理服务器，再由反向代理服务器返回给客户端。</p><p>生活中常见的 <code>NGINX</code> 就常常作为反向代理服务器来使用。那么你可能会问，传统 <code>C/S</code> 模型难道不够好吗，还非要引入一个不知道什么鬼的反向代理来捣乱，引入之后只会把架构变得更复杂，有啥好处？（傲娇状）其实原因很简单，第一反向代理服务器可以当作防火墙来用，它为真正的业务逻辑服务器与外界可能的恶意攻击之间提供了一个屏障，尤其是像银行这种对安全性要求极高的金融机构无论加几个这样的防火墙都不会嫌多。第二点就是它可以提供负载均衡功能，通过使用不同的策略将请求转发给不同的服务器，以达到负载均衡的目的。</p><p>幸运的是，引入反向代理，并不会改变传统的 <code>C/S</code> 编程模型，因为客户端无法感知反向代理服务器的存在，他们只会觉得反向代理服务器就是真正处理业务逻辑的服务器。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/67/Reverse_proxy_h2g2bob.svg/1200px-Reverse_proxy_h2g2bob.svg.png" alt="Reverse Proxy"></p><p>下面我们来实现一个简单的反向代理服务器吧，虽然听着很恐怖，但是不用慌，强大的 <code>Golang</code> 标准库已经实现了反向代理的功能了。<code>httputil</code> 中提供的 <code>ReverseProxy</code> 结构体具有将请求重定向的能力（ <code>Director</code> ），也具有将答复修改的能力（ <code>ModifyResponse</code> ），最重要的是，可以通过 <code>Transport</code> 这个 <code>http.RoundTripper</code> 将我们的代理请求发送出去。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReverseProxy <span class="keyword">struct</span> &#123;</span><br><span class="line">    Director      <span class="function"><span class="keyword">func</span><span class="params">(*http.Request)</span></span></span><br><span class="line"><span class="function">    <span class="title">Transport</span>     <span class="title">http</span>.<span class="title">RoundTripper</span></span></span><br><span class="line"><span class="function">    <span class="title">FlushInterval</span> <span class="title">time</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function">    <span class="title">ErrorLog</span>      *<span class="title">log</span>.<span class="title">Logger</span></span></span><br><span class="line"><span class="function">    <span class="title">BufferPool</span>    <span class="title">BufferPool</span></span></span><br><span class="line"><span class="function">    <span class="title">ModifyReponse</span> <span class="title">func</span><span class="params">(*http.Response)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">RoundTripper</span> <span class="title">interface</span></span> &#123;</span><br><span class="line">    RoundTrip(*http.Request) (*http.Response, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为一个代理服务器，虽然不直接处理业务逻辑，但是最基本的对请求的处理和答复的功能还是要有的，与一般的 <code>HTTP</code> 服务器类似，我们的反向代理服务器 <code>ReverseProxy</code> 也需要有 <code>ServeHTTP(http.ResponseWriter, *http.Request)</code> 这样的方法。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(http.ResponseWriter, *http.Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以为了实现代理请求的功能，我们需要定义一个结构体 <code>handler</code> ，使其实现 <code>ServeHTTP(http.ResponseWriter, *http.Request)</code> 方法，在该方法中我们通过 <code>httputil.NewSingleHostReverseProxy</code> 来构造一个反向代理，并将请求通过 <code>proxy.ServeHTTP(w, r)</code> 方法将请求代理到随机的（随机是为了实现负载均衡）服务器上。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">servers := []<span class="keyword">string</span>&#123;</span><br><span class="line">     <span class="string">"111.222.111.222"</span>,</span><br><span class="line">     <span class="string">"222.111.222.111"</span>,</span><br><span class="line">     <span class="string">"111.233.111.233"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> handler <span class="keyword">struct</span> &#123;</span><br><span class="line">    reverseProxy <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *handler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    addr := servers[rand.Intn(<span class="built_in">len</span>(servers))]</span><br><span class="line">    remote, err := url.Parse(<span class="string">"http://"</span> + addr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    proxy := httputil.NewSingleHostReverseProxy(remote)</span><br><span class="line">    proxy.ServeHTTP(w, r)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们申明一个 <code>http.Server</code> ，在 <code>StartServer</code> 中我们监听指定的端口（ <code>bind</code> ），其对应的 <code>Handler</code> 就是我们之前实现的 <code>handler</code> 结构体，用于把请求代理到 <code>remote</code> 上去，这样以来一个基本的反向代理服务器就实现好了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> srv http.Server</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartServer</span><span class="params">(bind <span class="keyword">string</span>, remote <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"Listening on %s, forwarding to %s"</span>, bind, remote)</span><br><span class="line">    h := &amp;handler&#123;reverseProxy: remote&#125;</span><br><span class="line">    srv.Addr = bind</span><br><span class="line">    srv.Handler = h</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := srv.ListenAndServe(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(<span class="string">"ListenAndServe:"</span> err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StopServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := srv.Shutdown(<span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    StartServer(<span class="string">":8080"</span>, <span class="string">"remote:8080"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中的采用的负载均衡算法只用了非常简单的随机选取策略，这只适合每台服务器性能差别不大的情况，如果服务器之间性能差距较大，我们可以使用 <code>Weighted Round Robin</code> 这样的负载均衡算法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Reverse-Proxy&quot;&gt;&lt;a href=&quot;#Reverse-Proxy&quot; class=&quot;headerlink&quot; title=&quot;Reverse Proxy&quot;&gt;&lt;/a&gt;Reverse Proxy&lt;/h1&gt;&lt;p&gt;在正常的 &lt;code&gt;HTTP&lt;/code&gt; 服务流
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Advisory Lock</title>
    <link href="https://oceanoverflow.github.io/2018/05/12/AdvisoryLock/"/>
    <id>https://oceanoverflow.github.io/2018/05/12/AdvisoryLock/</id>
    <published>2018-05-12T05:26:04.000Z</published>
    <updated>2018-05-15T11:33:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Advisory-Lock"><a href="#Advisory-Lock" class="headerlink" title="Advisory Lock"></a>Advisory Lock</h1><p>很多时候，在操作系统中，对于特定应用，我们只希望起一个进程实例，但是操作系统并没有限制同一个应用进程的个数，也就是说，在每个应用运行前，我们需要检测进程是否存在。</p><p>那么如何检测进程是否已经存在了呢，我们可以在进程启动时，生成一个以 <code>.pid</code> 结尾的文件，并向这个文件上加一个建议性锁（ <code>advisory lock</code> ），这样如果有第二个这个的进程起来，它会试着去打开这个 <code>.pid</code> 文件，并试着向这个文件加建议性锁，但由于先起来的进程已经加过锁了，所以第二个进程就没有办法再加锁了，第二个进程知道自己不是第一个起起来的，所以就选择退出。</p><p>等等，刚才说的建议性锁又是什么呢，建议性锁就好像人们指定的一系列规则， 例如交通法规建议人们红灯停，绿灯行，这里的红绿灯就是一个建议性锁，但是总有不听话的人不遵守这些规则，也就是说无视建议性锁的存在。建议性锁并不是强制性的，进程可以选择不去遵守它。</p><p>上面进程的例子就是这样，第二个进程如果观测到文件已经上锁了，如果它不是恶意进程，那么它会选择尊重规则选择退出。</p><h2 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h2><p>下面我们来实现一个文件锁，文件锁的本质就是文件，所以我们选择对 <code>os.File</code> 做一层封装，然后对它添加额外的行为使其成为一个真正的文件锁。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LockFile <span class="keyword">struct</span> &#123;</span><br><span class="line">    *os.File</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLockFile</span><span class="params">(file *os.File)</span> *<span class="title">LockFile</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;LockFile&#123;file&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对文件上锁和解锁的过程其实就是利用系统调用 <code>syscall.Flock</code>，下面是c语言中的系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_SH 1 <span class="comment">/* shared lock */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_EX 2 <span class="comment">/* exclusive lock */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_NB 4 <span class="comment">/* don't block when locking */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_UN 8 <span class="comment">/* unlock */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">flock(<span class="keyword">int</span> fd, <span class="keyword">int</span> operation)</span><br></pre></td></tr></table></figure><p>建议性锁分为两大类：共享锁（ <code>SH</code> ）和专有锁（ <code>EX</code> ），这里我们采用专有锁，也就是利用 <code>LOCK_EX</code> 选项，如果文件已经上过锁了，再次尝试对该文件上锁时，操作会被阻塞，为了避免调用此系统调用的进程被阻塞，我们在系统调用时增加一个 <code>LOCK_NB</code> 选项，也就是非阻塞（ <code>non blocking</code> ）的意思，指定该选项后如果尝试上锁时，文件已经上过锁了，此时则则不会发生阻塞而是返回一个 <code>EWOULDBLOCK</code> 错误，当对文件解锁时，只需要在系统调用时指定 <code>LOCK_UN</code> 选项就可以了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ErrWouldBlock = errors.New(<span class="string">"Resource temporarily unavailable"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *LockFile)</span> <span class="title">Lock</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lockFile(file.Fd())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lockFile</span><span class="params">(fd <span class="keyword">uintptr</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    err := syscall.Flock(<span class="keyword">int</span>(fd), syscall.LOCK_EX|syscall.LOCK_NB)</span><br><span class="line">    <span class="keyword">if</span> err == syscall.EWOULDBLOCK &#123;</span><br><span class="line">        err = ERRWouldBlock</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *LockFile)</span> <span class="title">Unlock</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unlockFile(file.Fd())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unlockFile</span><span class="params">(fd <span class="keyword">uintptr</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    err := syscall.Flock(<span class="keyword">int</span>(fd), syscall.LOCK_UN)</span><br><span class="line">    <span class="keyword">if</span> err == syscall.EWouldBLOCK &#123;</span><br><span class="line">        err = ErrWouldBlock</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>OpenLockFile</code> 方法很简单，就是对 <code>os.OpenFile</code> 方法进行了一层封装，将此方法返回的 <code>file</code> 封装为<code>LockFile</code> 返回供接下去使用。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenLockFile</span><span class="params">(name <span class="keyword">string</span>, perm os.FileMode)</span> <span class="params">(lock *LockFile, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> file *os.File</span><br><span class="line">    <span class="keyword">if</span> file, err = os.OpenFile(name, os.O_RWWR|os.O_CREATE, perm); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        lock = &amp;LockFile&#123;file&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程存在性检测"><a href="#进程存在性检测" class="headerlink" title="进程存在性检测"></a>进程存在性检测</h2><p>文件上锁可以用作进程存在性检测，我们在进程创建时生成一个以 <code>.pid</code> 结尾的文件，并向该文件中写入当前进程的进程号，下面的 <code>WritePid</code> 方法就将当前进程的进程号写入文件起始位置，而 <code>ReadPid</code> 则将此文件中存储的 <code>pid</code> 读取出来，注意这里无论是读操作还是写操作都会先将文件的指针定位到最开始的位置（通过 <code>file.Seek(0, os.SEEK_SET)</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *LockFile)</span> <span class="title">WritePid</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err = file.Seek(<span class="number">0</span>, os.SEEK_SET); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fileLen <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> fileLen, err = fmt.Fprint(file, os.Getpid()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = file.Truncate(<span class="keyword">int64</span>(fileLen)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    err = file.Sync()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *LockFile)</span> <span class="title">ReadPid</span><span class="params">()</span> <span class="params">(pid <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err = file.Seek(<span class="number">0</span>, os.SEEK_SET); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    _, err = fmt.Fscan(file, &amp;pid)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *LockFile)</span> <span class="title">Remove</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err := file.Unlock(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os.Remove(file.Name())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们创建一个 <code>pid</code> 文件时候，我们需要检测其他进程是否已经存在，<code>CreatePidFile</code> 方法会使用 <code>Lock</code> 方法尝试对文件上锁，如果上锁失败，则说明已经有进程对该文件上过锁，此时则应该选择退出，如果上锁成功，则说明自己是第一个进程，并将自己的进程号写入该文件中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreatePidFile</span><span class="params">(name <span class="keyword">string</span>, perm os.FileMode)</span> <span class="params">(lock *LockFile, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> lock, err = OpenLockFile(name, perm); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = lock.Lock(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        lock.Remove()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = lock.WritePid(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        lock.Remove()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadPidFile</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(pid <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> file *os.File</span><br><span class="line">    <span class="keyword">if</span> file, err = os.OpenFile(name, os.O_RDONLY, <span class="number">0640</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    lock := &amp;LockFile&#123;file&#125;</span><br><span class="line">    pid, err = lock.ReadPid()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Advisory-Lock&quot;&gt;&lt;a href=&quot;#Advisory-Lock&quot; class=&quot;headerlink&quot; title=&quot;Advisory Lock&quot;&gt;&lt;/a&gt;Advisory Lock&lt;/h1&gt;&lt;p&gt;很多时候，在操作系统中，对于特定应用，我们只希望起一
      
    
    </summary>
    
    
  </entry>
  
</feed>
