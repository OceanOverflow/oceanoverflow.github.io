<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Whyyy</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://oceanoverflow.github.io/"/>
  <updated>2018-06-17T08:27:47.804Z</updated>
  <id>https://oceanoverflow.github.io/</id>
  
  <author>
    <name>Yangyi, Yi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>World Cup</title>
    <link href="https://oceanoverflow.github.io/2018/06/17/WorldCup/"/>
    <id>https://oceanoverflow.github.io/2018/06/17/WorldCup/</id>
    <published>2018-06-17T07:18:49.000Z</published>
    <updated>2018-06-17T08:27:47.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="World-Cup"><a href="#World-Cup" class="headerlink" title="World Cup"></a>World Cup</h1><p>四年一度的世界杯最近正在俄罗斯如火如荼的进行，昨天看了西班牙🇪🇸对葡萄牙🇵🇹的比赛，C罗真的是太帅了，帽子戏法，不过作为一个伪球迷-真程序员，准备写一点和世界杯有关的东西，想想用机器学习预测比赛结果好像并没有什么卵用，于是就写一个最简单的搬砖程序来提醒自己比赛时间吧。最终效果如下所示，典型的 <code>MVC</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Costa Rica                       <span class="number">0</span> - <span class="number">0</span>                           Serbia</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">⚽  Will be played <span class="number">4</span> hours from now</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Germany                          <span class="number">0</span> - <span class="number">0</span>                           Mexico</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">⚽  Will be played <span class="number">7</span> hours from now</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Brazil                           <span class="number">0</span> - <span class="number">0</span>                      Switzerland</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">⚽  Will be played <span class="number">10</span> hours from now</span><br></pre></td></tr></table></figure><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>比赛相关的数据可以从 <code>http://worldcup.sfg.io/</code> 获取，我们使用结构体定义数据模型，注意结构体中的数据字段必须为大写，否则无法正确 <code>Unmarshal</code>，如果想要使结构体中的字段与 <code>json</code> 中的字段不同，可以额外增加 <code>tag</code> 来说明。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> match <span class="keyword">struct</span> &#123;</span><br><span class="line">    Time     <span class="keyword">string</span> <span class="string">`json:"time,omitempty"`</span></span><br><span class="line">    DateTime <span class="keyword">string</span> <span class="string">`json:"datetime,omitempty"`</span></span><br><span class="line">    HomeTeam team   <span class="string">`json:"home_team,ommitempty"`</span></span><br><span class="line">    AwayTeam team   <span class="string">`json:"away_team,omitempty"`</span></span><br><span class="line">    Winner   <span class="keyword">string</span> <span class="string">`json:"winner,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> team <span class="keyword">struct</span> &#123;</span><br><span class="line">    Country <span class="keyword">string</span> <span class="string">`json:"country,omitempty"`</span></span><br><span class="line">    Code    <span class="keyword">string</span> <span class="string">`json:"code,omitempty"`</span></span><br><span class="line">    Goals   <span class="keyword">int</span>    <span class="string">`json:"goals,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(endpoint)</span> <span class="params">([]match, error)</span></span> &#123;</span><br><span class="line">    url := fmt.Sprintf(<span class="string">"http://worldcup.sfg.io/%s"</span>, endpoint)</span><br><span class="line">    res, err := http.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">    b, err := ioutil.ReadAll(res.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> matches []match</span><br><span class="line">    err = json.Unmarshal(b, &amp;matches)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matches, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>因为我们的 <code>layout</code> 相对比较复杂，所以 <code>View</code> 部分代码也最多，但难度不大，就是繁琐，主要注意几点，彩色字体输出，不同情况下进度条的展示效果和各个字段所在的位置。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> status <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    PAST status = <span class="literal">iota</span></span><br><span class="line">    NOW</span><br><span class="line">    FUTURE</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ScreenWidth = <span class="number">72</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    START = <span class="string">"\x1b[32m"</span></span><br><span class="line">    END   = <span class="string">"\x1b[0m"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">colorize</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> START + s + END</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(c <span class="keyword">rune</span>, n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cs []<span class="keyword">rune</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        cs = <span class="built_in">append</span>(cs, c)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(cs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prettify</span><span class="params">(m match)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    t, _ := time.Parse(time.RFC3339, m.DateTime)</span><br><span class="line">    diff := <span class="keyword">int</span>(time.Now().Sub(t).Seconds())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> status status</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> diff &gt; <span class="number">60</span>*<span class="number">90</span>:</span><br><span class="line">        status = PAST</span><br><span class="line">    <span class="keyword">case</span> diff &lt; <span class="number">0</span>:</span><br><span class="line">        status = FUTURE</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        status = NOW</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    percentage := <span class="number">0</span></span><br><span class="line">    matchStatus := <span class="string">""</span></span><br><span class="line">    on := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> status &#123; </span><br><span class="line">    <span class="keyword">case</span> PAST:</span><br><span class="line">        percentage = <span class="number">100</span></span><br><span class="line">        <span class="keyword">var</span> result <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">if</span> m.Winner == <span class="string">"Draw"</span> &#123;</span><br><span class="line">            result = <span class="string">"Draw"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = fmt.Sprintf(<span class="string">"%s won"</span>, m.Winner)</span><br><span class="line">        &#125;</span><br><span class="line">        matchStatus = fmt.Sprintf(<span class="string">"Played %s. %s"</span>, humanize.Time(t), result)</span><br><span class="line">        on = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> NOW:</span><br><span class="line">        percentage = <span class="keyword">int</span>(diff / <span class="number">60</span> / <span class="number">90</span> * <span class="number">100</span>)</span><br><span class="line">        matchStatus = fmt.Sprintf(<span class="string">"Being played now: %s minutes gone"</span>, humanize.Time(t))</span><br><span class="line">        on = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> FUTURE:</span><br><span class="line">        percentage = <span class="number">0</span></span><br><span class="line">        matchStatus = fmt.Sprintf(<span class="string">"Will be played %s"</span>, humanize.Time(t))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    home := m.HomeTeam</span><br><span class="line">    away := m.AwayTeam</span><br><span class="line"></span><br><span class="line">    s, e := <span class="string">""</span>, <span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> on &#123;</span><br><span class="line">        s = start</span><br><span class="line">        e = end</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"    %s%-32s %d - %d %32s%s\n    %s\n    \u26BD  %s\n"</span>,</span><br><span class="line">        s,home.Country,home.Goals,away.Goals,away.Country,e,</span><br><span class="line">        progressBar(percentage),</span><br><span class="line">        matchStatus,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">progressBar</span><span class="params">(percentage <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> bar <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> percentage &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        bar = multiply(<span class="string">'-'</span>, ScreenWidth)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">        bar = colorize(multiply(<span class="string">'-'</span>, ScreenWidth))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        completed := <span class="keyword">int</span>(<span class="keyword">float64</span>(ScreenWidth) / <span class="number">100.0</span> * <span class="keyword">float64</span>(percentage))</span><br><span class="line">        bar = colorize(multiply(<span class="string">'-'</span>, completed<span class="number">-1</span>)+<span class="string">"o"</span>) + multiply(<span class="string">'-'</span>, ScreenWidth-completed)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p><code>Controller</code> 部分就是将 <code>Model</code> 部分和 <code>view</code> 部分代码整合在一起。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    matches, err := fetch(<span class="string">"matches/today"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, match := <span class="keyword">range</span> matches &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            fmt.Println()</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(prettify(match))</span><br><span class="line">        <span class="keyword">if</span> i != <span class="built_in">len</span>(matches)<span class="number">-1</span> &#123;</span><br><span class="line">            fmt.Println()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;World-Cup&quot;&gt;&lt;a href=&quot;#World-Cup&quot; class=&quot;headerlink&quot; title=&quot;World Cup&quot;&gt;&lt;/a&gt;World Cup&lt;/h1&gt;&lt;p&gt;四年一度的世界杯最近正在俄罗斯如火如荼的进行，昨天看了西班牙🇪🇸对葡萄牙🇵🇹
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Snappy</title>
    <link href="https://oceanoverflow.github.io/2018/06/15/Snappy/"/>
    <id>https://oceanoverflow.github.io/2018/06/15/Snappy/</id>
    <published>2018-06-15T09:00:01.000Z</published>
    <updated>2018-06-15T09:03:56.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Snappy"><a href="#Snappy" class="headerlink" title="Snappy"></a>Snappy</h1><p><code>Snappy</code> 是 <code>Google</code> 开发的压缩和解压缩的库，最初使用 <code>C++</code> 编写，后来又造了一个 <code>golang</code> 版本的轮子。由于目前该压缩算法还没有放到 <code>go</code> 的标准库中去，所以需要通过 <code>go get -u github.com/golang/snappy</code> 安装。</p><p>与其他常见的压缩算法相比，<code>Snappy</code> 存在的目的并不是为了获得最大程度的压缩比，正如其名字所言，它旨在保持合理的压缩比的同时最大限度地提高压缩和解压缩的速度。</p><p><code>Snappy</code> 对数据处理速度上做了很大的优化，但它并不是没有缺点，相对于其他算法来说，<code>Snappy</code> 压缩得到的文件体积会更大一点。如果你更在意压缩速度而不是压缩比的话，<code>Snappy</code> 可能会是一个很好的选择。</p><h2 id="compression"><a href="#compression" class="headerlink" title="compression"></a>compression</h2><p>下面，我们对比一下 <code>Snappy</code> 压缩算法和其他两种常见的压缩算法（ <code>zlib</code> 和 <code>gzip</code> ）的性能。首先，我们定一个 <code>Compressor</code> 接口，并使 <code>Zlib</code> ，<code>Gzip</code> 和 <code>Snappy</code> 这三个结构体均实现它。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Zlib <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Gzip <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Snappy <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Compressor <span class="keyword">interface</span> &#123;</span><br><span class="line">    Compress(io.Writer, io.Reader) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(_ *Zlib)</span> <span class="title">Compress</span><span class="params">(w io.Writer, r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    zw, err := zlib.NewWriterLevel(w, zlib.BestSpeed)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> zw.Close()</span><br><span class="line"></span><br><span class="line">    _, err = io.Copy(zw, r)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(_ *Gzip)</span> <span class="title">Compress</span><span class="params">(w io.Writer, r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    gw, err := gzip.NewWriterLevel(w, gzip.BestSpeed)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> gw.Close()</span><br><span class="line"></span><br><span class="line">    _, err = io.Copy(gw, r)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="snappy"><a href="#snappy" class="headerlink" title="snappy"></a>snappy</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(_ *Snappy)</span> <span class="title">compress</span><span class="params">(w io.Writer, r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    sw := snappy.NewBufferedWriter(w)</span><br><span class="line">    <span class="keyword">defer</span> sw.Close()</span><br><span class="line"></span><br><span class="line">    _, err := io.Copy(sw, r)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h2><p>对于压缩的性能，可以从压缩比和压缩时间这两点进行衡量。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, err := os.Open(<span class="string">"somebigfile"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fGzip, _ := os.Create(<span class="string">"gzip"</span>)</span><br><span class="line">    fZlib, _ := os.Create(<span class="string">"zlib"</span>)</span><br><span class="line">    fSnappy, _ := os.Create(<span class="string">"snappy"</span>)</span><br><span class="line"></span><br><span class="line">    cs := <span class="keyword">map</span>[compressor]io.Writer&#123;</span><br><span class="line">        &amp;Gzip&#123;&#125;:   fGzip,</span><br><span class="line">        &amp;Zlib&#123;&#125;:   fZlib,</span><br><span class="line">        &amp;Snappy&#123;&#125;: fSnappy,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> c, v := <span class="keyword">range</span> cs &#123;</span><br><span class="line">        t := time.Now()</span><br><span class="line">        err := c.compress(v, f)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">        d := time.Since(t)</span><br><span class="line">        fmt.Printf(<span class="string">"method: %s, time spend: %.02f, ratio: %.05f%%\n"</span>, </span><br><span class="line">        v.Name(), </span><br><span class="line">        d.Seconds(), </span><br><span class="line">        compressionRatio(f, v))</span><br><span class="line">        f.Seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compressionRatio</span><span class="params">(f1, f2 *os.File)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    f1s, _ := f1.Stat()</span><br><span class="line">    f1size := f1s.Size()</span><br><span class="line">    f2s, _ := f2.Stat()</span><br><span class="line">    f2size := f2s.Size()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(f2size) / <span class="keyword">float64</span>(f1size) * <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Snappy</code> 在速度上来说比 <code>zlib</code> 和 <code>gzip</code> 快得多，但文件相对要大 <code>20%</code> 到 <code>100%</code>。在 <code>64</code> 位模式的 <code>Core i7</code> 处理器上，<code>Snappy</code> 可以达到 <code>250~500</code> 兆每秒的压缩速度，可以说是非常惊人了。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">method:   gzip, time spend: 8.38s, ratio:  7.576%</span><br><span class="line">method:   zlib, time spend: 9.13s, ratio:  7.576%</span><br><span class="line">method: snappy, time spend: 1.96s, ratio: 18.813%</span><br></pre></td></tr></table></figure><p>相比其他的压缩库，<code>Snappy</code> 能在保持特定的压缩率下拥有惊人的压缩速度，压缩普通文本文件的速度是其他库的 <code>1.5-1.7</code> 倍，HTML能达到 <code>2-4</code> 倍，但是对于 <code>JPEG</code>、<code>PNG</code> 以及其他的已压缩的数据，压缩速度不会有明显改善。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Snappy&quot;&gt;&lt;a href=&quot;#Snappy&quot; class=&quot;headerlink&quot; title=&quot;Snappy&quot;&gt;&lt;/a&gt;Snappy&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Snappy&lt;/code&gt; 是 &lt;code&gt;Google&lt;/code&gt; 开发的压缩和解压缩的库，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Timing Wheel</title>
    <link href="https://oceanoverflow.github.io/2018/06/14/TimingWheel/"/>
    <id>https://oceanoverflow.github.io/2018/06/14/TimingWheel/</id>
    <published>2018-06-14T01:20:25.000Z</published>
    <updated>2018-06-14T01:47:52.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Timing-Wheel"><a href="#Timing-Wheel" class="headerlink" title="Timing Wheel"></a>Timing Wheel</h1><p><img src="https://www.confluent.io/wp-content/uploads/2016/08/TimingWheels1.png" alt="timingwheel"></p><p>当我们自己编写服务端程序时候，可能需要新建大量的定时器，对每个 <code>TCP</code> 连接设置连接超时，面对成千上万的客户端连接，如果傻傻地为每一个连接分配一个计时器的话，那么 <code>10k</code> 个连接就对应 <code>10k</code> 的计时器，<code>10w</code> 个连接就对应 <code>10w</code> 个计时器，这种方法显然是比较消耗内存的。</p><p>对于需要大量定时器的情况，由于许多定时器是在相近的时间超时的，或者说在一个时间范围内到时的，如果对时间精度没有那么近乎苛刻的要求的话，我们可以利用这个特性将多个同一时间段的计时器整合成一个来使用，这样的话就可以极大程度上降低内存的消耗，例如现在有 <code>3，4，5，6</code> 四个连接，它们均会在后面的3到4秒内超时，我们可以采用一种方法使它们共用一个计数器，并当时间点到来时，它们均可以被通知到。</p><h2 id="closed-channel"><a href="#closed-channel" class="headerlink" title="closed channel"></a>closed channel</h2><p>也就是说，我们需要一个机制来重复利用某一个计时器，换句话说，当时间点到来时，我们需要一种广播的机制让等待该计时器的都能被通知到。</p><p>为此需要利用 <code>golang</code> 中通道的几个特性，我们通过一个例子来理解一下，在下面的函数中 <code>make</code> 了一个 <code>unbuffered channel</code> ch，还新起了3个 <code>goroutine</code> ，每个<code>goroutine</code> 会执行 <code>fmt.Println(&quot;start &quot;, i)</code> ，但等它们都执行到 <code>&lt;-ch</code> 语句时，由于没有其他 <code>goroutine</code> 执行 <code>ch &lt;- struct{}{}</code> 操作，所以3个 <code>goroutine</code> 都会阻塞，当 <code>time.Sleep(1 * time.Second)</code> 结束时，我们利用 <code>close(ch)</code> ，此操作相当于向每个 <code>goroutine</code> 进行 <code>ch &lt;- struct{}{}</code> ，此时阻塞解除，每个 <code>goroutine</code> 都可以继续执行 <code>fmt.Println(&quot;end &quot;, i)</code> 。也就是说 <code>close(ch)</code> 相当于一个广播操作。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        i := i</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"start "</span>, i)</span><br><span class="line">            &lt;-ch</span><br><span class="line">            fmt.Println(<span class="string">"end "</span>, i)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子利用到了通道的的第一个特性和第三个特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. The expression blocks until a value is available. </span><br><span class="line">2. Receiving from a nil channel blocks forever. </span><br><span class="line">3. A receive operation on a closed channel can always proceed immediately, yielding the element type’s zero value after any previously sent values have been received.</span><br></pre></td></tr></table></figure><h2 id="timing-wheel"><a href="#timing-wheel" class="headerlink" title="timing wheel"></a>timing wheel</h2><p>那么上面的例子和我们要实现的东西有什么联系呢，其实联系非常大，我们可以给每一个需要进行定时操作的 <code>goroutine</code> 一个 <code>unbuffered channel</code><br>，并且给予在相同时间点超时的 <code>goroutine</code> 以同样的通道。然后我们自己维护一个 <code>ticker</code> ，这个 <code>ticker</code> 每隔固定的时间，将相应的通道关闭，这相当于一个广播操作，这样每个等待此广播的 <code>goroutine</code> 都会收到消息，也就可以继续执行下去了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TimingWheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line"></span><br><span class="line">    interval   time.Duration</span><br><span class="line">    maxTimeout time.Duration </span><br><span class="line">    </span><br><span class="line">    ticker     *time.Ticker</span><br><span class="line">    cs         []<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    pos        <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    stop       <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(interval time.Duration, buckets <span class="keyword">int</span>)</span> *<span class="title">TimingWheel</span></span> &#123;</span><br><span class="line">    w := &amp;TimingWheel&#123;</span><br><span class="line">        interval:   interval,</span><br><span class="line">        maxTimeout: interval * time.Duration(buckets),</span><br><span class="line">        ticker:     time.NewTicker(interval),</span><br><span class="line">        cs :        <span class="built_in">make</span>([]<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, buckets),</span><br><span class="line">        pos:        <span class="number">0</span>,</span><br><span class="line">        stop:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> w.cs &#123;</span><br><span class="line">        w.cs[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> w.run()</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>光说可能有一点抽象，下面我们来看一下具体的实现，<code>TimingWheel</code> 结构体相当于模拟一个秒表，其中的 <code>ticker</code> 就相当于一个秒针，同时我们还维护了一个通道数组 <code>cs</code> （其存储结构为顺序存储，而其逻辑结构则是一个圆环），作为定时器使用，<code>ticker</code> 每隔固定的 <code>interval</code> ，会让指针向前移动一个单位（ <code>pos++</code> ），并将该位置存储的通道关闭，也就相同于定时器返回，这种方法实现的定时器相对来说增加了定时器的利用率，降低了内存的消耗。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *TimingWheel)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-w.ticker.C:</span><br><span class="line">            w.tick()</span><br><span class="line">        <span class="keyword">case</span> &lt;-w.stop:</span><br><span class="line">            w.ticker.Stop()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *TimingWheel)</span> <span class="title">tick</span><span class="params">()</span></span> &#123;</span><br><span class="line">    w.Lock()</span><br><span class="line">    last := w.cs[w.pos]</span><br><span class="line">    w.cs[w.pos] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">     </span><br><span class="line">    w.pos = (w.pos + <span class="number">1</span>) % <span class="built_in">len</span>(w.cs)</span><br><span class="line">    w.Unlock()    </span><br><span class="line">    <span class="built_in">close</span>(last)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>After</code> 方法为我们提供一个定时器，如果 <code>timeout</code> 数值太大无法落在 <code>timing wheel</code> 的一个周期的时间范围内，则报错，如果 <code>timeout</code> 在正常范围内，则返回对应位置的通道，当该通道超时时，上面的 <code>tick</code> 方法就会将该通道关闭，相应的 <code>goroutine</code> 就可以收到通知了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *TimingWheel)</span> <span class="title">After</span><span class="params">(timeout time.Duration)</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span> &#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> timeout &gt;= w.maxTimeout &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"timeout too long"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idx := <span class="keyword">int</span>(timeout / w.interval)</span><br><span class="line">    <span class="keyword">if</span> idx &gt; <span class="number">0</span> &#123;</span><br><span class="line">        idx--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w.Lock()</span><br><span class="line">    idx = (w.pos + idx) % <span class="built_in">len</span>(w.cs)</span><br><span class="line">    b := w.cs[idx]</span><br><span class="line">    w.Unlock()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *TimingWheel)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">close</span>(w.exit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Timing-Wheel&quot;&gt;&lt;a href=&quot;#Timing-Wheel&quot; class=&quot;headerlink&quot; title=&quot;Timing Wheel&quot;&gt;&lt;/a&gt;Timing Wheel&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://www.confluen
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ligatures</title>
    <link href="https://oceanoverflow.github.io/2018/06/13/Ligatures/"/>
    <id>https://oceanoverflow.github.io/2018/06/13/Ligatures/</id>
    <published>2018-06-13T05:20:38.000Z</published>
    <updated>2018-06-13T05:24:39.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ligatures"><a href="#Ligatures" class="headerlink" title="Ligatures"></a>Ligatures</h1><p>!!! From: <code>https://github.com/tonsky/FiraCode</code> !!!</p><h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>Programmers use a lot of symbols, often encoded with several characters. For the human brain, sequences like -&gt;, &lt;= or := are single logical tokens, even if they take two or three characters on the screen. Your eye spends a non-zero amount of energy to scan, parse and join multiple characters into a single logical one. Ideally, all programming languages should be designed with full-fledged Unicode symbols for operators, but that’s not the case yet.</p><p><img src="https://github.com/tonsky/FiraCode/raw/master/showcases/all_ligatures.png" alt="all_ligatures"></p><h2 id="installation"><a href="#installation" class="headerlink" title="installation"></a>installation</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> brew tap caskroom/fonts</span><br><span class="line"><span class="meta">$</span> brew cask install font-fira-code</span><br></pre></td></tr></table></figure><h2 id="visual-studio-code"><a href="#visual-studio-code" class="headerlink" title="visual studio code"></a>visual studio code</h2><p>Add <code>&quot;editor.fontLigatures&quot;: true</code> to <code>settings.json</code> :</p><p>To open <code>settings.json</code> , from the File menu choose Preferences, Settings or use keyboard shortcut  <code>Cmd</code> + <code>,</code> . Then paste the following lines and save the file.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"editor.fontFamily"</span>: <span class="string">"Fira Code"</span>,</span><br><span class="line"><span class="string">"editor.fontLigatures"</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="what-it-looks-like"><a href="#what-it-looks-like" class="headerlink" title="what it looks like"></a>what it looks like</h2><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p><img src="https://github.com/tonsky/FiraCode/raw/master/showcases/go.png" alt="go"></p><h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><p><img src="https://github.com/tonsky/FiraCode/raw/master/showcases/swift.png" alt="swift"></p><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><p><img src="https://github.com/tonsky/FiraCode/raw/master/showcases/ruby.png" alt="ruby"></p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p><img src="https://github.com/tonsky/FiraCode/raw/master/showcases/javascript.png" alt="js"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ligatures&quot;&gt;&lt;a href=&quot;#Ligatures&quot; class=&quot;headerlink&quot; title=&quot;Ligatures&quot;&gt;&lt;/a&gt;Ligatures&lt;/h1&gt;&lt;p&gt;!!! From: &lt;code&gt;https://github.com/tonsky/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Calculate 24</title>
    <link href="https://oceanoverflow.github.io/2018/06/12/Calculate24/"/>
    <id>https://oceanoverflow.github.io/2018/06/12/Calculate24/</id>
    <published>2018-06-12T06:53:49.000Z</published>
    <updated>2018-06-12T07:01:19.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Calculate-24"><a href="#Calculate-24" class="headerlink" title="Calculate 24"></a>Calculate 24</h1><p>算24点还是挺考验一个人的心算能力的，作为一个数学比较差劲的人，每次和别人玩24点总是会慢一个节拍，可以说是非常伤自尊了。不过虽然心算算不过别人，我们可以写一个自动计算24点的程序和别人比嘛，嘻嘻。</p><h2 id="expression-tree"><a href="#expression-tree" class="headerlink" title="expression tree"></a>expression tree</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/98/Exp-tree-ex-11.svg/500px-Exp-tree-ex-11.svg.png" alt="ExpressionTree"></p><p>我们可以利用表达式树来确定运算的优先级，进而确定运算的顺序，表达式树属于二叉树，其叶结点存储运算数（ <code>val</code> ），非叶子结点存储运算符 <code>op</code> （ <code>+，-，*，/</code> ）及运算结果（ <code>val = l.val op r.val</code> ）。每个节点都有指向其左子节点（ <code>l</code> ）和右子节点（ <code>r</code> ）的指针，叶节点中这两个指针均为空。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    l    *node</span><br><span class="line">    r    *node</span><br><span class="line">    op   <span class="keyword">rune</span></span><br><span class="line">    val  <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">set</span><span class="params">(l, r *node, op <span class="keyword">rune</span>)</span></span> &#123;</span><br><span class="line">    n.l  = l</span><br><span class="line">    n.r  = r</span><br><span class="line">    n.op = op</span><br><span class="line">    <span class="keyword">switch</span> op &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">        n.val = <span class="keyword">float64</span>(n.l.val + n.r.val)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        n.val = <span class="keyword">float64</span>(n.l.val - n.r.val)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">        n.val = <span class="keyword">float64</span>(n.l.val * n.r.val)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">        n.val = <span class="keyword">float64</span>(n.l.val / n.r.val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n.op != <span class="keyword">rune</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">" %c "</span>, n.op)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d"</span>, <span class="keyword">int</span>(n.val))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="build-tree"><a href="#build-tree" class="headerlink" title="build tree"></a>build tree</h2><p>由于存在运算优先级的原因，所以在运算数和运算符都相同的情况下当其运算顺序不同时得出的表达式树的形态也不同，例如 <code>(1 + 8) * (7 - 13)</code>  与 <code>1 + 8 * 7 - 13</code> 的运算顺序是不同的，<code>(1 + 8) * (7 - 13)</code>  对应的是下面第一棵树的形态， <code>1 + 8 * 7 - 13</code> 对应的是下面第四棵树的形态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    x               x               x                x               x</span><br><span class="line">   / \             / \             / \              / \             / \</span><br><span class="line">  x   x           x   x           x   x            x   x           x   x</span><br><span class="line"> / \ / \             / \             / \          / \             / \</span><br><span class="line">x  x x  x           x   x           x   x        x   x           x   x</span><br><span class="line">                   / \                 / \          / \         / \</span><br><span class="line">                  x   x               x   x        x   x       x   x</span><br></pre></td></tr></table></figure><p>为了得出所有的可能结果，我们需要构建所有不同形态的表达式树，<code>buildAllTrees</code> 利用递归方法来建树，例如给定 <code>3，4，5，6</code> 这四个数，可以构建出上面5种形态的树。 <code>3，4，5，6</code> 作为参数传入，然后将数组分割为两个部分，例如上面的 <code>3，4，5，6</code> 可以分割为 <code>3</code> 和 <code>4，5，6</code> 或者 <code>3，4</code> 和 <code>5，6</code> 或者 <code>3，4，5</code> 和 <code>6</code> ，然后对这两个部分分别再进行递归建树操作，当数组长度为1时也就是当 <code>len(s) == 1</code> 作为递归函数退出的条件，此时返回一个叶节点，按照这样的方式最终可以得到所有可能形态的树的根节点。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildAllTrees</span><span class="params">(s []<span class="keyword">int</span>)</span> []*<span class="title">node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">1</span> &#123;</span><br><span class="line">       tree := &amp;node&#123;result: <span class="keyword">float64</span>(s[<span class="number">0</span>])&#125;</span><br><span class="line">       <span class="keyword">return</span> []*node&#123;tree&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    treelist := []*node&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        left := s[:i]</span><br><span class="line">        right := s[i:]</span><br><span class="line">        leftTrees := buildAllTrees(left)</span><br><span class="line">        rightTrees := buildAllTrees(right)</span><br><span class="line">        <span class="keyword">for</span> _, l := <span class="keyword">range</span> leftTrees &#123;</span><br><span class="line">            <span class="keyword">for</span> _, r := <span class="keyword">range</span> rightTrees &#123;</span><br><span class="line">                combinedTree := build(l, r)</span><br><span class="line">                treelist = <span class="built_in">append</span>(treelist, combinedTree...)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> treelist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为存在四种运算符，例如利用 <code>a</code> 和 <code>b</code> 这两个节点构建树的时候，可以有 <code>a+b</code> ， <code>a-b</code> ， <code>a*b</code> ， <code>a/b</code> 这四种可能，所以要分别列举。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(l, r *node)</span> []*<span class="title">node</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> list []*node</span><br><span class="line">    tree1 := &amp;node&#123;&#125;</span><br><span class="line">    tree1.set(l, r, <span class="string">'+'</span>)</span><br><span class="line">    list = <span class="built_in">append</span>(list, tree1)</span><br><span class="line">    tree2 := &amp;node&#123;&#125;</span><br><span class="line">    tree2.set(l, r, <span class="string">'-'</span>)</span><br><span class="line">    list = <span class="built_in">append</span>(list, tree2)</span><br><span class="line">    tree3 := &amp;node&#123;&#125;</span><br><span class="line">    tree3.set(l, r, <span class="string">'*'</span>)</span><br><span class="line">    list = <span class="built_in">append</span>(list, tree3)</span><br><span class="line">    <span class="keyword">if</span> r.result != <span class="number">0.0</span> &#123;</span><br><span class="line">        tree4 := &amp;node&#123;&#125;</span><br><span class="line">        tree4.set(l, r, <span class="string">'/'</span>)</span><br><span class="line">        list = <span class="built_in">append</span>(list, tree4)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过中序遍历表达式树来遍历输出构建的表达式，由于上面我们定义了每个节点的 <code>String</code> 方法，如果节点为运算符，则输出其 <code>op</code> 的值，如果节点为叶结点，则输出其 <code>val</code> 值。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">in</span><span class="params">(root *node)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n.op != <span class="keyword">rune</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        fmt.Print(<span class="string">"("</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    in(root.l)</span><br><span class="line">    fmt.Print(n.String())</span><br><span class="line">    in(root.r)</span><br><span class="line">    <span class="keyword">if</span> n.op != <span class="keyword">rune</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        fmt.Print(<span class="string">")"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="permutation"><a href="#permutation" class="headerlink" title="permutation"></a>permutation</h2><p>上面的方法是对一个数组其固定的顺序构建表达式树，例如 <code>3，4，5，6</code> 。为了获得所有的运算表达式，我们需要对数组的所有排列组合进行表达式树的构建，例如对 <code>6，5，4，3</code> ，<code>5，6，4，3</code> 这样的排列组合构建表达式树。也就是说除了树形态不同的这点区别之外，还要注意叶结点值存储顺序不同的带来的可能（可能会导致重复）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Perm</span><span class="params">(a []<span class="keyword">int</span>, f <span class="keyword">func</span>([]<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">    perm(a, f, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">perm</span><span class="params">(a []<span class="keyword">int</span>, f <span class="keyword">func</span>([]<span class="keyword">int</span>)</span>, <span class="title">i</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="built_in">len</span>(a) &#123;</span><br><span class="line">        f(a)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    perm(a, f, i+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(a); j++ &#123;</span><br><span class="line">        a[i], a[j] = a[j], a[i]</span><br><span class="line">        perm(a, f, i+<span class="number">1</span>)</span><br><span class="line">        a[i], a[j] = a[j], a[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>在主函数中我们每隔五秒钟获得一个随机的扑克牌数字，然后对于该组数字所有的排列组合分别构建表达式树，对每棵构建好的树判断其根节点的值是否接近于24（由于涉及到除法操作，所以有小数点），如果接近，则将其表达式通过中序遍历输出，这样就可以得出一组数字所有24点的可能了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        s := rand24()</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">        Perm(s, <span class="function"><span class="keyword">func</span><span class="params">(a []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            treelist := buildAllTrees(a)</span><br><span class="line">            <span class="keyword">for</span> _, root := <span class="keyword">range</span> treelist &#123;</span><br><span class="line">                <span class="keyword">if</span> math.Abs(<span class="number">24</span>-tree.result) &lt; <span class="number">0.000001</span> &#123;</span><br><span class="line">                    in(root)</span><br><span class="line">                    fmt.Println()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rand24</span><span class="params">()</span> <span class="params">(r []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">    club    := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;</span><br><span class="line">    heart   := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;</span><br><span class="line">    spade   := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;</span><br><span class="line">    diamond := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> all []<span class="keyword">int</span></span><br><span class="line">    all = <span class="built_in">append</span>(all, spade...)</span><br><span class="line">    all = <span class="built_in">append</span>(all, heart...)</span><br><span class="line">    all = <span class="built_in">append</span>(all, diamond...)</span><br><span class="line">    all = <span class="built_in">append</span>(all, club...)</span><br><span class="line"></span><br><span class="line">    r = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    exist = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            x := rand.Int() % <span class="built_in">len</span>(all)</span><br><span class="line">            <span class="keyword">if</span> !exist[x] &#123;</span><br><span class="line">                exist[x] = <span class="literal">true</span></span><br><span class="line">                r[i] = all[x]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Calculate-24&quot;&gt;&lt;a href=&quot;#Calculate-24&quot; class=&quot;headerlink&quot; title=&quot;Calculate 24&quot;&gt;&lt;/a&gt;Calculate 24&lt;/h1&gt;&lt;p&gt;算24点还是挺考验一个人的心算能力的，作为一个数学比较差劲的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Chat Chat Chat</title>
    <link href="https://oceanoverflow.github.io/2018/06/11/ChatChatChat/"/>
    <id>https://oceanoverflow.github.io/2018/06/11/ChatChatChat/</id>
    <published>2018-06-11T07:09:34.000Z</published>
    <updated>2018-06-11T07:10:20.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chat-Chat-Chat"><a href="#Chat-Chat-Chat" class="headerlink" title="Chat Chat Chat"></a>Chat Chat Chat</h1><p>承认吧，你肯定也会有深夜寂寞时特别想找人聊天但翻遍朋友圈，却还是没有发现合适的人的时候，今天我们就来写一个随机配对聊天程序，解决广大单身狗寂寞时想要找人聊天的需求吧。</p><p>为了让聊天不那么 <code>gay</code> ，我们的聊天程序会让异性匹配聊天，用户通过客户端连接到聊天程序服务器 <code>localhost:8080</code> ，例如使用 <code>netcat</code> 通过 <code>nc localhost 8080</code> 命令连接聊天程序服务器，服务器会根据你的性别匹配异性聊天。</p><p>在实现方面，为了达到异性相互聊天的目标，我们创建两个通道，分别是 <code>boy</code> 通道和 <code>girl</code> 通道，并通过 <code>net.Listen</code> 方法监听 <code>8080</code> 端口，对于每个连接我们起一个 <code>goroutine</code> 进行匹配操作。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boy = <span class="built_in">make</span>(<span class="keyword">chan</span> io.ReadWriteCloser)</span><br><span class="line"><span class="keyword">var</span> girl = <span class="built_in">make</span>(<span class="keyword">chan</span> io.ReadWriteCloser)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"localhost:8080"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        c, err := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> match(c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>match</code> 方法会首先询问你的性别，如果是男生则匹配女生聊天，反之亦然。如果当前只有一个男生连进来，程序会执行第一个 <code>select</code> 中的 <code>case boy &lt;- c:</code> 条件，由于 <code>boy</code> 通道是 <code>unbuffered channel</code> ，直到有女生进来之前该操作都会阻塞。如果此时进来一个女生，程序会执行第二个<code>select</code> 操作，由于 <code>girl</code> 通道也是 <code>unbuffered channel</code> ，所以<code>case girl &lt;- c:</code> 语句也会阻塞，但此时 <code>case p := &lt;-boy:</code> 会被执行，这时候就可以通过 <code>chat</code> 方法让两个 <code>net.Conn</code> 相互交流了。<code>match</code> 方法实现的逻辑就达到了异性交流的目的了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">match</span><span class="params">(c io.ReadWriteCloser)</span></span> &#123;</span><br><span class="line">    fmt.Fprint(c, <span class="string">"Are you a boy or a girl? "</span>)</span><br><span class="line">    <span class="keyword">var</span> sex <span class="keyword">string</span></span><br><span class="line">    fmt.Fscanln(c, &amp;sex)</span><br><span class="line">    <span class="keyword">if</span> strings.HasPrefix(<span class="string">"boy"</span>, sex) &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> boy &lt;- c: </span><br><span class="line">        <span class="keyword">case</span> p := &lt;-girl:</span><br><span class="line">            chat(p, c)</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> strings.HasPrefix(<span class="string">"girl"</span>, sex) &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> girl &lt;- c:</span><br><span class="line">        <span class="keyword">case</span> p := &lt;-boy:</span><br><span class="line">            chat(p, c)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>chat</code> 方法依赖 <code>cp</code> 方法 ，该方法封装了 <code>io.Copy</code> 方法，主要就是为了当任意一方结束聊天时发送一个 <code>err</code> 到我们的 <code>errc</code> ，以关闭双方的连接。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cp</span><span class="params">(w io.Writer, r io.Reader, errc <span class="keyword">chan</span>&lt;- error)</span></span> &#123;</span><br><span class="line">    _, err := io.Copy(w, r)</span><br><span class="line">    errc &lt;- err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>chat</code> 方法通过两个 <code>goroutine</code> ，<code>go cp(a, b, errc)</code>  和 <code>go cp(b, a, errc)</code> 使a和b这两个 <code>net.Conn</code> 相互发送消息，如果任意一方结束聊天， <code>errc</code> 通道就会返回一个 <code>error</code> 值，a和b就会被关闭，此时聊天结束。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chat</span><span class="params">(a, b io.ReadWriteCloser)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(a, <span class="string">"Found one! say hi"</span>)</span><br><span class="line">    fmt.Fprintln(b, <span class="string">"Found one! say hi"</span>)</span><br><span class="line">    errc := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> cp(a, b, errc) </span><br><span class="line">    <span class="keyword">go</span> cp(b, a, errc)</span><br><span class="line">    <span class="keyword">if</span> err := &lt;- errc; err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    a.Close()</span><br><span class="line">    b.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Chat-Chat-Chat&quot;&gt;&lt;a href=&quot;#Chat-Chat-Chat&quot; class=&quot;headerlink&quot; title=&quot;Chat Chat Chat&quot;&gt;&lt;/a&gt;Chat Chat Chat&lt;/h1&gt;&lt;p&gt;承认吧，你肯定也会有深夜寂寞时特别想找人聊天
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>bitcoin</title>
    <link href="https://oceanoverflow.github.io/2018/06/06/bitcoin/"/>
    <id>https://oceanoverflow.github.io/2018/06/06/bitcoin/</id>
    <published>2018-06-06T14:19:02.000Z</published>
    <updated>2018-06-06T14:30:06.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bitcoin"><a href="#bitcoin" class="headerlink" title="bitcoin"></a>bitcoin</h1><p>如果有时光机的话，我要做的第一件事情肯定就是穿梭回过去买比特币：），算了，不意淫了，还是学习要紧，虽然再也不能靠买比特币一夜暴富了，但是自己按照比特币实现一个山寨比特币的能力还是有的，比特币可以说是现在大红大紫的区块链的始祖，要全部了解它的原理可能还是要埋头啃个几个月的（并不简单）。</p><p>虽然比特币交易确认时间长，消耗资源多，但依旧无法掩盖其作为区块链始祖的光环。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*_RY4v9D5-BOVMzFMr8Dk4A.png" alt="bitcoin"></p><h2 id="Block-amp-BlockChain"><a href="#Block-amp-BlockChain" class="headerlink" title="Block &amp; BlockChain"></a>Block &amp; BlockChain</h2><p>比特币中有两个重要的基本概念，区块和区块链，如果将区块想象成珍珠，那么区块链就是将这些珍珠都串起来的珍珠项链，这个珍珠项链没有尽头，新加入的珍珠和次新的珍珠彼此靠近，并通过某种关系紧密联系在一起，牢不可破。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    idx        <span class="keyword">int</span></span><br><span class="line">    timestamp  <span class="keyword">string</span></span><br><span class="line">    hash       <span class="keyword">string</span></span><br><span class="line">    prevHash   <span class="keyword">string</span></span><br><span class="line">    difficulty <span class="keyword">int</span></span><br><span class="line">    nonce      <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BlockChain <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    blocks []Block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">AddBlock</span><span class="params">(block Block)</span></span> &#123;</span><br><span class="line">    bc.Lock()</span><br><span class="line">    <span class="keyword">defer</span> bc.Unlock()</span><br><span class="line">    bc.blocks = <span class="built_in">append</span>(bc.blocks, block)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> blockchain BlockChain</span><br></pre></td></tr></table></figure><h2 id="Proof-of-Work"><a href="#Proof-of-Work" class="headerlink" title="Proof of Work"></a>Proof of Work</h2><p>生成区块的过程就相当于打磨珍珠的过程，只有符合要求的珍珠才能最终被加入到珍珠项链中去，那么话说回来生成区块的过程是怎么样的呢，对于一个特定的区块，需要不断改变其中一个值（nonce），这里的 <code>nonce</code> 值从0开始逐渐递增，然后计算特定 <code>nonce</code> 对应的区块哈希值，只有哈希值符合相应的要求之后，才能说这个区块是有效的，才能被加入到区块链中，生成区块的过程也被叫做挖矿。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateBlock</span><span class="params">(oldBlock Block, difficulty <span class="keyword">int</span>)</span> <span class="title">Block</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> newBlock Block</span><br><span class="line"></span><br><span class="line">    newBlock.idx = oldBlock.idx + <span class="number">1</span></span><br><span class="line">    newBlock.timestamp = time.Now().String()</span><br><span class="line">    newBlock.prevHash = oldBlock.hash</span><br><span class="line">  newBlock.difficulty = diff</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">        hex := fmt.Sprintf(<span class="string">"%x"</span>, i)</span><br><span class="line">        newBlock.nonce = hex</span><br><span class="line">        <span class="keyword">if</span> !isHashValid(calculateHash(newBlock), newBlock.difficulty) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(calculateHash(newBlock), <span class="string">" work done!"</span>)</span><br><span class="line">            newBlock.Hash = calculateHash(newBlock)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newBlock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateHash</span><span class="params">(block Block)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    record := strconv.Itoa(block.idx) + block.timestamp + block.prevHash + block.difficulty + block.nonce</span><br><span class="line">    h := sha256.New()</span><br><span class="line">    h.Write([]<span class="keyword">byte</span>(record))</span><br><span class="line">    hashed := h.Sum(<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(hashed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么什么样的区块才是有效的呢，简单来说就是对于一个哈希值，其开头部分都是0就可以了（0越多，难度越高）。像这种，找到答案很困难但验证答案却非常轻松的算法就是 <code>Proof of Work</code> 的精髓。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHashValid</span><span class="params">(hash <span class="keyword">string</span>, difficulty <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    prefix := strings.Repeat(<span class="string">"0"</span>, difficulty)</span><br><span class="line">    <span class="keyword">return</span> strings.HasPrefix(hash, prefix)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个难度逐渐递增的区块链"><a href="#一个难度逐渐递增的区块链" class="headerlink" title="一个难度逐渐递增的区块链"></a>一个难度逐渐递增的区块链</h2><p>下面实现了一个难度逐渐递增的区块链，运行时就会发现产生区块的时间间隔越来越长，因为 <code>CPU</code> 需要经过更多的计算才能找到符合条件的哈希值。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    difficulty := <span class="number">1</span></span><br><span class="line">    genesisBlock := Block&#123;&#125;</span><br><span class="line">    genesisBlock = Block&#123;</span><br><span class="line">        idx:        <span class="number">0</span>, </span><br><span class="line">        timestamp:  time.Now().String(), </span><br><span class="line">        hash:       calculateHash(genesisBlock),</span><br><span class="line">        prevHash:   <span class="string">""</span>, </span><br><span class="line">        difficulty: difficulty, </span><br><span class="line">        nonce:      <span class="string">""</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    blockchain.AddBlock(genesisBlock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> block Block</span><br><span class="line">    block = genesisBlock</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        block = generateBlock(block, diff)</span><br><span class="line">        difficulty++</span><br><span class="line">        blockchain.AddBlock(block)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;bitcoin&quot;&gt;&lt;a href=&quot;#bitcoin&quot; class=&quot;headerlink&quot; title=&quot;bitcoin&quot;&gt;&lt;/a&gt;bitcoin&lt;/h1&gt;&lt;p&gt;如果有时光机的话，我要做的第一件事情肯定就是穿梭回过去买比特币：），算了，不意淫了，还是学习要紧，虽
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Magic Number</title>
    <link href="https://oceanoverflow.github.io/2018/06/05/MagicNumber/"/>
    <id>https://oceanoverflow.github.io/2018/06/05/MagicNumber/</id>
    <published>2018-06-05T08:27:07.000Z</published>
    <updated>2018-06-05T09:03:33.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Magic-Number"><a href="#Magic-Number" class="headerlink" title="Magic Number"></a>Magic Number</h1><p>微笑.jpg，这里年轻人们聊天时经常使用的说法，但是！作为一个严谨的程序员，我们能不能通过文件的后缀来判断这个文件的类型呢？例如看到电脑上存在“微笑.jpg”这个文件，通过后缀 <code>jpg</code> 来判断它就是一个 <code>JPEG</code> 文件呢，答案肯定是否定的，因为文件名可以被轻松篡改，例如这个文件本来是“微笑.gif”，有人想不开就将它改成“微笑.jpg”，虽然没有什么影响，但是可以说明一个问题，我们不能通过文件后缀来判断文件的类型。</p><p>如果不使用文件后缀，我们应该如何判断文件的类型呢，答案就是我们今天要讨论的<code>Magic Number</code> ，即魔术数，因为文件的本质就是字节数组，所以在一般的操作系统中，对于特定类型的文件，其开头的几个字节都是相同的，例如对于 <code>JPEG</code> 格式的文件，开头的字节都是 <code>\xff\xd8\xff</code> ，我们可以通过读取文件开头的字节来确定文件的类型，这种方法准确性更高。</p><p>下面我们准备一个魔术数到类型的字典，注意，这里只列举了几个例子，还可以按照这样的格式增加字典项。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> magicNumber = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> &#123;</span><br><span class="line">    <span class="string">"\xff\xd8\xff"</span>:      <span class="string">"image/jpeg"</span>,</span><br><span class="line">    <span class="string">"\x89PNG\r\n\x1a\n"</span>: <span class="string">"image/png"</span>,</span><br><span class="line">    <span class="string">"GIF87a"</span>:            <span class="string">"image/gif"</span>,</span><br><span class="line">    <span class="string">"GIF89a"</span>:            <span class="string">"image/gif"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFileType</span><span class="params">(incipit []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    incipitStr := <span class="keyword">string</span>(incipit)</span><br><span class="line">    <span class="keyword">for</span> magic, mime := <span class="keyword">range</span> magicNumber &#123;</span><br><span class="line">        <span class="keyword">if</span> strings.HasPrefix(incipitStr, magic) &#123;</span><br><span class="line">            <span class="keyword">return</span> mime</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正匹配格式的逻辑比较简单，遍历 <code>magicNumber</code> 这个 <code>map</code> ，判断每个 <code>key</code> 是不是某个字符串的前缀，因为魔术数符合前缀编码的特点，即任何一个编码都不是另一个编码的前缀，所以我们能保证判断文件类型时，不会有二义。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    filepath := os.Args[<span class="number">1</span>]</span><br><span class="line">    file, err := os.Open(filepath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    buff := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">512</span>)</span><br><span class="line">    _, err = file.Read(buff)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file.Seek(<span class="number">0</span>, os.SEEK_SET)</span><br><span class="line">    typ := getFileType(buff)</span><br><span class="line">    fmt.Println(typ)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Magic-Number&quot;&gt;&lt;a href=&quot;#Magic-Number&quot; class=&quot;headerlink&quot; title=&quot;Magic Number&quot;&gt;&lt;/a&gt;Magic Number&lt;/h1&gt;&lt;p&gt;微笑.jpg，这里年轻人们聊天时经常使用的说法，但是！作为一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Raft</title>
    <link href="https://oceanoverflow.github.io/2018/06/03/Raft/"/>
    <id>https://oceanoverflow.github.io/2018/06/03/Raft/</id>
    <published>2018-06-03T12:59:23.000Z</published>
    <updated>2018-06-03T13:01:25.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><ul><li>Raft stands for Replicated and Fault Tolerant</li><li>Raft is something you can build out of a collection of logs</li><li>Raft is something you can use to get away from the island of Paxos</li></ul><h2 id="Goal-Replicated-Log"><a href="#Goal-Replicated-Log" class="headerlink" title="Goal: Replicated Log"></a>Goal: Replicated Log</h2><ul><li>Replicated log =&gt; replicated state machine<ul><li>All servers execute same commands in same order</li></ul></li><li>Consensus module ensures proper log replication</li><li>System makes progress as long as any majority of servers are up</li><li>Failure model: fail-stop(not Byzantine), delayed/lost messages    </li></ul><h2 id="Approaches-to-Consensus"><a href="#Approaches-to-Consensus" class="headerlink" title="Approaches to Consensus"></a>Approaches to Consensus</h2><p>Two possible approaches to consensus:</p><ul><li>Symmetric, leader-less:<ul><li>All servers have equal roles</li><li>Clients can contact any server </li></ul></li><li>Asymmetric, leader-based:<ul><li>At any given time, one server is in charge, others accept its decision</li><li>Clients communicate with the leader </li></ul></li><li>Raft uses a leader:<ul><li>Decomposes the problem (normal operation, leader changes)</li><li>Simplifies normal operation (no conflicts)</li><li>More efficient than leader-less approaches  </li></ul></li></ul><h2 id="Leader-Election"><a href="#Leader-Election" class="headerlink" title="Leader Election"></a>Leader Election</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">                  +------------------+</span><br><span class="line">                  | Become Candidate |</span><br><span class="line">                  +------------------+</span><br><span class="line">                           |</span><br><span class="line">                           v</span><br><span class="line">                   +---------------+    timeout</span><br><span class="line">                   | currentTerm++ |&lt;--------------+</span><br><span class="line">                   | vote for self |               |</span><br><span class="line">                   +---------------+               |</span><br><span class="line">                           |                       |</span><br><span class="line">                           v                       |</span><br><span class="line">               +-----------------------+           |</span><br><span class="line">               | Send RequestVote RPCs |-----------+</span><br><span class="line">               |    to other servers   |</span><br><span class="line">               +-----------------------+</span><br><span class="line">votes from majority |              | RPC from Leader</span><br><span class="line">                    v              v</span><br><span class="line">           +----------------+  +---------+</span><br><span class="line">           | Become Leader, |  | Become  |</span><br><span class="line">           | send heartbeats|  | Follower|</span><br><span class="line">           +----------------+  +---------+</span><br></pre></td></tr></table></figure><ul><li>Safety: allow at most one winner per term<ul><li>Each server gives only one vote per term(persist on disk)</li><li>Majority required to win election</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   B can&apos;t also                  Voted for</span><br><span class="line">   get majority                candidate A</span><br><span class="line">+-----------------+     +-------------------------+</span><br><span class="line">| +-----+ +-----+ |     | +-----+ +-----+ +-----+ |     </span><br><span class="line">| |     | |     | |     | |     | |     | |     | | </span><br><span class="line">| +-----+ +-----+ |     | +-----+ +-----+ +-----+ |</span><br><span class="line">+-----------------+     +-------------------------+</span><br><span class="line">                  Servers</span><br></pre></td></tr></table></figure><ul><li>Livebess: some candidate must eventually win<ul><li>Choose election timeout randomly in [T, 2T] (e.g. 150-300ms)</li><li>One server usually times out and wins election before others time out</li><li>Works well if T &gt;&gt; broadcast time</li></ul></li></ul><p>Randomized approach simpler than ranking</p><h2 id="Normal-Operation"><a href="#Normal-Operation" class="headerlink" title="Normal Operation"></a>Normal Operation</h2><ul><li>Client sends command to leader</li><li>Leader appends command to its log</li><li>Leader send AppendEntries RPCs to all followers</li><li>Once new entry committed<ul><li>Leader executes command in its state machine, returns result to client</li><li>Leader notifies followers of committed entries in subsequent AppendEntries RPCs</li><li>Followers execute committed commands in their state machines  </li></ul></li><li>Crashed/slow followers<ul><li>Leader retries AppendEntries RPCs until they succeed</li></ul></li><li>Optimal performance in common case:<ul><li>One successful RPC to any majority of servers</li></ul></li></ul><h2 id="Log-Structure"><a href="#Log-Structure" class="headerlink" title="Log Structure"></a>Log Structure</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Command <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Log <span class="keyword">struct</span> &#123;</span><br><span class="line">    Term <span class="keyword">int</span></span><br><span class="line">    Command Command</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Logs []Log</span><br></pre></td></tr></table></figure><ul><li>Must survive crashes (store on disk)</li><li>Entry committed if safe to execute in state machines<ul><li>Replicated on majority of servers by leader of its term</li></ul></li></ul><h2 id="Log-Inconsistencies"><a href="#Log-Inconsistencies" class="headerlink" title="Log Inconsistencies"></a>Log Inconsistencies</h2><p>Crashes can result in log inconsistencies</p><ul><li>Raft minimizes special code for repairing inconsistencies<ul><li>Leader assumes its log is correct</li><li>Normal operation will repair all inconsistencies </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Raft&quot;&gt;&lt;a href=&quot;#Raft&quot; class=&quot;headerlink&quot; title=&quot;Raft&quot;&gt;&lt;/a&gt;Raft&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Raft stands for Replicated and Fault Tolerant&lt;/li&gt;
&lt;li&gt;R
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Replicated Service Client</title>
    <link href="https://oceanoverflow.github.io/2018/06/02/ReplicatedServiceClient/"/>
    <id>https://oceanoverflow.github.io/2018/06/02/ReplicatedServiceClient/</id>
    <published>2018-06-02T07:01:00.000Z</published>
    <updated>2018-06-02T07:06:46.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Replicated-Service-Client"><a href="#Replicated-Service-Client" class="headerlink" title="Replicated Service Client"></a>Replicated Service Client</h1><p>Self-explanatory :-)<br>Actually cause I feel lazy today.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplicatedClient <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Init initializes the client to use the given servers.</span></span><br><span class="line">    <span class="comment">// To make a particular request later,</span></span><br><span class="line">    <span class="comment">// the client can use callOne(srv, args), where srv </span></span><br><span class="line">    <span class="comment">// is one of the servers from the list</span></span><br><span class="line">    Init(servers []<span class="keyword">string</span>, callOne(<span class="keyword">string</span>, Args) Reply)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call makes a request to an available server.</span></span><br><span class="line">    <span class="comment">// Multiple gouroutines may call Call concurrently.</span></span><br><span class="line">    Call(args Args) Reply </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    servers []<span class="keyword">string</span></span><br><span class="line">    callOne <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, Args)</span> <span class="title">Reply</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">mu</span> <span class="title">sync</span>.<span class="title">Mutex</span></span></span><br><span class="line"><span class="function">    <span class="title">prefer</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Client)</span> <span class="title">Init</span><span class="params">(servers []<span class="keyword">string</span>, callOne <span class="keyword">func</span>(<span class="keyword">string</span>, Args)</span> <span class="title">Reply</span>)</span> &#123;</span><br><span class="line">    c.servers = servers</span><br><span class="line">    c.callOne = callOne</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Call</span><span class="params">(args Args)</span> <span class="title">Reply</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">        serverID <span class="keyword">int</span></span><br><span class="line">        reply Reply</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> timeout = <span class="number">1</span> * time.Second</span><br><span class="line">    t := time.NewTimer(timeout)</span><br><span class="line">    <span class="keyword">defer</span> t.Stop()</span><br><span class="line"></span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> result, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    prefer := c.prefer</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> r result</span><br><span class="line">    <span class="keyword">for</span> off := <span class="number">0</span>; off &lt; <span class="built_in">len</span>(c.servers); off++ &#123;</span><br><span class="line">        id := (prefer + off) % <span class="built_in">len</span>(c.servers)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            done &lt;- result&#123;id, c.callOne(c.servers[id], args)&#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> r = &lt;-done:</span><br><span class="line">            goro Done</span><br><span class="line">        <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">            t.Reset(timeout)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Done:</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    c.prefer = r.serverID</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> r.reply  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Replicated-Service-Client&quot;&gt;&lt;a href=&quot;#Replicated-Service-Client&quot; class=&quot;headerlink&quot; title=&quot;Replicated Service Client&quot;&gt;&lt;/a&gt;Replicated 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Semaphore</title>
    <link href="https://oceanoverflow.github.io/2018/06/01/Semaphore/"/>
    <id>https://oceanoverflow.github.io/2018/06/01/Semaphore/</id>
    <published>2018-06-01T13:07:44.000Z</published>
    <updated>2018-06-01T13:42:30.973Z</updated>
    
    <content type="html"><![CDATA[<p>现在要完成一个非常简单的任务，给定很多图片的 <code>URL</code> ，将它们下载到本地，你会怎么做？</p><h2 id="Sequential"><a href="#Sequential" class="headerlink" title="Sequential"></a>Sequential</h2><p>如果你想也不想，就写下了下面这种代码，说明你是一个能干活的程序员，但这并不意味着你是一个优秀的程序员。下面的代码虽然没有什么致命的错误，但是效率非常低，程序运行时 <code>CPU</code> 大部分时间都在等待网络 <code>I/O</code> 而处于空闲状态，导致 <code>CPU</code> 的利用率非常低。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, task := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">    <span class="keyword">if</span> err := Do(idx, task); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h2><p>这种完全由相互独立的子任务组成的任务，被称为 <em>embarrassingly parallel</em> ，这种问题可以通过并行的方法提高程序的性能，而且并行程度越高，性能越好，在程序中我们通过添加 <code>go</code> 这个关键字来创建多个 <code>goroutine</code> ，使多个子任务并发执行，以减少网络 <code>I/O</code> 延迟，提高 <code>CPU</code> 的利用率 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> idx, task := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, v <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">if</span> err := Do(i, v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(idx, task)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><h2 id="Parallel-with-Semaphore"><a href="#Parallel-with-Semaphore" class="headerlink" title="Parallel with Semaphore"></a>Parallel with Semaphore</h2><p>但是通过创建多个 <code>goroutine</code> 提高并行度从而提高性能的方法有其局限性，例如一次性创建过多的网络连接，超出了进程打开文件的数量限制时，程序就会报错。所以我们需要限制单位时间内并行程序的个数，通过信号量（ <code>semaphore</code> ）来限制并行度。在 <code>golang</code> 中，我们可以使用容量为 n 的 <code>buffered channel</code> 来模拟 <code>counting semaphore</code> ，这样以来在每个子任务执行前需要通过 <code>sem &lt;- struct{}{}</code> 来获取执行许可，如果 <code>sem</code> 通道已满，说明当前已经有n个子任务正在执行，该操作就会阻塞等待，直到通道空闲。当任务执行完成后，使用 <code>&lt;-sem</code> 释放执行许可。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sem := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">8</span>) <span class="comment">// 8 jobs at once</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> idx, task := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, v <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> err := Do(i, v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">        &lt;-sem</span><br><span class="line">    &#125;(idx, task)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(sem)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在要完成一个非常简单的任务，给定很多图片的 &lt;code&gt;URL&lt;/code&gt; ，将它们下载到本地，你会怎么做？&lt;/p&gt;
&lt;h2 id=&quot;Sequential&quot;&gt;&lt;a href=&quot;#Sequential&quot; class=&quot;headerlink&quot; title=&quot;Sequenti
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Memory Mapped File</title>
    <link href="https://oceanoverflow.github.io/2018/05/31/MemoryMappedFile/"/>
    <id>https://oceanoverflow.github.io/2018/05/31/MemoryMappedFile/</id>
    <published>2018-05-31T11:05:38.000Z</published>
    <updated>2018-05-31T12:01:30.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Memory-Mapped-File"><a href="#Memory-Mapped-File" class="headerlink" title="Memory Mapped File"></a>Memory Mapped File</h1><p>内存映射文件( <code>memory mapped file</code> )与磁盘上的文件存在直接的对应关系。内存映射 <code>I/O</code> 将磁盘上的文件映射到用户进程地址空间中，这样，当我们从映射内存中获取字节时，会读取文件的相应字节。同样的，当我们将数据存储在映射内存中时，相应的字节会自动写入文件中。这样以来就可以在不使用 <code>read()</code> 或 <code>write()</code> 系统调用的情况下执行 <code>I/O</code> 操作 。</p><p><img src="http://www.tutorialsdaddy.com/wp-content/uploads/2016/11/linux-mmap.png" alt="mmap"></p><h2 id="mmap-amp-munmap"><a href="#mmap-amp-munmap" class="headerlink" title="mmap &amp; munmap"></a>mmap &amp; munmap</h2><p><code>mmap</code> 系统调用将文件或设备映射到内存中，当调用成功时，它会返回映射内存的起始地址。第一个参数 <code>addr</code> 表示文件要映射到内存中的虚拟地址，一般都为 <code>NULL</code> ，表示由内核决定合适的映射地址。第二个参数 <code>len</code> 指定映射的大小（以字节为单位），通常情况下，内核创建的映射内存的大小是内存页面大小的整数倍。第三个参数 <code>prot</code> 指定访问权限，可以是 <code>PROT_READ</code>，<code>PROT_WRITE</code> ，<code>PROT_EXEC</code> 。第四个参数 <code>flags</code> 可以是 <code>MAP_PRIVATE</code>，<code>MAP_SHARED</code> 。第五个参数 <code>fd</code> 标识映射文件的文件描述符。第六个参数 <code>offset</code> 指定了文件映射的起点。为了映射整个文件，我们将 <code>offset</code> 指定为0，将 <code>len</code> 指定为整个文件的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">mmap(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">munmap(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len);</span><br></pre></td></tr></table></figure><p>Golang中系统调用参数有些许不同，但本质是一样的。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> syscall</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mmap</span><span class="params">(fd <span class="keyword">int</span>, offset <span class="keyword">int64</span>, length <span class="keyword">int</span>, prot <span class="keyword">int</span>, flags <span class="keyword">int</span>)</span> <span class="params">(data []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Munmap</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(err error)</span></span></span><br></pre></td></tr></table></figure><h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><p>当然了，如果光介绍 <code>mmap</code> 这个系统调用就太无聊了，我们下面来看一下 <code>mmap</code> 能帮助我们干什么事情，如果你玩树莓派的话，我们可以用 <code>mmap</code> 来写一个 <code>GPIO</code> 驱动。</p><p><img src="https://cdn.shopify.com/s/files/1/2187/3161/products/450ba4cc5f96d682fde154a5e569ebf4_1024x.png?v=1520446011" alt="RasberryPi"></p><p>在树莓派的 <code>/dev</code> 目录下存在 <code>mem</code> 和 <code>gpiomem</code> 这两个文件。通过 <code>mmap</code> <code>/dev/gpiomem</code> 文件我们可以在没有 <code>root</code> 权限的情况下访问 <code>GPIO</code> 寄存器。打开 <code>/dev/gpiomem</code> 设备文件并使用 <code>mmap()</code> 函数可将 <code>GPIO</code> 寄存器映射到进程内存空间中去。<code>/dev/mem</code> 代表整个系统的内存空间。<code>/dev/gpiomem</code> 仅允许访问 <code>GPIO</code> 外设寄存器， <code>/dev/mem</code> 允许访问所有外设寄存器以及所有内存，相对来说更加危险。为了保护内存空间，最好使用 <code>/dev/gpiomem</code> 而非 <code>/dev/mem</code> 来控制 <code>GPIO</code> 寄存器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">          Rev 2 and 3 Raspberry Pi </span><br><span class="line">+-----+---------+----------+---------+-----+</span><br><span class="line">| BCM |   Name  | Physical | Name    | BCM |</span><br><span class="line">+-----+---------+----++----+---------+-----+ </span><br><span class="line">|     |    3.3v |  1 || 2  | 5v      |     |</span><br><span class="line">|   2 |   SDA 1 |  3 || 4  | 5v      |     | </span><br><span class="line">|   3 |   SCL 1 |  5 || 6  | 0v      |     |</span><br><span class="line">|   4 | GPIO  7 |  7 || 8  | TxD     | 14  |</span><br><span class="line">|     |      0v |  9 || 10 | RxD     | 15  | </span><br><span class="line">|  17 | GPIO  0 | 11 || 12 | GPIO  1 | 18  | </span><br><span class="line">|  27 | GPIO  2 | 13 || 14 | 0v      |     |</span><br><span class="line">|  22 | GPIO  3 | 15 || 16 | GPIO  4 | 23  |</span><br><span class="line">|     |    3.3v | 17 || 18 | GPIO  5 | 24  |  </span><br><span class="line">|  10 |    MOSI | 19 || 20 | 0v      |     |  </span><br><span class="line">|   9 |    MISO | 21 || 22 | GPIO  6 | 25  | </span><br><span class="line">|  11 |    SCLK | 23 || 24 | CE0     | 8   |</span><br><span class="line">|     |      0v | 25 || 26 | CE1     | 7   | </span><br><span class="line">|   0 |   SDA 0 | 27 || 28 | SCL 0   | 1   | </span><br><span class="line">|   5 | GPIO 21 | 29 || 30 | 0v      |     |</span><br><span class="line">|   6 | GPIO 22 | 31 || 32 | GPIO 26 | 12  |</span><br><span class="line">|  13 | GPIO 23 | 33 || 34 | 0v      |     |</span><br><span class="line">|  19 | GPIO 24 | 35 || 36 | GPIO 27 | 16  |</span><br><span class="line">|  26 | GPIO 25 | 37 || 38 | GPIO 28 | 20  |</span><br><span class="line">|     |      0v | 39 || 40 | GPIO 29 | 21  |</span><br><span class="line">+-----+---------+----++----+---------+-----+</span><br></pre></td></tr></table></figure><p>如果通过 <code>/dev/mem</code> 访问 <code>GPIO</code> 外设寄存器，那么我们需要确定其内存中的基地址，我们通过读取 <code>/proc/device-tree/soc/ranges</code> 来确定基地址。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    bcm2835Base = <span class="number">0x20000000</span></span><br><span class="line">    gpioOffset  = <span class="number">0x200000</span></span><br><span class="line">    memLength = <span class="number">4096</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gpioBase <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    memLock sync.Mutex</span><br><span class="line">    gpioMem  []<span class="keyword">byte</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    base := getBase()</span><br><span class="line">    gpioBase = base + gpioOffset </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBase</span><span class="params">()</span> <span class="params">(base <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    base = bcm2835Base</span><br><span class="line">    ranges, err := os.Open(<span class="string">"/proc/device-tree/soc/ranges"</span>)</span><br><span class="line">    <span class="keyword">defer</span> ranges.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">    n, err := ranges.ReadAt(b, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">if</span> n != <span class="number">4</span> || err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    buf := bytes.NewReader(b)</span><br><span class="line">    <span class="keyword">var</span> out <span class="keyword">uint32</span></span><br><span class="line">    err = binary.Read(buf, binary.BigEndian, &amp;out)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int64</span>(out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>Open</code> 函数通过映射 <code>/dev/mem</code> 文件来将 <code>GPIO</code> 寄存器映射到内存中，这样以来我们就可以通过直接改变 <code>gpioMem</code> 的值来操控 <code>GPIO</code> 寄存器了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// Open fd for rw mem access; try dev/mem first (need root)</span></span><br><span class="line">    file, err := os.OpenFile(<span class="string">"/dev/mem"</span>, os.O_RDWR|os.O_SYNC, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> os.IsPermission(err) &#123;</span><br><span class="line">        <span class="comment">// try gpiomem otherwise (some extra functions like clock and pwm setting wont work)</span></span><br><span class="line">        file, err = os.OpenFile(<span class="string">"/dev/gpiomem"</span>, os.O_RDWR|os.O_SYNC, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// FD can be closed after memory mapping</span></span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    memLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> memLock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Memory map GPIO registers to slice</span></span><br><span class="line">    gpioMem, err = syscall.Mmap(</span><br><span class="line">        <span class="keyword">int</span>(file.Fd()),</span><br><span class="line">        gpioBase,</span><br><span class="line">        memLength,</span><br><span class="line">        syscall.PROT_READ|syscall.PROT_WRITE,</span><br><span class="line">        syscall.MAP_SHARED,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Close</code> 函数使用 <code>syscall.Munmap</code> 系统调用来解除内存映射。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    memLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> memLock.Unlock()</span><br><span class="line">    <span class="keyword">if</span> err := syscall.Munmap(mem); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Memory-Mapped-File&quot;&gt;&lt;a href=&quot;#Memory-Mapped-File&quot; class=&quot;headerlink&quot; title=&quot;Memory Mapped File&quot;&gt;&lt;/a&gt;Memory Mapped File&lt;/h1&gt;&lt;p&gt;内存映射文件
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Protocol Multiplexer</title>
    <link href="https://oceanoverflow.github.io/2018/05/29/ProtocolMultiplexer/"/>
    <id>https://oceanoverflow.github.io/2018/05/29/ProtocolMultiplexer/</id>
    <published>2018-05-29T11:50:23.000Z</published>
    <updated>2018-05-29T13:22:16.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Protocol-Multiplexer"><a href="#Protocol-Multiplexer" class="headerlink" title="Protocol Multiplexer"></a>Protocol Multiplexer</h1><p>假设我们要实现一个 <code>RPC</code> 框架并且每个客户端与服务器只维护一根 <code>TCP</code> 连接，但客户端可能会同时发出很多 <code>RPC</code> 请求，服务器收到请求处理后将结果返还给客户端，现在问题来了，由于只有一根 <code>TCP</code> 连接，客户端收到的结果可能是乱序的，我们该如何将请求和答复对应起来呢，如果采取同步的方法倒是不用担心乱序的问题，但是效率肯定非常低，同步导致系统大部分时间在等待 <code>I/O</code> ，为了提高 <code>CPU</code> 的利用率，我们可以采用多路复用的方法。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ProtocolMux <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Init initializes the mux to manage messages to the given service.</span></span><br><span class="line">    Init(Service)</span><br><span class="line">    <span class="comment">// Call makes a request with the given message and returns the reply.</span></span><br><span class="line">    <span class="comment">// Multiple goroutines may call Call concurrently.</span></span><br><span class="line">    Call(Msg) Msg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Service</code> 接口仅仅指明了服务需要实现的接口，这些服务实际就是对网络库的封装，可以是 <code>TCP</code> 或者 <code>UDP</code> ，<code>Send</code> 和 <code>Recv</code> 方法不能在并发条件下使用，并发使用可能会导致数据竞争。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// ReadTag returns the muxing identifier in the request or reply message.</span></span><br><span class="line">    <span class="comment">// Multiple goroutines may call ReadTag concurrently.</span></span><br><span class="line">    ReadTag(Msg) <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">// Send sends a request message to the remote service.</span></span><br><span class="line">    <span class="comment">// Send must not be called concurrently with itself.</span></span><br><span class="line">    Send(Msg)</span><br><span class="line">    <span class="comment">// Recv waits for and returns a reply mesasge from the remote service.</span></span><br><span class="line">    <span class="comment">// Recv must not be called concurrently with itself.</span></span><br><span class="line">    Recv(Msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现多路复用的核心就在于使用 <code>pending</code> 这个 <code>map</code> 来存储还未收到答复的请求，每一个请求都有自己独一无二的标签（例如请求的序列号），每个标签对应一个答复，答复用通道 <code>chan Msg</code> 来表示，当收到该标签对应的答复时，该通道返回结果（ <code>&lt;-done</code> ），这样就可以保证请求和答复一一对应，而不用关心接收消息先后顺序的问题了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mux <span class="keyword">struct</span> &#123;</span><br><span class="line">    srv     Service</span><br><span class="line">    send    <span class="keyword">chan</span> Msg</span><br><span class="line">    mu      sync.Mutex</span><br><span class="line">    pending <span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">chan</span>&lt;- Msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mux)</span> <span class="title">Init</span><span class="params">(srv Service)</span></span> &#123;</span><br><span class="line">    m.srv = srv</span><br><span class="line">    m.pending = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">chan</span> Msg)</span><br><span class="line">    <span class="keyword">go</span> m.sendLoop()</span><br><span class="line">    <span class="keyword">go</span> m.recvLoop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sendLoop</code> 负责消息的发送，而 <code>recvLoop</code> 则会对接受到的答复进行判断标签操作，并将 <code>pending</code> 中这个标签对应的通道取出，然后向这个通道发消息从而告知对应的 <code>Call</code> 函数该请求已经处理完。这两个方法就是复用机制的体现，因为它们底层只使用一个连接来处理多个请求。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mux)</span> <span class="title">sendLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> args := <span class="keyword">range</span> m.send &#123;</span><br><span class="line">        m.srv.Send(args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mux)</span> <span class="title">recvLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        reply := m.srv.Recv()</span><br><span class="line">        tag := m.srv.Tag(reply)</span><br><span class="line">   </span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        done := m.pending[tag]</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"unexpected reply"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        done &lt;- reply</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>Call</code> 方法，整个调用过程是阻塞的，先通过 <code>ReadTag</code> 获取 <code>Msg</code> 的标签，并新建一个通道 <code>done := make(chan Msg, 1)</code> ，作为将来事件完成时的通知。并将该通道存储到 <code>pending</code> 中，通过 <code>m.send &lt;- args</code> 将消息发送到 <code>send</code> 中，<code>sendLoop</code> 会执行真正的发送操作，最后阻塞，等待结果返回（ <code>&lt;-done</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mux)</span> <span class="title">Call</span><span class="params">(args Msg)</span> <span class="params">(reply Msg)</span></span> &#123;</span><br><span class="line">    tag := m.srv.ReadTag(args)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> Msg, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> m.pending[tag] != <span class="literal">nil</span> &#123;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"mux: duplicate call tag"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    m.pending[tag] = done</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line">    </span><br><span class="line">    m.send &lt;- args</span><br><span class="line">    <span class="keyword">return</span> &lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Protocol-Multiplexer&quot;&gt;&lt;a href=&quot;#Protocol-Multiplexer&quot; class=&quot;headerlink&quot; title=&quot;Protocol Multiplexer&quot;&gt;&lt;/a&gt;Protocol Multiplexer&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Shredder &amp; Gluer</title>
    <link href="https://oceanoverflow.github.io/2018/05/28/Shredder-Gluer/"/>
    <id>https://oceanoverflow.github.io/2018/05/28/Shredder-Gluer/</id>
    <published>2018-05-28T03:38:22.000Z</published>
    <updated>2018-05-28T04:01:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shredder-amp-Gluer"><a href="#Shredder-amp-Gluer" class="headerlink" title="Shredder &amp; Gluer"></a>Shredder &amp; Gluer</h1><p>有时候我们需要向服务器上传一个很大的文件，但是无奈网络不稳定，再加上使用的软件不支持断点续传，经常会出现文件上传到一半出错，无奈只能从头再来，可以说是非常烦恼了。还有的时候服务器明确规定了单次上传文件的大小，手头又没有啥好的软件可以帮助我们进行文件的分割和合并操作，只好自己写一个。</p><p>要是一个人被砍了头，手，脚，再把这几个肢体合并起来大概率这人也是废了（在医学水平没有极大进步的情况下），但是对于一个文件来说则不同，无论什么格式的文件，其实本质上都是一大堆字节，如果我们在固定的地方进行切割，最后再在被切割的地方合并的话，这个文件还是可以被正常使用的。</p><h2 id="Get-Basic-Info"><a href="#Get-Basic-Info" class="headerlink" title="Get Basic Info"></a>Get Basic Info</h2><p>在对文件切割之前，我们需要获得文件的基本信息，即文件的大小或者说是字节数，还需要决定切割后每个单位的大小，知道了这两个参数之后，就可以算出所有分割块的数量了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">"some_very_big_file"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">fileInfo, err := f.Stat()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fileSize := fileInfo.Size()</span><br><span class="line">partSize := <span class="number">1</span> &lt;&lt; <span class="number">28</span></span><br><span class="line">concurrency := <span class="keyword">int</span>(fileSize / <span class="keyword">int64</span>(partSize))</span><br><span class="line"><span class="keyword">if</span> remainder := fileSize % <span class="keyword">int64</span>(partSize); remainder != <span class="number">0</span> &#123;</span><br><span class="line">    concurrency++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Shredder"><a href="#Shredder" class="headerlink" title="Shredder"></a>Shredder</h2><p>利用 <code>io.NewSectionReader</code> 可以读取文件特定偏移的数据，然后利用<code>buffo.NewReader</code> 来缓冲读数据，利用 <code>bufio.NewWriter</code> 来缓冲写数据提高效率，最后利用 <code>io.Copy(bw, br)</code> 将文件特定部分复制到新文件中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(concurrency)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; concurrency; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        sr := io.NewSectionReader(f, <span class="keyword">int64</span>(i * partSize), <span class="keyword">int64</span>(partSize))</span><br><span class="line">        br := bufio.NewReader(sr)</span><br><span class="line">        partFile, err := os.Create(<span class="string">"partFile_"</span> + strconv.Itoa(i))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        bw := bufio.NewWriter(partFile)</span><br><span class="line">        io.Copy(bw, br)</span><br><span class="line">    &#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><h2 id="Gluer"><a href="#Gluer" class="headerlink" title="Gluer"></a>Gluer</h2><p>合并与分割互为逆操作，因为我们对上面分割后的文件采取了顺序命名操作，所以可以根据编号的顺序，利用 <code>Seek</code> 方法指定合并文件的写偏移地址，通过 <code>bufio.NewReader</code> 对分割文件进行缓冲读操作，同理利用 <code>bufio.NewWriter</code> 对合并文件进行缓冲写操作，通过 <code>io.Copy(bw, br)</code> 将分割文件放入最终合并文件的正确位置。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">matches, err := filepath.Glob(<span class="string">"partFile_*"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mergedFile, err := os.Create(<span class="string">"mergedFile"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> matches &#123;</span><br><span class="line">    ss := strings.Split(v, <span class="string">"_"</span>)</span><br><span class="line">    i, err := strconv.Atoi(ss[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    mergedFile.Seek(<span class="keyword">int64</span>(i * partSize), os.SEEK_SET)</span><br><span class="line">    f, err := os.Open(v)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    br := bufio.NewReader(f)</span><br><span class="line">    bw := bufio.NewWriter(mergedFile)</span><br><span class="line">    io.Copy(bw, br)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Shredder-amp-Gluer&quot;&gt;&lt;a href=&quot;#Shredder-amp-Gluer&quot; class=&quot;headerlink&quot; title=&quot;Shredder &amp;amp; Gluer&quot;&gt;&lt;/a&gt;Shredder &amp;amp; Gluer&lt;/h1&gt;&lt;p&gt;有时
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TUN/TAP</title>
    <link href="https://oceanoverflow.github.io/2018/05/27/TUNTAP/"/>
    <id>https://oceanoverflow.github.io/2018/05/27/TUNTAP/</id>
    <published>2018-05-27T06:05:03.000Z</published>
    <updated>2018-05-27T06:07:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TUNTAP"><a href="#TUNTAP" class="headerlink" title="TUNTAP"></a>TUNTAP</h1><p><a href="http://tuntaposx.sourceforge.net/" target="_blank" rel="noopener">TUN/TAP</a> 为我们在 <code>macOS</code> 下面提供了虚拟网络接口（ <code>TUN/TAP</code> ），其本质是字符设备（ <code>character special file</code> ）。因为在 <code>Unix</code> 中一切皆文件，所以我们可以像操作文件一样操作这两种设备。</p><p><img src="https://1.bp.blogspot.com/-mnxh0kXQeKI/V10lx7q7H4I/AAAAAAAALYs/i427R0SfAQckApSz3piMDu7LiJnPzzu4gCLcB/s1600/tuntap.png" alt="TUNTAP"></p><p><code>TUN</code> 模拟网络层设备，它可以操作第3层数据包例如 <code>IP</code> 数据包。 <code>TAP</code> 模拟链路层设备，用于操作第2层数据包例如以太网帧。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxDevices = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrBusy        = errors.New(<span class="string">"device is already in use"</span>)</span><br><span class="line">  ErrNotReady    = errors.New(<span class="string">"device is not ready"</span>)</span><br><span class="line">  ErrExhausted   = errors.New(<span class="string">"no devices are available"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="keyword">string</span></span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">    io.ReadWriteCloser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tun</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(Interface, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> newTUN(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tap</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(Interface, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> newTAP(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TUN/TAP</code> 在 <code>/dev</code>目录下，以 <code>/dev/tunX</code> 和 <code>/dev/tapX</code> 的形式存在，<code>X</code> 从0到15。每个字符设备都与同名的网络接口关联。网络接口只有在相应的字符设备被程序打开时才会创建，并且在字符设备关闭时将被删除。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> device <span class="keyword">struct</span> &#123;</span><br><span class="line">    n <span class="keyword">string</span></span><br><span class="line">    f *os.File</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> d.n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> d.n &#125;</span><br></pre></td></tr></table></figure><p>新创建设备时，我们像正常打开文件一样使用 <code>TUN</code> 或者 <code>TAP</code> 设备，如果设备已经被占用，则报 <code>ErrBusy</code> 错误。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newDevice</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(Interface, error)</span></span> &#123;</span><br><span class="line">    file, err := os.OpenFile(name, os.O_EXCL|os.O_RWWR, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> isBusy(err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrBusy</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> &amp;device&#123;n: name, f: file&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBusy</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> perr, ok := err.(*os.PathError); ok &#123;</span><br><span class="line">        <span class="keyword">if</span> code, ok := perr.Err.(syscall.Errno); ok &#123;</span><br><span class="line">            <span class="keyword">if</span> code == <span class="number">0x10</span> || code == <span class="number">0x11</span> &#123;</span><br><span class="line">                <span class="comment">// device busy || exclusive lock</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tunX</code> 是 <code>IP</code> 隧道设备，可用于与内核交换 <code>IP</code> 数据包。使用 <code>read()</code> 获取单个数据包，使用 <code>write()</code> 可以将数据包写入 <code>/dev/tunX</code> 设备中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTUN</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(Interface, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := o; i &lt; maxDevices; i++ &#123;</span><br><span class="line">            iface, err := newDevice(<span class="string">"/dev/tun"</span> + strconv.Itoa(i))</span><br><span class="line">            <span class="keyword">if</span> err == ErrBusy &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ErrExhausted</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newDevice(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tapX</code> 是 <code>ethertap</code> 设备，为内核的以太网层提供接口。每次从 <code>/dev/tapX</code> 字符设备中读取或写入一个数据包。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTAP</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(Interface, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := o; i &lt; maxDevices; i++ &#123;</span><br><span class="line">            iface, err := newDevice(<span class="string">"/dev/tap"</span> + strconv.Itoa(i))</span><br><span class="line">            <span class="keyword">if</span> err == ErrBusy &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ErrExhausted</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newDevice(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于字符设备，可以像操作正常文件一样进行读/写操作来向设备写入数据包或者获取数据包。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    n, err := d.f.Read(p)</span><br><span class="line">    <span class="keyword">if</span> isNotReady(err) &#123;</span><br><span class="line">        err = ErrNotReady</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    n, err := d.f.Write(p)</span><br><span class="line">    <span class="keyword">if</span> isNotReady(err) &#123;</span><br><span class="line">        err = ErrNotReady </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isNotReady</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> perr, ok := err.(*os.PathError); ok &#123;</span><br><span class="line">        <span class="keyword">if</span> code, ok := perr.Err.(syscall.Errno); ok &#123;</span><br><span class="line">            <span class="keyword">if</span> code == <span class="number">0x05</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123; </span><br><span class="line">    <span class="keyword">return</span> d.f.Close() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TUNTAP&quot;&gt;&lt;a href=&quot;#TUNTAP&quot; class=&quot;headerlink&quot; title=&quot;TUNTAP&quot;&gt;&lt;/a&gt;TUNTAP&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://tuntaposx.sourceforge.net/&quot; target=&quot;_b
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Try Lock</title>
    <link href="https://oceanoverflow.github.io/2018/05/26/TryLock/"/>
    <id>https://oceanoverflow.github.io/2018/05/26/TryLock/</id>
    <published>2018-05-26T14:05:27.000Z</published>
    <updated>2018-05-26T14:11:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Try-Lock"><a href="#Try-Lock" class="headerlink" title="Try Lock"></a>Try Lock</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;...&#125;</span><br><span class="line"><span class="comment">// Lock locks m. </span></span><br><span class="line"><span class="comment">// If the lock is already in use, the calling goroutine</span></span><br><span class="line"><span class="comment">//  blocks until the mutex is available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">// <span class="title">Unlock</span> <span class="title">unlocks</span> <span class="title">m</span>. </span></span><br><span class="line"><span class="function">// <span class="title">It</span> <span class="title">is</span> <span class="title">a</span> <span class="title">run</span>-<span class="title">time</span> <span class="title">error</span> <span class="title">if</span> <span class="title">m</span> <span class="title">is</span> <span class="title">not</span> <span class="title">locked</span> <span class="title">on</span> <span class="title">entry</span> <span class="title">to</span> <span class="title">Unlock</span>. </span></span><br><span class="line"><span class="function">// </span></span><br><span class="line"><span class="function">// <span class="title">A</span> <span class="title">locked</span> <span class="title">Mutex</span> <span class="title">is</span> <span class="title">not</span> <span class="title">associated</span> <span class="title">with</span> <span class="title">a</span> <span class="title">particular</span> <span class="title">goroutine</span>. </span></span><br><span class="line"><span class="function">// <span class="title">It</span> <span class="title">is</span> <span class="title">allowed</span> <span class="title">for</span> <span class="title">one</span> <span class="title">goroutine</span> <span class="title">to</span> <span class="title">lock</span> <span class="title">a</span> <span class="title">Mutex</span> <span class="title">and</span> <span class="title">then</span></span></span><br><span class="line"><span class="function">// <span class="title">arrange</span> <span class="title">for</span> <span class="title">another</span> <span class="title">goroutine</span> <span class="title">to</span> <span class="title">unlock</span> <span class="title">it</span>.</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><code>sync.Mutex</code> 提供了 <code>Lock</code> 和 <code>Unlock</code> 两个方法分别对应上锁和解锁操作，如果锁已经被占据了，<code>Lock</code> 方法会阻塞相应的 <code>goroutine</code> 。在 <code>C</code> 中也有互斥锁的实现，但除了一般的上锁操作和解锁操作，它还多了一种方法 —— <code>pthread_mutex_trylock</code> ，也就是<code>TryLock</code> ， <code>pthread_mutex_trylock</code> 语义与 <code>pthread_mutex_lock</code> 类似，不同的是在锁已经被占据时返回 <code>EBUSY</code> 而不是挂起等待。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// lock a mutex, If the mutex is already locked, </span></span><br><span class="line"><span class="comment">// the calling thread will block until the mutex becomes available.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// unlock a mutex</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// attempt to lock a mutex without blocking</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>下面我们自己来实现一个 <code>golang</code> 版本的 <code>try lock</code> 。实现互斥锁的关键就在于原子操作，保证即使有多个 <code>CPU</code> 存在的情况下，也不能同时执行同一条指令。利用 <code>sync/atomic</code> 库下面的方法可以轻松实现对一个数的原子操作。</p><p>我们实现的互斥锁中有两个东西，首先是一个 <code>v int32</code> ，因为是互斥锁，所以初始化为1，还有一个 <code>ch</code> 通道用于唤醒阻塞等待的 <code>goroutine</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    v <span class="keyword">int32</span></span><br><span class="line">    ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m.v = <span class="number">1</span></span><br><span class="line">    m.ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Lock</code> 方法获取一个锁，如果锁被占据了，则一直阻塞等待( <code>&lt;-m.ch</code> )，等待其他 <code>goroutine</code> 唤醒，相当于 <code>PV</code> 操作中的 <code>P</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;m.v, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> v := atomic.LoadInt32(&amp;m.v); v &gt;= <span class="number">0</span> &amp;&amp; atomic.SwapInt32(&amp;m.v, <span class="number">-1</span>) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        &lt;-m.ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Unlock</code> 方法释放 <code>Mutex</code> ，如果当前有因为等待该锁而被阻塞的<code>goroutine</code> （说明 <code>atomic.SwapInt32(&amp;m.v, 1) != 0</code> ），则执行 <code>m.ch &lt;- struct{}{}</code> 将阻塞的 <code>goroutine</code> 唤醒，对应 <code>PV</code> 操作中的 <code>V</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.SwapInt32(&amp;m.v, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> m.ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>Lock</code> 方法会在锁可用之前阻塞调用该方法的 <code>goroutine</code> ，<code>TryLoad</code> 方法并不会阻塞，通过 <code>atomic.LoadInt32(&amp;m.v)</code> 来查看当前资源是否可用，如果不可用(说明 <code>v &lt;= 0</code> )，则返回 <code>false</code> ，如果 <code>atomic.CompareAndSwapInt32(&amp;m.v, 1, 0)</code> 返回 <code>true</code> ，说明资源可用直接上锁。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">TryLock</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    v := atomic.LoadInt32(&amp;m.v)</span><br><span class="line">    <span class="keyword">if</span> v &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> atomic.CompareAndSwapInt32(&amp;m.v, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Try-Lock&quot;&gt;&lt;a href=&quot;#Try-Lock&quot; class=&quot;headerlink&quot; title=&quot;Try Lock&quot;&gt;&lt;/a&gt;Try Lock&lt;/h1&gt;&lt;figure class=&quot;highlight golang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Concurrent Prime Sieve</title>
    <link href="https://oceanoverflow.github.io/2018/05/25/ConcurrentPrimeSieve/"/>
    <id>https://oceanoverflow.github.io/2018/05/25/ConcurrentPrimeSieve/</id>
    <published>2018-05-25T06:36:04.000Z</published>
    <updated>2018-05-25T10:43:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Concurrent-Prime-Sieve"><a href="#Concurrent-Prime-Sieve" class="headerlink" title="Concurrent Prime Sieve"></a>Concurrent Prime Sieve</h1><p>本科刚学编程的时候经常遇到判断一个数是不是素数之类的编程题，当时基础比较差，用的方法也相当简单粗暴，直接采用枚举法判断，虽然简单但是效率很低，时间复杂度为 <code>O(n^2)</code> ，后来慢慢了解了神奇的埃氏筛法，只用 <code>O(nlglgn)</code> 的时间复杂度就可以完成，效率大幅度提高，如果对埃氏筛不了解的童鞋可以看看这篇文章 <a href="http://empslocal.ex.ac.uk/people/staff/mrwatkin/sieve.htm" target="_blank" rel="noopener">sieve of Eratosthenes</a>。</p><p><img src="http://empslocal.ex.ac.uk/people/staff/mrwatkin/bridge1.jpg" alt="Sieve"></p><p>一般的埃氏筛实现都是单线程的，并不能完全发挥现在多核 <code>CPU</code> 的全部性能，下面给出了 <code>Golang</code> 并发版本的埃氏筛实现。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span> ;; i++ &#123;</span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(in, out <span class="keyword">chan</span> <span class="keyword">int</span>, prime <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i := &lt;-in</span><br><span class="line">        <span class="keyword">if</span> i % prime != <span class="number">0</span> &#123;</span><br><span class="line">            out &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> generate(ch)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        prime := &lt;-ch</span><br><span class="line">        fmt.Println(prime)</span><br><span class="line">        out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">        <span class="keyword">go</span> filter(ch, out, prime)</span><br><span class="line">        ch = out</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>并发版本的埃氏筛代码行数虽然不多，然而实现还是比较 <code>tricky</code> 的，谁要是第一遍就看懂算我输（你要是天才的话当我没说过）。</p><p><img src="https://talks.golang.org/2012/concurrency/images/gophereartrumpet.jpg" alt="channel"></p><p>首先要起一个 <code>goroutine</code> ，记为 <code>G</code> ， 用于生成2以后的整数，并放到通道中（记为 <code>out0</code> ）供别的 <code>goroutine</code> 读取。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> generate(ch)          <span class="comment">// ch &lt;- i</span></span><br></pre></td></tr></table></figure><p>进入第一个 <code>for</code> 循环，从上面的通道中取出第一个数2，毫无疑问，2为素数，所以创建一个通道 <code>out1</code> ，并起一个 <code>goroutine</code> ，记为 <code>filter1</code> ，用于过滤所有2的整数倍的数，此时通道数据流的走向为 <code>G -&gt; out1</code> ，只有通过 <code>filter1</code> 筛选的数才有资格进入 <code>out1</code> 中，此时将 <code>ch</code> 设为 <code>out1</code> （ <code>ch</code> 用于记录该链上的最后一个通道），第一个循环结束。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prime := &lt;-ch             <span class="comment">// &lt;-ch</span></span><br><span class="line">fmt.Println(prime)        <span class="comment">// 输出2 </span></span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)     <span class="comment">// 记作out1</span></span><br><span class="line"><span class="keyword">go</span> filter(ch, out, prime) <span class="comment">// ch -&gt; out1</span></span><br><span class="line">ch = out                  <span class="comment">// ch = out1</span></span><br><span class="line">        ^</span><br><span class="line">        |</span><br><span class="line">      +----+ </span><br><span class="line">G ---&gt;|out1|---&gt;</span><br><span class="line">      +----+    </span><br><span class="line">        %<span class="number">2</span></span><br><span class="line">        ^</span><br><span class="line">        |</span><br><span class="line">        ch</span><br></pre></td></tr></table></figure><p>进入第二个 <code>for</code> 循环，因为此时 <code>ch</code> 为 <code>out1</code> ，尝试去 <code>out1</code> 中取，3由 <code>G</code> 产生，然后经过 <code>filter1</code> 后成功进入 <code>out1</code> ，说明3是素数，此时我们再创建一个通道 <code>out2</code> ，并且再起一个 <code>goroutine</code> ，记为 <code>filter2</code> ，该 <code>goroutine</code> 会过滤所有3的整数倍的数，此时通道数据流的走向为 <code>G -&gt; out1 -&gt; out2</code> ，只有成功经过 <code>filter1,filter2</code> 筛选的数才能进入通道 <code>out2</code> 中，将 <code>ch</code> 设为 <code>out2</code> ，第二个循环结束。当<code>G</code> 中产生4，并尝试在这个链上移动时，当它经过 <code>filter1</code> 时，由于4是2的整数倍，说明不是素数，不符合要求，4出局。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prime := &lt;-ch             <span class="comment">// &lt;-out1</span></span><br><span class="line">fmt.Println(prime)        <span class="comment">// 输出3</span></span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)     <span class="comment">// 记作out2</span></span><br><span class="line"><span class="keyword">go</span> filter(ch, out, prime) <span class="comment">// out1 -&gt; out2</span></span><br><span class="line">ch = out                  <span class="comment">// ch = out2</span></span><br><span class="line"></span><br><span class="line">        ^         ^</span><br><span class="line">        |         |</span><br><span class="line">      +----+    +----+    </span><br><span class="line">G ---&gt;|out1|---&gt;|out2|---&gt;</span><br><span class="line">      +----+    +----+ </span><br><span class="line">        %<span class="number">2</span>        %<span class="number">3</span></span><br><span class="line">                   ^</span><br><span class="line">                   |</span><br><span class="line">                   ch</span><br></pre></td></tr></table></figure><p>进入第三个 <code>for</code> 循环，同样的，此时 <code>ch</code> 为 <code>out2</code> ，尝试去 <code>out2</code> 中取，5由 <code>G</code> 产生，经过 <code>filter1,filter2</code> 后成功进入 <code>out2</code> ，说明5为素数，此时我们再创建一个通道 <code>out3</code> ，并且再起一个 <code>goroutine</code> ，记为 <code>filter3</code> ，该 <code>goroutine</code> 会过滤所有5的整数倍的数，此时通道数据流的走向为 <code>G -&gt; out1 -&gt; out2 -&gt; out3</code> ，只有成功经过 <code>filter1,filter2,filter3</code> 筛选的数才能进入通道 <code>out3</code> 中，将 <code>ch</code> 设为 <code>out3</code> ，第三个循环结束。当 <code>G</code> 中产生6，并尝试在这个链上移动时，经过 <code>filter1</code> 时，由于6是2的整数倍，说明不是素数，不符合要求，同样出局。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prime := &lt;-ch             <span class="comment">// &lt;-out2</span></span><br><span class="line">fmt.Println(prime)        <span class="comment">// 输出5</span></span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)     <span class="comment">// 记作out3</span></span><br><span class="line"><span class="keyword">go</span> filter(ch, out, prime) <span class="comment">// out2 -&gt; out3</span></span><br><span class="line">ch = out                  <span class="comment">// ch=out3</span></span><br><span class="line"></span><br><span class="line">        ^         ^         ^</span><br><span class="line">        |         |         |</span><br><span class="line">      +----+    +----+    +----+    </span><br><span class="line">G ---&gt;|out1|---&gt;|out2|---&gt;|out3|---&gt;</span><br><span class="line">      +----+    +----+    +----+</span><br><span class="line">        %<span class="number">2</span>        %<span class="number">3</span>        %<span class="number">5</span>        </span><br><span class="line">                            ^</span><br><span class="line">                            |</span><br><span class="line">                            ch</span><br></pre></td></tr></table></figure><p>进入第四个 <code>for</code> 循环，此时 <code>ch</code> 为 <code>out3</code> ，尝试去 <code>out3</code> 中取，7由 <code>G</code> 产生，然后经过 <code>filter1,filter2,filter3</code> 筛选后成功进入 <code>out3</code> ，说明7是素数，此时我们再创建一个通道 <code>out4</code> ，并且再起一个 <code>goroutine</code> ，记为 <code>filter4</code> ，该 <code>goroutine</code> 会过滤所有7的整数倍的数，此时通道数据流的走向为 <code>G -&gt; out1 -&gt; out2 -&gt; out3 -&gt; out4</code> ，只有成功经过 <code>filter1,filter2,filter2,filter4</code> 筛选的数才能进入通道 <code>out4</code> 中，将 <code>ch</code> 设为 <code>out4</code> ，第四个循环结束。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prime := &lt;-ch             <span class="comment">// &lt;-out3</span></span><br><span class="line">fmt.Println(prime)        <span class="comment">// 输出7</span></span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)     <span class="comment">// 记作out4</span></span><br><span class="line"><span class="keyword">go</span> filter(ch, out, prime) <span class="comment">// out3 -&gt; out4</span></span><br><span class="line">ch = out                  <span class="comment">// ch=out4</span></span><br><span class="line"></span><br><span class="line">        ^         ^         ^         ^</span><br><span class="line">        |         |         |         |</span><br><span class="line">      +----+    +----+    +----+    +----+</span><br><span class="line">G ---&gt;|out1|---&gt;|out2|---&gt;|out3|---&gt;|out4|---&gt;</span><br><span class="line">      +----+    +----+    +----+    +----+</span><br><span class="line">        %<span class="number">2</span>        %<span class="number">3</span>        %<span class="number">5</span>        %<span class="number">7</span>            </span><br><span class="line">                                      ^</span><br><span class="line">                                      |</span><br><span class="line">                                      ch</span><br></pre></td></tr></table></figure><p>以此类推，并发版本素数筛的本质就是构建 <code>DaisyChain</code> ，每个数经过 <code>DaisyChain</code> 层层筛选后，如果最终保留，说明该数为素数，作为 <code>DaisyChain</code> 的最后一层加入，如此往复，就可以达到快速筛选素数的目的了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Concurrent-Prime-Sieve&quot;&gt;&lt;a href=&quot;#Concurrent-Prime-Sieve&quot; class=&quot;headerlink&quot; title=&quot;Concurrent Prime Sieve&quot;&gt;&lt;/a&gt;Concurrent Prime Sie
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Single Flight</title>
    <link href="https://oceanoverflow.github.io/2018/05/24/SingleFlight/"/>
    <id>https://oceanoverflow.github.io/2018/05/24/SingleFlight/</id>
    <published>2018-05-24T05:46:36.000Z</published>
    <updated>2018-05-24T06:06:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Single-Flight"><a href="#Single-Flight" class="headerlink" title="Single Flight"></a>Single Flight</h1><h2 id="SingleFlight"><a href="#SingleFlight" class="headerlink" title="SingleFlight"></a>SingleFlight</h2><p>很多人闲来无事就喜欢刷票圈逛微博，所有的消息看完一遍之后，就开启疯狂下拉刷新模式，希望能第一时间看到什么劲爆的消息。对于应用的使用者，这倒没什么，但是如果连续多次下拉刷新操作都分别对应一次服务器请求的话，那么服务器估计就得扑街了，所以我们需要限制在一定时间内同一个请求的数量，以避免无用的请求。</p><p>我们需要实现一种机制，对于特定的请求，在该请求触发之后但还没有返回结果之前，对于之后所有相同的请求，无论多少个，都不会真正触发，而是等待第一个请求返回，然后共用一个结果。</p><p><code>SingleFlight</code> 就可以帮助我们实现上述的要求，我们使用结构体 <code>call</code> 来表示特定请求返回的结果，在 <code>SingleFlight</code> 结构体中使用一个 <code>map</code> 来存储不同的请求结果，也就是一个请求对应一个<code>call</code>，并用锁保护 <code>map</code> 的读写。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SingleFlight <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="keyword">string</span>]*call</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">    wg  sync.WaitGroup</span><br><span class="line">    val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    err error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说，<code>call</code> 是一些所需时间长，消耗资源多的操作的返回结果（例如<code>HTTP</code> 请求）。<code>Do</code> 方法就保证对于同一个请求，在结果未返回之前，后面相同的请求都不会真正进行，而是等待第一个请求的结果。在函数运行时需要检测当前 <code>map</code> 是否为空，如果为空则 <code>make</code> 一个，然后检查是否有相同的请求正在进行，如果有则使用 <code>c.wg.Wait</code> 来等待执行结果。要是这个请求是该时间段内第一个请求，则将它加入 <code>map</code> 中，然后通过 <code>c.wg.Add</code> 来增加 <code>WaitGroup</code> 应该等待的 <code>goroutine</code> 个数，当函数执行完成之后，通过 <code>c.wg.Done</code> 来广播告知他人，此时任何调用<code>c.wg.Wait</code> 的地方都会解除阻塞，并返回该结果。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sf *SingleFlight)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    sf.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sf.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        sf.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> c, ok := sf.m[key]; ok &#123;</span><br><span class="line">        sf.Unlock()</span><br><span class="line">        c.wg.Wait()</span><br><span class="line">        <span class="keyword">return</span> c.val, c.err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">new</span>(call)</span><br><span class="line">    c.wg.Add(<span class="number">1</span>)</span><br><span class="line">    sf.m[key] = c</span><br><span class="line">    sf.Unlock()</span><br><span class="line"></span><br><span class="line">    c.val, c.err = fn()</span><br><span class="line">    c.wg.Done()</span><br><span class="line">    </span><br><span class="line">    sf.Lock()</span><br><span class="line">    <span class="built_in">delete</span>(sf.m, key)</span><br><span class="line">    sf.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c.val, c.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p><code>SingleFlight</code> 机制主要是靠 <code>WaitGroup</code> 实现，一般来说，因为<code>main routine</code> 不会等待 <code>goroutine</code> 执行完成，所以需要某种机制等待所有的<code>goroutine</code> 执行完成，使用 <code>WaitGroup</code> 就可以帮助我们达到这样的目的。</p><p><code>WaitGroup</code> 的本质就是一个计数器，当每起一个新的 <code>goroutine</code> 时，我们调用 <code>wg.Add(1)</code> 来增加计数器的数量，当该 <code>goroutine</code> 执行完毕时，利用 <code>wg.Done()</code> 可以将计数器减一，调用 <code>Wait()</code> 方法的地方会一直阻塞 <code>main routine</code> ，只有当计数器为0时，<code>wg</code> 才会解除阻塞，此时程序才可以继续执行下去。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</span></span><br><span class="line">    <span class="comment">// 64-bit atomic operations require 64-bit alignment, but 32-bit</span></span><br><span class="line">    <span class="comment">// compilers do not ensure it. So we allocate 12 bytes and then use</span></span><br><span class="line">    <span class="comment">// the aligned 8 bytes in them as state.</span></span><br><span class="line">    state1 [<span class="number">12</span>]<span class="keyword">byte</span></span><br><span class="line">    sema   <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> urls = []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"http://www.golang.org/"</span>,</span><br><span class="line">    <span class="string">"http://www.google.com/"</span>,</span><br><span class="line">    <span class="string">"http://www.somestupidname.com/"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">    <span class="comment">// Increment the WaitGroup counter.</span></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// Launch a goroutine to fetch the URL.</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Decrement the counter when the goroutine completes</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done() </span><br><span class="line">    <span class="comment">// Fetch the URL.</span></span><br><span class="line">    http.Get(url)</span><br><span class="line">    &#125;(url)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Wait for all HTTP fetches to complete.</span></span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Single-Flight&quot;&gt;&lt;a href=&quot;#Single-Flight&quot; class=&quot;headerlink&quot; title=&quot;Single Flight&quot;&gt;&lt;/a&gt;Single Flight&lt;/h1&gt;&lt;h2 id=&quot;SingleFlight&quot;&gt;&lt;a href
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LRU</title>
    <link href="https://oceanoverflow.github.io/2018/05/24/LRU/"/>
    <id>https://oceanoverflow.github.io/2018/05/24/LRU/</id>
    <published>2018-05-23T16:23:40.000Z</published>
    <updated>2018-05-23T16:29:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Least-Recently-Used"><a href="#Least-Recently-Used" class="headerlink" title="Least Recently Used"></a>Least Recently Used</h1><p>最近最少使用（ <code>Least Recently Used</code> ）也就是 <code>LRU</code> 算法是内存页面置换算法的一种，使用该算法可以在有限的资源内提高内存访问的速度，它利用了著名的局部性原理，更具体的说是时间局部性，也就是说如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</p><p>例如我们有3个物理块，访问序列为 <code>7，0，1，2，0，3，0</code></p><ul><li>访问7时，LRU缺失，此时LRU未满，放入7，此时淘汰顺序为7</li><li>访问0时，LRU缺失，此时LRU未满，放入0，此时淘汰顺序为7，0</li><li>访问1时，LRU缺失，此时LRU未满，放入1，此时淘汰顺序为7，0 ，1</li><li>访问2时，LRU缺失，此时LRU已满，驱逐7，放入2，此时淘汰顺序为0，1，2</li><li>访问0时，LRU命中，更新淘汰顺序，此时淘汰循序为1，2，0</li><li>访问3时，LRU缺失，此时LRU已满，驱逐1，放入3，此时淘汰顺序为2，0，3</li><li>访问0时，LRU命中，更新淘汰顺序，此时淘汰顺序为0，3，2</li></ul><p><img src="https://i.ytimg.com/vi/4wVp97-uqr0/maxresdefault.jpg" alt="LRU"></p><p>我们利用链表（ <code>*list.List</code> ）维护其淘汰顺序，利用 <code>map</code> 作为其存储引擎（作为物质基础）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;---------------------------------------------------------&gt;</span><br><span class="line">newest                                               oldest</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Key <span class="keyword">interface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    key Key</span><br><span class="line">    value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">    MaxEntries <span class="keyword">int</span></span><br><span class="line">    OnEvicted  <span class="function"><span class="keyword">func</span><span class="params">(key Key, value <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">ll</span>         *<span class="title">list</span>.<span class="title">List</span></span></span><br><span class="line"><span class="function">    <span class="title">cache</span>      <span class="title">map</span>[<span class="title">interface</span></span>&#123;&#125;]*list.Element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(maxEntries <span class="keyword">int</span>)</span> *<span class="title">Cache</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Cache&#123;</span><br><span class="line">        MaxEntries: maxEntries,</span><br><span class="line">        ll:         list.New(),</span><br><span class="line">        cache:      <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*list.Element),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们经常需要判断当前的 <code>LRU</code> 缓存是否存满，所以我们构造一个<code>helper function</code> 来获取当前缓存的容量。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.cache == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c.ll.Len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>淘汰顺序在两种情况下会更新，一是新增元素时，如果元素在 <code>LRU</code> 缓存中不存在，则将它放在链表的头部（ <code>PushFront</code> ），如果存在，则直接将其移到链表的头部（ <code>MoveToFront</code> ）。二是在获取元素时，如果元素存在，则直接将其移到链表的头部（ <code>MoveToFront</code> ）。这样一来我们就能确保最新的东西在链表头，最老的东西在链表尾。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Add</span><span class="params">(key Key, value interfacfe&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.cache == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.cache = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;*list.Element])</span><br><span class="line">        c.ll = list.New()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ee, ok := c.cache[key]; ok &#123;</span><br><span class="line">        c.ll.MoveToFront(ee)</span><br><span class="line">        ee.Value.(*entry).value = value</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ele := c.ll.PushFront(&amp;entry&#123;key, value&#125;)</span><br><span class="line">    c.cache[key] = ele</span><br><span class="line">    <span class="keyword">if</span> c.MaxEntries != <span class="number">0</span> &amp;&amp; c.ll.Len() &gt; c.MaxEntries &#123;</span><br><span class="line">        c.RemoveOldest()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Get</span><span class="params">(key Key)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.cache == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ele, hit := c.cache[key]; hit &#123;</span><br><span class="line">        c.ll.MoveToFront(ele)</span><br><span class="line">        <span class="keyword">return</span> ele.Value.(*entry).value, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RemoveOldest</code> 将最老的元素淘汰，也就是说将链表中最后一项移除，并将<code>map</code> 中对应的元素删除。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">RemoveOldest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.cache == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ele := c.ll.Back()</span><br><span class="line">    <span class="keyword">if</span> ele != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.removeElement(ele)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">removeElement</span><span class="params">(e *list.Element)</span></span> &#123;</span><br><span class="line">    c.ll.Remove(e)</span><br><span class="line">    kv := e.Value.(*entry)</span><br><span class="line">    <span class="built_in">delete</span>(c.cache, kv.key)</span><br><span class="line">    <span class="keyword">if</span> c.OnEvicted != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.OnEvicted(kv.key, kv.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清除 <code>LRU</code> 缓存只需要将链表和 <code>map</code> 设为 <code>nil</code> 就可以了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.OnEvicted != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, e := <span class="keyword">range</span> c.cache &#123;</span><br><span class="line">            kv := e.Value.(*entry)</span><br><span class="line">            c.OnEvicted(kv.key, kv.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.ll = <span class="literal">nil</span></span><br><span class="line">    c.cache = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Least-Recently-Used&quot;&gt;&lt;a href=&quot;#Least-Recently-Used&quot; class=&quot;headerlink&quot; title=&quot;Least Recently Used&quot;&gt;&lt;/a&gt;Least Recently Used&lt;/h1&gt;&lt;p&gt;最近
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Heartbeat</title>
    <link href="https://oceanoverflow.github.io/2018/05/23/Heartbeat/"/>
    <id>https://oceanoverflow.github.io/2018/05/23/Heartbeat/</id>
    <published>2018-05-23T09:52:18.000Z</published>
    <updated>2018-06-08T14:19:26.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Heartbeat"><a href="#Heartbeat" class="headerlink" title="Heartbeat"></a>Heartbeat</h1><p>在一个分布式集群中，个别节点出现宕机的情况并不少见，例如在一个只有一个主节点，和多个从节点的集群中，从节点发生宕机对整个系统影响倒不算太大，如果主节点宕机，系统将不能正常运行，所以必须有一个机制检测各个节点是否正常运行。</p><p>心跳机制是设计高可用性分布式系统的重要技术。心跳机制通过周期性地向其他节点发送心跳消息并等待确认来检测集群中的节点状态。当节点状态发生变化时，会通知发送心跳检测消息的节点。如果发送心跳检测消息的节点在一段时间内未收到确认，则该节点将被视为失败。这是心跳机制的基本原理。</p><p>在设计心跳时，需要考虑心跳是单向，还是双向的，单向的心跳可以保证当发送方出现问题时，接收方在一定的时间内可以检测到，而双向则可以保证双方都可以检测到对方是否出现问题。</p><p>下面我们来实现一个单向的心跳检测机制，这里存在一个主节点和多个从节点，主节点会向连接到自己的从节点定期发送心跳消息，如果从节点在规定时间内没有收到来自主节点的心跳消息，则认为主节点发生异常，然后进行相应的超时处理流程（如自己参与选举成为主节点等）。</p><h2 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h2><p>在主节点中我们维护连接到主节点的从节点的信息，使用用一个数组保存，当节点加入或者退出系统时候，分别调用 <code>Add</code> 和 <code>Del</code> 方法进行增删。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Master <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    n      <span class="keyword">int</span></span><br><span class="line">    slaves []*Slave</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">Add</span><span class="params">(s *Slave)</span></span> &#123;</span><br><span class="line">    s.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.Unlock()</span><br><span class="line">    s.n++</span><br><span class="line">    s.slaves = <span class="built_in">append</span>(s.slaves, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">Del</span><span class="params">(s *Slave)</span></span> &#123;</span><br><span class="line">    s.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.Unlock()</span><br><span class="line">    n := <span class="built_in">make</span>([]*Slave, <span class="built_in">len</span>(s.slaves)<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> m.slaves &#123;</span><br><span class="line">        <span class="keyword">if</span> x != s &#123;</span><br><span class="line">            n = <span class="built_in">append</span>(n, x)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    s.n--</span><br><span class="line">    s.slaves = n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦从节点与主节点建立连接，主节点会通过 <code>heartbeatLoop</code> 向从节点定时发送心跳消息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    s := &amp;slave&#123;</span><br><span class="line">        conn: conn,</span><br><span class="line">        connectTime: time.Now()</span><br><span class="line">    &#125;</span><br><span class="line">    m.Add(s)</span><br><span class="line">    log.Println(<span class="string">"Connected: "</span>, conn.RemoteAddr)</span><br><span class="line">    <span class="keyword">go</span> s.heartbeatLoop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Slave"><a href="#Slave" class="headerlink" title="Slave"></a>Slave</h2><p><code>slave</code> 是主节点维护的从节点的信息，<code>connectTime</code> 表示从节点第一次连接的时间，<code>exit chan struct{}</code> 用于接收退出信号，例如当从节点退出该集群时或者从节点发生宕机时，通过该机制停止向从节点发送心跳信息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slave <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    conn        net.Conn</span><br><span class="line">    connectTime time.Time</span><br><span class="line">    exit        <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>hearbeatLoop</code> 方法中，通过 <code>time.NewTicker</code> 来设置一个定时器，每隔一秒钟向从节点发送心跳消息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *slave)</span> <span class="title">heartbeatLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.conn.Close()</span><br><span class="line">        ticker.Stop()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> t := &lt;-ticker.C:</span><br><span class="line">            s.Lock()</span><br><span class="line">            c.conn.Write([]<span class="keyword">byte</span>(fmt.Sprintf(<span class="string">"heartbeat %d"</span>, time.Now())))</span><br><span class="line">            s.Unlock()</span><br><span class="line">        <span class="keyword">case</span> &lt;-s.exit:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *slave)</span> <span class="title">stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.exit &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Main-Routine"><a href="#Main-Routine" class="headerlink" title="Main Routine"></a>Main Routine</h2><h2 id="master-main"><a href="#master-main" class="headerlink" title="master main"></a>master main</h2><p>主节点通过监听相应的端口，处理与自己连接的请求，对于每个连接请求，都会起一个新的 <code>goroutine</code> 分别处理。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":8080"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> l.Close()</span><br><span class="line">    m := &amp;Master&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> m.handleConnection(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="slave-main"><a href="#slave-main" class="headerlink" title="slave main"></a>slave main</h2><p>从节点会接收来自主节点的心跳消息，并通过 <code>time.NewTimer</code> 来设置一个定时器，如果在规定的时间内没有收到来自主节点的消息，则说明心跳超时，怀疑主节点出现异常，如果在规定的时间内收到心跳消息，则通过<code>timer.Reset</code> 来重置定时器。一般来说，心跳超时的时间是心跳发送周期的3倍左右。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:8080"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timer := time.NewTimer(<span class="number">3</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    msgChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100</span>)</span><br><span class="line">            n, err := conn.Read(b)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(err)</span><br><span class="line">            &#125;</span><br><span class="line">            msgChan &lt;- <span class="keyword">string</span>(b[:n])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(conn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> m := &lt;-msgChan:</span><br><span class="line">            fmt.Println(m)</span><br><span class="line">        <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">            fmt.Println(<span class="string">"Timed out"</span>)</span><br><span class="line">            <span class="comment">// do something here</span></span><br><span class="line">            &lt;-msgChan</span><br><span class="line">        &#125;</span><br><span class="line">        timer.Reset(<span class="number">3</span> * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Randomized-Timeout"><a href="#Randomized-Timeout" class="headerlink" title="Randomized Timeout"></a>Randomized Timeout</h2><p>上面使用的计时器的时间间隔都是相同的，但是在很多工程项目例如 <code>Raft</code> 中，常常使用 <code>Randomized Timeout</code> 这种奇技淫巧来减少 <code>split votes</code> 情况的发生。使用随机超时我们需要自己定义一个 <code>var timeout &lt;-chan time.Time</code> ，每次重置计时器时（例如收到心跳消息或者计时器超时），先将相应的 <code>timeout</code> 设置为 <code>nil</code> ，然后获取一个随机的时间间隔，并使用 <code>time.After</code> 来获得一个新的计时器。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UTC().UnixNano())</span><br><span class="line">    ticker := time.NewTicker(<span class="number">250</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line">    appendEntries := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">            appendEntries &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> timeout &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">    <span class="keyword">for</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> timeout == <span class="literal">nil</span> &#123;</span><br><span class="line">            timeout = time.After(time.Duration(r(<span class="number">150</span>, <span class="number">300</span>)) * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> m := &lt;-appendEntries:</span><br><span class="line">            timeout = <span class="literal">nil</span></span><br><span class="line">            fmt.Println(<span class="string">"received a message"</span>)</span><br><span class="line">            <span class="comment">// process(m)</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">            timeout = <span class="literal">nil</span></span><br><span class="line">            fmt.Println(<span class="string">"convert to candidate"</span>)</span><br><span class="line">            <span class="comment">// do something such as election</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">r</span><span class="params">(min, max <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rand.Intn(max-min) + min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Heartbeat&quot;&gt;&lt;a href=&quot;#Heartbeat&quot; class=&quot;headerlink&quot; title=&quot;Heartbeat&quot;&gt;&lt;/a&gt;Heartbeat&lt;/h1&gt;&lt;p&gt;在一个分布式集群中，个别节点出现宕机的情况并不少见，例如在一个只有一个主节点，和多个
      
    
    </summary>
    
    
  </entry>
  
</feed>
