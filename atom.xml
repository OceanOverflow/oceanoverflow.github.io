<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Whyyy</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://oceanoverflow.github.io/"/>
  <updated>2018-05-28T04:01:48.833Z</updated>
  <id>https://oceanoverflow.github.io/</id>
  
  <author>
    <name>Yangyi, Yi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shredder &amp; Gluer</title>
    <link href="https://oceanoverflow.github.io/2018/05/28/Shredder-Gluer/"/>
    <id>https://oceanoverflow.github.io/2018/05/28/Shredder-Gluer/</id>
    <published>2018-05-28T03:38:22.000Z</published>
    <updated>2018-05-28T04:01:48.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shredder-amp-Gluer"><a href="#Shredder-amp-Gluer" class="headerlink" title="Shredder &amp; Gluer"></a>Shredder &amp; Gluer</h1><p>有时候我们需要向服务器上传一个很大的文件，但是无奈网络不稳定，再加上使用的软件不支持断点续传，经常会出现文件上传到一半出错，无奈只能从头再来，可以说是非常烦恼了。还有的时候服务器明确规定了单次上传文件的大小，手头又没有啥好的软件可以帮助我们进行文件的分割和合并操作，只好自己写一个。</p><p>要是一个人被砍了头，手，脚，再把这几个肢体合并起来大概率这人也是废了（在医学水平没有极大进步的情况下），但是对于一个文件来说则不同，无论什么格式的文件，其实本质上都是一大堆字节，如果我们在固定的地方进行切割，最后再在被切割的地方合并的话，这个文件还是可以被正常使用的。</p><h2 id="Get-Basic-Info"><a href="#Get-Basic-Info" class="headerlink" title="Get Basic Info"></a>Get Basic Info</h2><p>在对文件切割之前，我们需要获得文件的基本信息，即文件的大小或者说是字节数，还需要决定切割后每个单位的大小，知道了这两个参数之后，就可以算出所有分割块的数量了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">"some_very_big_file"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">fileInfo, err := f.Stat()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fileSize := fileInfo.Size()</span><br><span class="line">partSize := <span class="number">1</span> &lt;&lt; <span class="number">28</span></span><br><span class="line">concurrency := <span class="keyword">int</span>(fileSize / <span class="keyword">int64</span>(partSize))</span><br><span class="line"><span class="keyword">if</span> remainder := fileSize % <span class="keyword">int64</span>(partSize); remainder != <span class="number">0</span> &#123;</span><br><span class="line">    concurrency++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Shredder"><a href="#Shredder" class="headerlink" title="Shredder"></a>Shredder</h2><p>利用 <code>io.NewSectionReader</code> 可以读取文件特定偏移的数据，然后利用<code>buffo.NewReader</code> 来缓冲读数据，利用 <code>bufio.NewWriter</code> 来缓冲写数据提高效率，最后利用 <code>io.Copy(bw, br)</code> 将文件特定部分复制到新文件中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(concurrency)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; concurrency; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        sr := io.NewSectionReader(f, <span class="keyword">int64</span>(i * partSize), <span class="keyword">int64</span>(partSize))</span><br><span class="line">        br := bufio.NewReader(sr)</span><br><span class="line">        partFile, err := os.Create(<span class="string">"partFile_"</span> + strconv.Itoa(i))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        bw := bufio.NewWriter(partFile)</span><br><span class="line">        io.Copy(bw, br)</span><br><span class="line">    &#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><h2 id="Gluer"><a href="#Gluer" class="headerlink" title="Gluer"></a>Gluer</h2><p>合并与分割互为逆操作，因为我们对上面分割后的文件采取了顺序命名操作，所以可以根据编号的顺序，利用 <code>Seek</code> 方法指定合并文件的写偏移地址，通过 <code>bufio.NewReader</code> 对分割文件进行缓冲读操作，同理利用 <code>bufio.NewWriter</code> 对合并文件进行缓冲写操作，通过 <code>io.Copy(bw, br)</code> 将分割文件放入最终合并文件的正确位置。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">matches, err := filepath.Glob(<span class="string">"partFile_*"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mergedFile, err := os.Create(<span class="string">"mergedFile"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> matches &#123;</span><br><span class="line">    ss := strings.Split(v, <span class="string">"_"</span>)</span><br><span class="line">    i, err := strconv.Atoi(ss[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    mergedFile.Seek(<span class="keyword">int64</span>(i * partSize), os.SEEK_SET)</span><br><span class="line">    f, err := os.Open(v)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    br := bufio.NewReader(f)</span><br><span class="line">    bw := bufio.NewWriter(mergedFile)</span><br><span class="line">    io.Copy(bw, br)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Shredder-amp-Gluer&quot;&gt;&lt;a href=&quot;#Shredder-amp-Gluer&quot; class=&quot;headerlink&quot; title=&quot;Shredder &amp;amp; Gluer&quot;&gt;&lt;/a&gt;Shredder &amp;amp; Gluer&lt;/h1&gt;&lt;p&gt;有时
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TUN/TAP</title>
    <link href="https://oceanoverflow.github.io/2018/05/27/TUNTAP/"/>
    <id>https://oceanoverflow.github.io/2018/05/27/TUNTAP/</id>
    <published>2018-05-27T06:05:03.000Z</published>
    <updated>2018-05-27T06:07:19.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TUNTAP"><a href="#TUNTAP" class="headerlink" title="TUNTAP"></a>TUNTAP</h1><p><a href="http://tuntaposx.sourceforge.net/" target="_blank" rel="noopener">TUN/TAP</a> 为我们在 <code>macOS</code> 下面提供了虚拟网络接口（ <code>TUN/TAP</code> ），其本质是字符设备（ <code>character special file</code> ）。因为在 <code>Unix</code> 中一切皆文件，所以我们可以像操作文件一样操作这两种设备。</p><p><img src="https://1.bp.blogspot.com/-mnxh0kXQeKI/V10lx7q7H4I/AAAAAAAALYs/i427R0SfAQckApSz3piMDu7LiJnPzzu4gCLcB/s1600/tuntap.png" alt="TUNTAP"></p><p><code>TUN</code> 模拟网络层设备，它可以操作第3层数据包例如 <code>IP</code> 数据包。 <code>TAP</code> 模拟链路层设备，用于操作第2层数据包例如以太网帧。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxDevices = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrBusy        = errors.New(<span class="string">"device is already in use"</span>)</span><br><span class="line">  ErrNotReady    = errors.New(<span class="string">"device is not ready"</span>)</span><br><span class="line">  ErrExhausted   = errors.New(<span class="string">"no devices are available"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="keyword">string</span></span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">    io.ReadWriteCloser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tun</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(Interface, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> newTUN(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tap</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(Interface, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> newTAP(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TUN/TAP</code> 在 <code>/dev</code>目录下，以 <code>/dev/tunX</code> 和 <code>/dev/tapX</code> 的形式存在，<code>X</code> 从0到15。每个字符设备都与同名的网络接口关联。网络接口只有在相应的字符设备被程序打开时才会创建，并且在字符设备关闭时将被删除。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> device <span class="keyword">struct</span> &#123;</span><br><span class="line">    n <span class="keyword">string</span></span><br><span class="line">    f *os.File</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> d.n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> d.n &#125;</span><br></pre></td></tr></table></figure><p>新创建设备时，我们像正常打开文件一样使用 <code>TUN</code> 或者 <code>TAP</code> 设备，如果设备已经被占用，则报 <code>ErrBusy</code> 错误。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newDevice</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(Interface, error)</span></span> &#123;</span><br><span class="line">    file, err := os.OpenFile(name, os.O_EXCL|os.O_RWWR, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> isBusy(err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrBusy</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> &amp;device&#123;n: name, f: file&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBusy</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> perr, ok := err.(*os.PathError); ok &#123;</span><br><span class="line">        <span class="keyword">if</span> code, ok := perr.Err.(syscall.Errno); ok &#123;</span><br><span class="line">            <span class="keyword">if</span> code == <span class="number">0x10</span> || code == <span class="number">0x11</span> &#123;</span><br><span class="line">                <span class="comment">// device busy || exclusive lock</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tunX</code> 是 <code>IP</code> 隧道设备，可用于与内核交换 <code>IP</code> 数据包。使用 <code>read()</code> 获取单个数据包，使用 <code>write()</code> 可以将数据包写入 <code>/dev/tunX</code> 设备中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTUN</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(Interface, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := o; i &lt; maxDevices; i++ &#123;</span><br><span class="line">            iface, err := newDevice(<span class="string">"/dev/tun"</span> + strconv.Itoa(i))</span><br><span class="line">            <span class="keyword">if</span> err == ErrBusy &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ErrExhausted</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newDevice(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tapX</code> 是 <code>ethertap</code> 设备，为内核的以太网层提供接口。每次从 <code>/dev/tapX</code> 字符设备中读取或写入一个数据包。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTAP</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(Interface, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := o; i &lt; maxDevices; i++ &#123;</span><br><span class="line">            iface, err := newDevice(<span class="string">"/dev/tap"</span> + strconv.Itoa(i))</span><br><span class="line">            <span class="keyword">if</span> err == ErrBusy &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ErrExhausted</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newDevice(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于字符设备，可以像操作正常文件一样进行读/写操作来向设备写入数据包或者获取数据包。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    n, err := d.f.Read(p)</span><br><span class="line">    <span class="keyword">if</span> isNotReady(err) &#123;</span><br><span class="line">        err = ErrNotReady</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    n, err := d.f.Write(p)</span><br><span class="line">    <span class="keyword">if</span> isNotReady(err) &#123;</span><br><span class="line">        err = ErrNotReady </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isNotReady</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> perr, ok := err.(*os.PathError); ok &#123;</span><br><span class="line">        <span class="keyword">if</span> code, ok := perr.Err.(syscall.Errno); ok &#123;</span><br><span class="line">            <span class="keyword">if</span> code == <span class="number">0x05</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123; </span><br><span class="line">    <span class="keyword">return</span> d.f.Close() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TUNTAP&quot;&gt;&lt;a href=&quot;#TUNTAP&quot; class=&quot;headerlink&quot; title=&quot;TUNTAP&quot;&gt;&lt;/a&gt;TUNTAP&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://tuntaposx.sourceforge.net/&quot; target=&quot;_b
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Try Lock</title>
    <link href="https://oceanoverflow.github.io/2018/05/26/TryLock/"/>
    <id>https://oceanoverflow.github.io/2018/05/26/TryLock/</id>
    <published>2018-05-26T14:05:27.000Z</published>
    <updated>2018-05-26T14:11:36.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Try-Lock"><a href="#Try-Lock" class="headerlink" title="Try Lock"></a>Try Lock</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;...&#125;</span><br><span class="line"><span class="comment">// Lock locks m. </span></span><br><span class="line"><span class="comment">// If the lock is already in use, the calling goroutine</span></span><br><span class="line"><span class="comment">//  blocks until the mutex is available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">// <span class="title">Unlock</span> <span class="title">unlocks</span> <span class="title">m</span>. </span></span><br><span class="line"><span class="function">// <span class="title">It</span> <span class="title">is</span> <span class="title">a</span> <span class="title">run</span>-<span class="title">time</span> <span class="title">error</span> <span class="title">if</span> <span class="title">m</span> <span class="title">is</span> <span class="title">not</span> <span class="title">locked</span> <span class="title">on</span> <span class="title">entry</span> <span class="title">to</span> <span class="title">Unlock</span>. </span></span><br><span class="line"><span class="function">// </span></span><br><span class="line"><span class="function">// <span class="title">A</span> <span class="title">locked</span> <span class="title">Mutex</span> <span class="title">is</span> <span class="title">not</span> <span class="title">associated</span> <span class="title">with</span> <span class="title">a</span> <span class="title">particular</span> <span class="title">goroutine</span>. </span></span><br><span class="line"><span class="function">// <span class="title">It</span> <span class="title">is</span> <span class="title">allowed</span> <span class="title">for</span> <span class="title">one</span> <span class="title">goroutine</span> <span class="title">to</span> <span class="title">lock</span> <span class="title">a</span> <span class="title">Mutex</span> <span class="title">and</span> <span class="title">then</span></span></span><br><span class="line"><span class="function">// <span class="title">arrange</span> <span class="title">for</span> <span class="title">another</span> <span class="title">goroutine</span> <span class="title">to</span> <span class="title">unlock</span> <span class="title">it</span>.</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><code>sync.Mutex</code> 提供了 <code>Lock</code> 和 <code>Unlock</code> 两个方法分别对应上锁和解锁操作，如果锁已经被占据了，<code>Lock</code> 方法会阻塞相应的 <code>goroutine</code> 。在 <code>C</code> 中也有互斥锁的实现，但除了一般的上锁操作和解锁操作，它还多了一种方法 —— <code>pthread_mutex_trylock</code> ，也就是<code>TryLock</code> ， <code>pthread_mutex_trylock</code> 语义与 <code>pthread_mutex_lock</code> 类似，不同的是在锁已经被占据时返回 <code>EBUSY</code> 而不是挂起等待。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// lock a mutex, If the mutex is already locked, </span></span><br><span class="line"><span class="comment">// the calling thread will block until the mutex becomes available.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// unlock a mutex</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// attempt to lock a mutex without blocking</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>下面我们自己来实现一个 <code>golang</code> 版本的 <code>try lock</code> 。实现互斥锁的关键就在于原子操作，保证即使有多个 <code>CPU</code> 存在的情况下，也不能同时执行同一条指令。利用 <code>sync/atomic</code> 库下面的方法可以轻松实现对一个数的原子操作。</p><p>我们实现的互斥锁中有两个东西，首先是一个 <code>v int32</code> ，因为是互斥锁，所以初始化为1，还有一个 <code>ch</code> 通道用于唤醒阻塞等待的 <code>goroutine</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    v <span class="keyword">int32</span></span><br><span class="line">    ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m.v = <span class="number">1</span></span><br><span class="line">    m.ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Lock</code> 方法获取一个锁，如果锁被占据了，则一直阻塞等待( <code>&lt;-m.ch</code> )，等待其他 <code>goroutine</code> 唤醒，相当于 <code>PV</code> 操作中的 <code>P</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;m.v, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> v := atomic.LoadInt32(&amp;m.v); v &gt;= <span class="number">0</span> &amp;&amp; atomic.SwapInt32(&amp;m.v, <span class="number">-1</span>) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        &lt;-m.ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Unlock</code> 方法释放 <code>Mutex</code> ，如果当前有因为等待该锁而被阻塞的<code>goroutine</code> （说明 <code>atomic.SwapInt32(&amp;m.v, 1) != 0</code> ），则执行 <code>m.ch &lt;- struct{}{}</code> 将阻塞的 <code>goroutine</code> 唤醒，对应 <code>PV</code> 操作中的 <code>V</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.SwapInt32(&amp;m.v, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> m.ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>Lock</code> 方法会在锁可用之前阻塞调用该方法的 <code>goroutine</code> ，<code>TryLoad</code> 方法并不会阻塞，通过 <code>atomic.LoadInt32(&amp;m.v)</code> 来查看当前资源是否可用，如果不可用(说明 <code>v &lt;= 0</code> )，则返回 <code>false</code> ，如果 <code>atomic.CompareAndSwapInt32(&amp;m.v, 1, 0)</code> 返回 <code>true</code> ，说明资源可用直接上锁。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">TryLock</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    v := atomic.LoadInt32(&amp;m.v)</span><br><span class="line">    <span class="keyword">if</span> v &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> atomic.CompareAndSwapInt32(&amp;m.v, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Try-Lock&quot;&gt;&lt;a href=&quot;#Try-Lock&quot; class=&quot;headerlink&quot; title=&quot;Try Lock&quot;&gt;&lt;/a&gt;Try Lock&lt;/h1&gt;&lt;figure class=&quot;highlight golang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Concurrent Prime Sieve</title>
    <link href="https://oceanoverflow.github.io/2018/05/25/ConcurrentPrimeSieve/"/>
    <id>https://oceanoverflow.github.io/2018/05/25/ConcurrentPrimeSieve/</id>
    <published>2018-05-25T06:36:04.000Z</published>
    <updated>2018-05-25T10:43:27.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Concurrent-Prime-Sieve"><a href="#Concurrent-Prime-Sieve" class="headerlink" title="Concurrent Prime Sieve"></a>Concurrent Prime Sieve</h1><p>本科刚学编程的时候经常遇到判断一个数是不是素数之类的编程题，当时基础比较差，用的方法也相当简单粗暴，直接采用枚举法判断，虽然简单但是效率很低，时间复杂度为 <code>O(n^2)</code> ，后来慢慢了解了神奇的埃氏筛法，只用 <code>O(nlglgn)</code> 的时间复杂度就可以完成，效率大幅度提高，如果对埃氏筛不了解的童鞋可以看看这篇文章 <a href="http://empslocal.ex.ac.uk/people/staff/mrwatkin/sieve.htm" target="_blank" rel="noopener">sieve of Eratosthenes</a>。</p><p><img src="http://empslocal.ex.ac.uk/people/staff/mrwatkin/bridge1.jpg" alt="Sieve"></p><p>一般的埃氏筛实现都是单线程的，并不能完全发挥现在多核 <code>CPU</code> 的全部性能，下面给出了 <code>Golang</code> 并发版本的埃氏筛实现。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span> ;; i++ &#123;</span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(in, out <span class="keyword">chan</span> <span class="keyword">int</span>, prime <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i := &lt;-in</span><br><span class="line">        <span class="keyword">if</span> i % prime != <span class="number">0</span> &#123;</span><br><span class="line">            out &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> generate(ch)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        prime := &lt;-ch</span><br><span class="line">        fmt.Println(prime)</span><br><span class="line">        out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">        <span class="keyword">go</span> filter(ch, out, prime)</span><br><span class="line">        ch = out</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>并发版本的埃氏筛代码行数虽然不多，然而实现还是比较 <code>tricky</code> 的，谁要是第一遍就看懂算我输（你要是天才的话当我没说过）。</p><p><img src="https://talks.golang.org/2012/concurrency/images/gophereartrumpet.jpg" alt="channel"></p><p>首先要起一个 <code>goroutine</code> ，记为 <code>G</code> ， 用于生成2以后的整数，并放到通道中（记为 <code>out0</code> ）供别的 <code>goroutine</code> 读取。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> generate(ch)          <span class="comment">// ch &lt;- i</span></span><br></pre></td></tr></table></figure><p>进入第一个 <code>for</code> 循环，从上面的通道中取出第一个数2，毫无疑问，2为素数，所以创建一个通道 <code>out1</code> ，并起一个 <code>goroutine</code> ，记为 <code>filter1</code> ，用于过滤所有2的整数倍的数，此时通道数据流的走向为 <code>G -&gt; out1</code> ，只有通过 <code>filter1</code> 筛选的数才有资格进入 <code>out1</code> 中，此时将 <code>ch</code> 设为 <code>out1</code> （ <code>ch</code> 用于记录该链上的最后一个通道），第一个循环结束。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prime := &lt;-ch             <span class="comment">// &lt;-ch</span></span><br><span class="line">fmt.Println(prime)        <span class="comment">// 输出2 </span></span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)     <span class="comment">// 记作out1</span></span><br><span class="line"><span class="keyword">go</span> filter(ch, out, prime) <span class="comment">// ch -&gt; out1</span></span><br><span class="line">ch = out                  <span class="comment">// ch = out1</span></span><br><span class="line">        ^</span><br><span class="line">        |</span><br><span class="line">      +----+ </span><br><span class="line">G ---&gt;|out1|---&gt;</span><br><span class="line">      +----+    </span><br><span class="line">        %<span class="number">2</span></span><br><span class="line">        ^</span><br><span class="line">        |</span><br><span class="line">        ch</span><br></pre></td></tr></table></figure><p>进入第二个 <code>for</code> 循环，因为此时 <code>ch</code> 为 <code>out1</code> ，尝试去 <code>out1</code> 中取，3由 <code>G</code> 产生，然后经过 <code>filter1</code> 后成功进入 <code>out1</code> ，说明3是素数，此时我们再创建一个通道 <code>out2</code> ，并且再起一个 <code>goroutine</code> ，记为 <code>filter2</code> ，该 <code>goroutine</code> 会过滤所有3的整数倍的数，此时通道数据流的走向为 <code>G -&gt; out1 -&gt; out2</code> ，只有成功经过 <code>filter1,filter2</code> 筛选的数才能进入通道 <code>out2</code> 中，将 <code>ch</code> 设为 <code>out2</code> ，第二个循环结束。当<code>G</code> 中产生4，并尝试在这个链上移动时，当它经过 <code>filter1</code> 时，由于4是2的整数倍，说明不是素数，不符合要求，4出局。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prime := &lt;-ch             <span class="comment">// &lt;-out1</span></span><br><span class="line">fmt.Println(prime)        <span class="comment">// 输出3</span></span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)     <span class="comment">// 记作out2</span></span><br><span class="line"><span class="keyword">go</span> filter(ch, out, prime) <span class="comment">// out1 -&gt; out2</span></span><br><span class="line">ch = out                  <span class="comment">// ch = out2</span></span><br><span class="line"></span><br><span class="line">        ^         ^</span><br><span class="line">        |         |</span><br><span class="line">      +----+    +----+    </span><br><span class="line">G ---&gt;|out1|---&gt;|out2|---&gt;</span><br><span class="line">      +----+    +----+ </span><br><span class="line">        %<span class="number">2</span>        %<span class="number">3</span></span><br><span class="line">                   ^</span><br><span class="line">                   |</span><br><span class="line">                   ch</span><br></pre></td></tr></table></figure><p>进入第三个 <code>for</code> 循环，同样的，此时 <code>ch</code> 为 <code>out2</code> ，尝试去 <code>out2</code> 中取，5由 <code>G</code> 产生，经过 <code>filter1,filter2</code> 后成功进入 <code>out2</code> ，说明5为素数，此时我们再创建一个通道 <code>out3</code> ，并且再起一个 <code>goroutine</code> ，记为 <code>filter3</code> ，该 <code>goroutine</code> 会过滤所有5的整数倍的数，此时通道数据流的走向为 <code>G -&gt; out1 -&gt; out2 -&gt; out3</code> ，只有成功经过 <code>filter1,filter2,filter3</code> 筛选的数才能进入通道 <code>out3</code> 中，将 <code>ch</code> 设为 <code>out3</code> ，第三个循环结束。当 <code>G</code> 中产生6，并尝试在这个链上移动时，经过 <code>filter1</code> 时，由于6是2的整数倍，说明不是素数，不符合要求，同样出局。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prime := &lt;-ch             <span class="comment">// &lt;-out2</span></span><br><span class="line">fmt.Println(prime)        <span class="comment">// 输出5</span></span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)     <span class="comment">// 记作out3</span></span><br><span class="line"><span class="keyword">go</span> filter(ch, out, prime) <span class="comment">// out2 -&gt; out3</span></span><br><span class="line">ch = out                  <span class="comment">// ch=out3</span></span><br><span class="line"></span><br><span class="line">        ^         ^         ^</span><br><span class="line">        |         |         |</span><br><span class="line">      +----+    +----+    +----+    </span><br><span class="line">G ---&gt;|out1|---&gt;|out2|---&gt;|out3|---&gt;</span><br><span class="line">      +----+    +----+    +----+</span><br><span class="line">        %<span class="number">2</span>        %<span class="number">3</span>        %<span class="number">5</span>        </span><br><span class="line">                            ^</span><br><span class="line">                            |</span><br><span class="line">                            ch</span><br></pre></td></tr></table></figure><p>进入第四个 <code>for</code> 循环，此时 <code>ch</code> 为 <code>out3</code> ，尝试去 <code>out3</code> 中取，7由 <code>G</code> 产生，然后经过 <code>filter1,filter2,filter3</code> 筛选后成功进入 <code>out3</code> ，说明7是素数，此时我们再创建一个通道 <code>out4</code> ，并且再起一个 <code>goroutine</code> ，记为 <code>filter4</code> ，该 <code>goroutine</code> 会过滤所有7的整数倍的数，此时通道数据流的走向为 <code>G -&gt; out1 -&gt; out2 -&gt; out3 -&gt; out4</code> ，只有成功经过 <code>filter1,filter2,filter2,filter4</code> 筛选的数才能进入通道 <code>out4</code> 中，将 <code>ch</code> 设为 <code>out4</code> ，第四个循环结束。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prime := &lt;-ch             <span class="comment">// &lt;-out3</span></span><br><span class="line">fmt.Println(prime)        <span class="comment">// 输出7</span></span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)     <span class="comment">// 记作out4</span></span><br><span class="line"><span class="keyword">go</span> filter(ch, out, prime) <span class="comment">// out3 -&gt; out4</span></span><br><span class="line">ch = out                  <span class="comment">// ch=out4</span></span><br><span class="line"></span><br><span class="line">        ^         ^         ^         ^</span><br><span class="line">        |         |         |         |</span><br><span class="line">      +----+    +----+    +----+    +----+</span><br><span class="line">G ---&gt;|out1|---&gt;|out2|---&gt;|out3|---&gt;|out4|---&gt;</span><br><span class="line">      +----+    +----+    +----+    +----+</span><br><span class="line">        %<span class="number">2</span>        %<span class="number">3</span>        %<span class="number">5</span>        %<span class="number">7</span>            </span><br><span class="line">                                      ^</span><br><span class="line">                                      |</span><br><span class="line">                                      ch</span><br></pre></td></tr></table></figure><p>以此类推，并发版本素数筛的本质就是构建 <code>DaisyChain</code> ，每个数经过 <code>DaisyChain</code> 层层筛选后，如果最终保留，说明该数为素数，作为 <code>DaisyChain</code> 的最后一层加入，如此往复，就可以达到快速筛选素数的目的了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Concurrent-Prime-Sieve&quot;&gt;&lt;a href=&quot;#Concurrent-Prime-Sieve&quot; class=&quot;headerlink&quot; title=&quot;Concurrent Prime Sieve&quot;&gt;&lt;/a&gt;Concurrent Prime Sie
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Single Flight</title>
    <link href="https://oceanoverflow.github.io/2018/05/24/SingleFlight/"/>
    <id>https://oceanoverflow.github.io/2018/05/24/SingleFlight/</id>
    <published>2018-05-24T05:46:36.000Z</published>
    <updated>2018-05-24T06:06:47.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Single-Flight"><a href="#Single-Flight" class="headerlink" title="Single Flight"></a>Single Flight</h1><h2 id="SingleFlight"><a href="#SingleFlight" class="headerlink" title="SingleFlight"></a>SingleFlight</h2><p>很多人闲来无事就喜欢刷票圈逛微博，所有的消息看完一遍之后，就开启疯狂下拉刷新模式，希望能第一时间看到什么劲爆的消息。对于应用的使用者，这倒没什么，但是如果连续多次下拉刷新操作都分别对应一次服务器请求的话，那么服务器估计就得扑街了，所以我们需要限制在一定时间内同一个请求的数量，以避免无用的请求。</p><p>我们需要实现一种机制，对于特定的请求，在该请求触发之后但还没有返回结果之前，对于之后所有相同的请求，无论多少个，都不会真正触发，而是等待第一个请求返回，然后共用一个结果。</p><p><code>SingleFlight</code> 就可以帮助我们实现上述的要求，我们使用结构体 <code>call</code> 来表示特定请求返回的结果，在 <code>SingleFlight</code> 结构体中使用一个 <code>map</code> 来存储不同的请求结果，也就是一个请求对应一个<code>call</code>，并用锁保护 <code>map</code> 的读写。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SingleFlight <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="keyword">string</span>]*call</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">    wg  sync.WaitGroup</span><br><span class="line">    val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    err error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说，<code>call</code> 是一些所需时间长，消耗资源多的操作的返回结果（例如<code>HTTP</code> 请求）。<code>Do</code> 方法就保证对于同一个请求，在结果未返回之前，后面相同的请求都不会真正进行，而是等待第一个请求的结果。在函数运行时需要检测当前 <code>map</code> 是否为空，如果为空则 <code>make</code> 一个，然后检查是否有相同的请求正在进行，如果有则使用 <code>c.wg.Wait</code> 来等待执行结果。要是这个请求是该时间段内第一个请求，则将它加入 <code>map</code> 中，然后通过 <code>c.wg.Add</code> 来增加 <code>WaitGroup</code> 应该等待的 <code>goroutine</code> 个数，当函数执行完成之后，通过 <code>c.wg.Done</code> 来广播告知他人，此时任何调用<code>c.wg.Wait</code> 的地方都会解除阻塞，并返回该结果。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sf *SingleFlight)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    sf.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sf.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        sf.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> c, ok := sf.m[key]; ok &#123;</span><br><span class="line">        sf.Unlock()</span><br><span class="line">        c.wg.Wait()</span><br><span class="line">        <span class="keyword">return</span> c.val, c.err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">new</span>(call)</span><br><span class="line">    c.wg.Add(<span class="number">1</span>)</span><br><span class="line">    sf.m[key] = c</span><br><span class="line">    sf.Unlock()</span><br><span class="line"></span><br><span class="line">    c.val, c.err = fn()</span><br><span class="line">    c.wg.Done()</span><br><span class="line">    </span><br><span class="line">    sf.Lock()</span><br><span class="line">    <span class="built_in">delete</span>(sf.m, key)</span><br><span class="line">    sf.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c.val, c.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p><code>SingleFlight</code> 机制主要是靠 <code>WaitGroup</code> 实现，一般来说，因为<code>main routine</code> 不会等待 <code>goroutine</code> 执行完成，所以需要某种机制等待所有的<code>goroutine</code> 执行完成，使用 <code>WaitGroup</code> 就可以帮助我们达到这样的目的。</p><p><code>WaitGroup</code> 的本质就是一个计数器，当每起一个新的 <code>goroutine</code> 时，我们调用 <code>wg.Add(1)</code> 来增加计数器的数量，当该 <code>goroutine</code> 执行完毕时，利用 <code>wg.Done()</code> 可以将计数器减一，调用 <code>Wait()</code> 方法的地方会一直阻塞 <code>main routine</code> ，只有当计数器为0时，<code>wg</code> 才会解除阻塞，此时程序才可以继续执行下去。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</span></span><br><span class="line">    <span class="comment">// 64-bit atomic operations require 64-bit alignment, but 32-bit</span></span><br><span class="line">    <span class="comment">// compilers do not ensure it. So we allocate 12 bytes and then use</span></span><br><span class="line">    <span class="comment">// the aligned 8 bytes in them as state.</span></span><br><span class="line">    state1 [<span class="number">12</span>]<span class="keyword">byte</span></span><br><span class="line">    sema   <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> urls = []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"http://www.golang.org/"</span>,</span><br><span class="line">    <span class="string">"http://www.google.com/"</span>,</span><br><span class="line">    <span class="string">"http://www.somestupidname.com/"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">    <span class="comment">// Increment the WaitGroup counter.</span></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// Launch a goroutine to fetch the URL.</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Decrement the counter when the goroutine completes</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done() </span><br><span class="line">    <span class="comment">// Fetch the URL.</span></span><br><span class="line">    http.Get(url)</span><br><span class="line">    &#125;(url)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Wait for all HTTP fetches to complete.</span></span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Single-Flight&quot;&gt;&lt;a href=&quot;#Single-Flight&quot; class=&quot;headerlink&quot; title=&quot;Single Flight&quot;&gt;&lt;/a&gt;Single Flight&lt;/h1&gt;&lt;h2 id=&quot;SingleFlight&quot;&gt;&lt;a href
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LRU</title>
    <link href="https://oceanoverflow.github.io/2018/05/24/LRU/"/>
    <id>https://oceanoverflow.github.io/2018/05/24/LRU/</id>
    <published>2018-05-23T16:23:40.000Z</published>
    <updated>2018-05-23T16:29:58.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Least-Recently-Used"><a href="#Least-Recently-Used" class="headerlink" title="Least Recently Used"></a>Least Recently Used</h1><p>最近最少使用（ <code>Least Recently Used</code> ）也就是 <code>LRU</code> 算法是内存页面置换算法的一种，使用该算法可以在有限的资源内提高内存访问的速度，它利用了著名的局部性原理，更具体的说是时间局部性，也就是说如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</p><p>例如我们有3个物理块，访问序列为 <code>7，0，1，2，0，3，0</code></p><ul><li>访问7时，LRU缺失，此时LRU未满，放入7，此时淘汰顺序为7</li><li>访问0时，LRU缺失，此时LRU未满，放入0，此时淘汰顺序为7，0</li><li>访问1时，LRU缺失，此时LRU未满，放入1，此时淘汰顺序为7，0 ，1</li><li>访问2时，LRU缺失，此时LRU已满，驱逐7，放入2，此时淘汰顺序为0，1，2</li><li>访问0时，LRU命中，更新淘汰顺序，此时淘汰循序为1，2，0</li><li>访问3时，LRU缺失，此时LRU已满，驱逐1，放入3，此时淘汰顺序为2，0，3</li><li>访问0时，LRU命中，更新淘汰顺序，此时淘汰顺序为0，3，2</li></ul><p><img src="https://i.ytimg.com/vi/4wVp97-uqr0/maxresdefault.jpg" alt="LRU"></p><p>我们利用链表（ <code>*list.List</code> ）维护其淘汰顺序，利用 <code>map</code> 作为其存储引擎（作为物质基础）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;---------------------------------------------------------&gt;</span><br><span class="line">newest                                               oldest</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Key <span class="keyword">interface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    key Key</span><br><span class="line">    value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">    MaxEntries <span class="keyword">int</span></span><br><span class="line">    OnEvicted  <span class="function"><span class="keyword">func</span><span class="params">(key Key, value <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">ll</span>         *<span class="title">list</span>.<span class="title">List</span></span></span><br><span class="line"><span class="function">    <span class="title">cache</span>      <span class="title">map</span>[<span class="title">interface</span></span>&#123;&#125;]*list.Element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(maxEntries <span class="keyword">int</span>)</span> *<span class="title">Cache</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Cache&#123;</span><br><span class="line">        MaxEntries: maxEntries,</span><br><span class="line">        ll:         list.New(),</span><br><span class="line">        cache:      <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*list.Element),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们经常需要判断当前的 <code>LRU</code> 缓存是否存满，所以我们构造一个<code>helper function</code> 来获取当前缓存的容量。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.cache == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c.ll.Len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>淘汰顺序在两种情况下会更新，一是新增元素时，如果元素在 <code>LRU</code> 缓存中不存在，则将它放在链表的头部（ <code>PushFront</code> ），如果存在，则直接将其移到链表的头部（ <code>MoveToFront</code> ）。二是在获取元素时，如果元素存在，则直接将其移到链表的头部（ <code>MoveToFront</code> ）。这样一来我们就能确保最新的东西在链表头，最老的东西在链表尾。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Add</span><span class="params">(key Key, value interfacfe&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.cache == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.cache = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;*list.Element])</span><br><span class="line">        c.ll = list.New()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ee, ok := c.cache[key]; ok &#123;</span><br><span class="line">        c.ll.MoveToFront(ee)</span><br><span class="line">        ee.Value.(*entry).value = value</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ele := c.ll.PushFront(&amp;entry&#123;key, value&#125;)</span><br><span class="line">    c.cache[key] = ele</span><br><span class="line">    <span class="keyword">if</span> c.MaxEntries != <span class="number">0</span> &amp;&amp; c.ll.Len() &gt; c.MaxEntries &#123;</span><br><span class="line">        c.RemoveOldest()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Get</span><span class="params">(key Key)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.cache == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ele, hit := c.cache[key]; hit &#123;</span><br><span class="line">        c.ll.MoveToFront(ele)</span><br><span class="line">        <span class="keyword">return</span> ele.Value.(*entry).value, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RemoveOldest</code> 将最老的元素淘汰，也就是说将链表中最后一项移除，并将<code>map</code> 中对应的元素删除。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">RemoveOldest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.cache == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ele := c.ll.Back()</span><br><span class="line">    <span class="keyword">if</span> ele != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.removeElement(ele)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">removeElement</span><span class="params">(e *list.Element)</span></span> &#123;</span><br><span class="line">    c.ll.Remove(e)</span><br><span class="line">    kv := e.Value.(*entry)</span><br><span class="line">    <span class="built_in">delete</span>(c.cache, kv.key)</span><br><span class="line">    <span class="keyword">if</span> c.OnEvicted != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.OnEvicted(kv.key, kv.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清除 <code>LRU</code> 缓存只需要将链表和 <code>map</code> 设为 <code>nil</code> 就可以了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.OnEvicted != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, e := <span class="keyword">range</span> c.cache &#123;</span><br><span class="line">            kv := e.Value.(*entry)</span><br><span class="line">            c.OnEvicted(kv.key, kv.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.ll = <span class="literal">nil</span></span><br><span class="line">    c.cache = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Least-Recently-Used&quot;&gt;&lt;a href=&quot;#Least-Recently-Used&quot; class=&quot;headerlink&quot; title=&quot;Least Recently Used&quot;&gt;&lt;/a&gt;Least Recently Used&lt;/h1&gt;&lt;p&gt;最近
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Heartbeat</title>
    <link href="https://oceanoverflow.github.io/2018/05/23/Heartbeat/"/>
    <id>https://oceanoverflow.github.io/2018/05/23/Heartbeat/</id>
    <published>2018-05-23T09:52:18.000Z</published>
    <updated>2018-05-23T09:55:09.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Heartbeat"><a href="#Heartbeat" class="headerlink" title="Heartbeat"></a>Heartbeat</h1><p>在一个分布式集群中，个别节点出现宕机的情况并不少见，例如在一个只有一个主节点，和多个从节点的集群中，从节点发生宕机对整个系统影响倒不算太大，如果主节点宕机，系统将不能正常运行，所以必须有一个机制检测各个节点是否正常运行。</p><p>心跳机制是设计高可用性分布式系统的重要技术。心跳机制通过周期性地向其他节点发送心跳消息并等待确认来检测集群中的节点状态。当节点状态发生变化时，会通知发送心跳检测消息的节点。如果发送心跳检测消息的节点在一段时间内未收到确认，则该节点将被视为失败。这是心跳机制的基本原理。</p><p>在设计心跳时，需要考虑心跳是单向，还是双向的，单向的心跳可以保证当发送方出现问题时，接收方在一定的时间内可以检测到，而双向则可以保证双方都可以检测到对方是否出现问题。</p><p>下面我们来实现一个单向的心跳检测机制，这里存在一个主节点和多个从节点，主节点会向连接到自己的从节点定期发送心跳消息，如果从节点在规定时间内没有收到来自主节点的心跳消息，则认为主节点发生异常，然后进行相应的超时处理流程（如自己参与选举成为主节点等）。</p><h2 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h2><p>在主节点中我们维护连接到主节点的从节点的信息，使用用一个数组保存，当节点加入或者退出系统时候，分别调用 <code>Add</code> 和 <code>Del</code> 方法进行增删。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Master <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    n      <span class="keyword">int</span></span><br><span class="line">    slaves []*Slave</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">Add</span><span class="params">(s *Slave)</span></span> &#123;</span><br><span class="line">    s.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.Unlock()</span><br><span class="line">    s.n++</span><br><span class="line">    s.slaves = <span class="built_in">append</span>(s.slaves, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">Del</span><span class="params">(s *Slave)</span></span> &#123;</span><br><span class="line">    s.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.Unlock()</span><br><span class="line">    n := <span class="built_in">make</span>([]*Slave, <span class="built_in">len</span>(s.slaves)<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> m.slaves &#123;</span><br><span class="line">        <span class="keyword">if</span> x != s &#123;</span><br><span class="line">            n = <span class="built_in">append</span>(n, x)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    s.n--</span><br><span class="line">    s.slaves = n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦从节点与主节点建立连接，主节点会通过 <code>heartbeatLoop</code> 向从节点定时发送心跳消息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    s := &amp;slave&#123;</span><br><span class="line">        conn: conn,</span><br><span class="line">        connectTime: time.Now()</span><br><span class="line">    &#125;</span><br><span class="line">    m.Add(s)</span><br><span class="line">    log.Println(<span class="string">"Connected: "</span>, conn.RemoteAddr)</span><br><span class="line">    <span class="keyword">go</span> s.heartbeatLoop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Slave"><a href="#Slave" class="headerlink" title="Slave"></a>Slave</h2><p><code>slave</code> 是主节点维护的从节点的信息，<code>connectTime</code> 表示从节点第一次连接的时间，<code>exit chan struct{}</code> 用于接收退出信号，例如当从节点退出该集群时或者从节点发生宕机时，通过该机制停止向从节点发送心跳信息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slave <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    conn        net.Conn</span><br><span class="line">    connectTime time.Time</span><br><span class="line">    exit        <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>hearbeatLoop</code> 方法中，通过 <code>time.NewTicker</code> 来设置一个定时器，每隔一秒钟向从节点发送心跳消息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *slave)</span> <span class="title">heartbeatLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.conn.Close()</span><br><span class="line">        ticker.Stop()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> t := &lt;-ticker.C:</span><br><span class="line">            s.Lock()</span><br><span class="line">            c.conn.Write([]<span class="keyword">byte</span>(fmt.Sprintf(<span class="string">"heartbeat %d"</span>, time.Now())))</span><br><span class="line">            s.Unlock()</span><br><span class="line">        <span class="keyword">case</span> &lt;-s.exit:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *slave)</span> <span class="title">stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.exit &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Main-Routine"><a href="#Main-Routine" class="headerlink" title="Main Routine"></a>Main Routine</h2><h2 id="master-main"><a href="#master-main" class="headerlink" title="master main"></a>master main</h2><p>主节点通过监听相应的端口，处理与自己连接的请求，对于每个连接请求，都会起一个新的 <code>goroutine</code> 分别处理。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":8080"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> l.Close()</span><br><span class="line">    m := &amp;Master&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> m.handleConnection(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="slave-main"><a href="#slave-main" class="headerlink" title="slave main"></a>slave main</h2><p>从节点会接收来自主节点的心跳消息，并通过 <code>time.NewTimer</code> 来设置一个定时器，如果在规定的时间内没有收到来自主节点的消息，则说明心跳超时，怀疑主节点出现异常，如果在规定的时间内收到心跳消息，则通过<code>timer.Reset</code> 来重置定时器。一般来说，心跳超时的时间是心跳发送周期的3倍左右。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:8080"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timer := time.NewTimer(<span class="number">3</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    msgChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100</span>)</span><br><span class="line">            n, err := conn.Read(b)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(err)</span><br><span class="line">            &#125;</span><br><span class="line">            msgChan &lt;- <span class="keyword">string</span>(b[:n])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(conn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> m := &lt;-msgChan:</span><br><span class="line">            fmt.Println(m)</span><br><span class="line">        <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">            fmt.Println(<span class="string">"Timed out"</span>)</span><br><span class="line">            <span class="comment">// do something here</span></span><br><span class="line">            &lt;-msgChan</span><br><span class="line">        &#125;</span><br><span class="line">        timer.Reset(<span class="number">3</span> * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Heartbeat&quot;&gt;&lt;a href=&quot;#Heartbeat&quot; class=&quot;headerlink&quot; title=&quot;Heartbeat&quot;&gt;&lt;/a&gt;Heartbeat&lt;/h1&gt;&lt;p&gt;在一个分布式集群中，个别节点出现宕机的情况并不少见，例如在一个只有一个主节点，和多个
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Bitwise Operation</title>
    <link href="https://oceanoverflow.github.io/2018/05/22/BitwiseOperation/"/>
    <id>https://oceanoverflow.github.io/2018/05/22/BitwiseOperation/</id>
    <published>2018-05-22T11:28:38.000Z</published>
    <updated>2018-05-22T11:41:26.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bitwise-Operation"><a href="#Bitwise-Operation" class="headerlink" title="Bitwise Operation"></a>Bitwise Operation</h1><p>在计算机刚出现时的远古年代（其实也就几十年）， CPU ，内存和网络带宽都是非常珍贵的资源，在处理或者发送数据时，为了尽可能地节约资源，程序员都需要尽可能控制数据的大小，例如布尔值能用一个比特表示就绝不使用一个字节。</p><p>一般网络协议的头部通过指定特定比特来表示特定的意思，还有在很多 <code>low-level</code> 的系统编程中，位运算也非常常见。所以，位运算可以说是程序员的必备技能了，下面让我们来看几种基本的位运算吧。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> op <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BitwiseOperation <span class="keyword">interface</span> &#123;</span><br><span class="line">    AND(<span class="keyword">byte</span>, <span class="keyword">byte</span>) <span class="keyword">byte</span></span><br><span class="line">    ANDNOT(<span class="keyword">byte</span>, <span class="keyword">byte</span>) <span class="keyword">byte</span></span><br><span class="line">    OR(<span class="keyword">byte</span>, <span class="keyword">byte</span>) <span class="keyword">byte</span></span><br><span class="line">    XOR(<span class="keyword">byte</span>. <span class="keyword">byte</span>) <span class="keyword">byte</span> </span><br><span class="line">    NOT(<span class="keyword">byte</span>) <span class="keyword">byte</span>  </span><br><span class="line">    SHIFT_LEFT(<span class="keyword">byte</span>, <span class="keyword">uint</span>) <span class="keyword">byte</span></span><br><span class="line">    SHIFT_RIGHT(<span class="keyword">byte</span>, <span class="keyword">uint</span>) <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="amp-AND"><a href="#amp-AND" class="headerlink" title="&amp; (AND)"></a>&amp; (AND)</h2><p><code>AND</code> 运算符可以有选择性地将数的某位清零，除此之外，还可以检测数的奇偶性（1 &amp; a == 1）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0xAC // 10101100</span><br><span class="line">&amp; 0xF0 // 11110000</span><br><span class="line">= 0xA0 // 10100000</span><br><span class="line">          ^ ^</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (op *bitwiseOp) AND(x byte, y byte) byte &#123;</span><br><span class="line">    return x &amp; y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="amp-AND-NOT"><a href="#amp-AND-NOT" class="headerlink" title="&amp;^ (AND NOT)"></a>&amp;^ (AND NOT)</h2><p>与 <code>AND</code> 类似，<code>AND NOT</code> 也可以将特定的位清0，但是 <code>AND NOT</code> 的语义更加符合正常思维，写起来也更加直观。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   0xAB // 10101011</span><br><span class="line">&amp;^ 0x03 // 00000011</span><br><span class="line">=  0xA8 // 10101000</span><br><span class="line">           ^ ^ ^</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *op)</span> <span class="title">ANDNOT</span><span class="params">(x <span class="keyword">byte</span>, y <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp;^ y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OR"><a href="#OR" class="headerlink" title="| (OR)"></a>| (OR)</h2><p><code>OR</code> 操作可以有选择性地将一个字节的某几个比特设为1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0x00 // 00000000</span><br><span class="line">| 0xC4 // 11000100</span><br><span class="line">= 0xC4 // 11000100</span><br><span class="line">          ^^   ^</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *op)</span> <span class="title">OR</span><span class="params">(x <span class="keyword">byte</span>, y <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x | y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（XOR-NOT）"><a href="#（XOR-NOT）" class="headerlink" title="^ （XOR | NOT）"></a>^ （XOR | NOT）</h2><h3 id="Binary-XOR"><a href="#Binary-XOR" class="headerlink" title="Binary ^ (XOR)"></a>Binary ^ (XOR)</h3><p>使用 <code>XOR</code> 可以将位从一个值切换到另一个（toggle），除此之外，<code>XOR</code> 还可以用于比较两个数的符号是否相同。当 <code>(a ^ b) ≥ 0</code> 时，表示两个整数a，b具有相同的符号（或当 <code>(a ^ b) &lt; 0</code> 时表示符号相反）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0xCEFF // 1100111011111111</span><br><span class="line">^ 0xFF00 // 1111111100000000</span><br><span class="line">= 0x31FF // 0011000111111111</span><br><span class="line">              ^^   ^^^^^^^^^</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *op)</span> <span class="title">XOR</span><span class="params">(x <span class="keyword">byte</span>, y <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x ^ y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Unary-NOT"><a href="#Unary-NOT" class="headerlink" title="Unary ^ (NOT)"></a>Unary ^ (NOT)</h3><p>与其他语言（c / c ++，Java，Python，Javascript等）不同，Go没有专门的取反位运算符，但它可以用 <code>^</code> 来表示 <code>NOT</code>， 也就是按位取反。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^ 0x0F // 00001111</span><br><span class="line">= 0xF0 // 11110000</span><br><span class="line">          ^^^^</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *op)</span> <span class="title">NOT</span><span class="params">(x <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ^x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SHIFT"><a href="#SHIFT" class="headerlink" title="SHIFT"></a>SHIFT</h2><p><code>Shift</code> 操作可以和 <code>&amp;</code>  <code>|</code>  <code>&amp;^</code> 这三个操作符组合起来使用。</p><ul><li><code>a | ( 1&lt;&lt; 2)</code></li></ul><p><code>|</code> 与 <code>&lt;&lt;</code> 运算符组合可以用于设置a中的第n位。</p><ul><li><code>a &amp; (1 &lt;&lt; 2)</code></li></ul><p>或者将 <code>＆</code> 和 <code>&lt;&lt;</code> 运算符组合来测试第n位是否被设置。</p><ul><li><code>a &amp;^ (1 &lt;&lt; 2)</code></li></ul><p>使用 <code>＆^</code> 和 <code>&lt;&lt;</code>，我们可以取消设置值的第n位。</p><p>使用左右移位运算符还可以完成效率更高的乘法和除法。</p><h3 id="gt-gt-Shift-Right"><a href="#gt-gt-Shift-Right" class="headerlink" title="&gt;&gt; (Shift Right)"></a>&gt;&gt; (Shift Right)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     0x78 // 01111000</span><br><span class="line">              ^^^^</span><br><span class="line">&gt;&gt; 1 0x3C // 00111100  </span><br><span class="line">               ^^^^</span><br><span class="line">&gt;&gt; 2 0x1E // 00011110</span><br><span class="line">                ^^^^</span><br><span class="line">&gt;&gt; 3 0x0F // 00001111</span><br><span class="line">                 ^^^^</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *op)</span> <span class="title">SHIFT_RIGHT</span><span class="params">(x <span class="keyword">byte</span>, n <span class="keyword">uint</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;&gt; n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lt-lt-Shift-Left"><a href="#lt-lt-Shift-Left" class="headerlink" title="&lt;&lt; (Shift Left)"></a>&lt;&lt; (Shift Left)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     0x03 // 00000011</span><br><span class="line">                   ^^</span><br><span class="line">&lt;&lt; 1 0x60 // 00000110</span><br><span class="line">                  ^^</span><br><span class="line">&lt;&lt; 2 0xC0 // 00001100</span><br><span class="line">                 ^^</span><br><span class="line">&lt;&lt; 3 0x18 // 00011000</span><br><span class="line">                ^^</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *op)</span> <span class="title">SHIFT_LEFT</span><span class="params">(x <span class="keyword">byte</span>, n <span class="keyword">uint</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Bitwise-Operation&quot;&gt;&lt;a href=&quot;#Bitwise-Operation&quot; class=&quot;headerlink&quot; title=&quot;Bitwise Operation&quot;&gt;&lt;/a&gt;Bitwise Operation&lt;/h1&gt;&lt;p&gt;在计算机刚出现时的远
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GUID</title>
    <link href="https://oceanoverflow.github.io/2018/05/22/GUID/"/>
    <id>https://oceanoverflow.github.io/2018/05/22/GUID/</id>
    <published>2018-05-22T03:49:08.000Z</published>
    <updated>2018-05-22T03:51:22.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GUID"><a href="#GUID" class="headerlink" title="GUID"></a>GUID</h1><p>在点外卖或者网上购物的时候，每个订单中都会有一串独一无二的数字，但是处理订单的服务器肯定不止一台，如何保证多台服务器，也就是说一个计算机集群中，在相互独立的情况下（不沟通自己生成的订单号的信息）不生成相同的订单号码呢，下面我们就来介绍一种全球唯一标识符（ <code>GUID</code> ）的生成算法。</p><p>这里我们的 <code>GUID</code> 共64比特。<code>sequence</code> 部分占12比特，<code>nodeID</code> 占10比特，偏移10比特，时间戳 <code>timestamp</code> 占剩余的42比特，偏移22比特。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------------------+----------+------------+</span><br><span class="line">|                timestamp                  |nodeIDBits|sequenceBits|</span><br><span class="line">+-------------------------------------------+----------+------------+</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    nodeIDBits = <span class="keyword">uint64</span>(<span class="number">10</span>)</span><br><span class="line">    sequenceBits = <span class="keyword">uint64</span>(<span class="number">12</span>)</span><br><span class="line">    nodeIDShift = sequenceBits</span><br><span class="line">    timestampShift = sequenceBits + nodeIDBits</span><br><span class="line">    sequenceMask   = <span class="keyword">int64</span>(<span class="number">-1</span>) ^ (<span class="keyword">int64</span>(<span class="number">-1</span>) &lt;&lt; sequenceBits)</span><br><span class="line"></span><br><span class="line">    twepoch = <span class="keyword">int64</span>(<span class="number">1288834974288</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrIDBackwards = errors.New(<span class="string">"ID went backward"</span>)</span><br><span class="line">    ErrTimeBackwards = errors.New(<span class="string">"time has gone backwards"</span>)</span><br><span class="line">    ErrSequenceExpired = errors.New(<span class="string">"sequence expired"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>下面我们定义一个生成 <code>guid</code> 的工厂， <code>guid</code> 由 <code>timestamp</code>  ，<code>nodeID</code> 和 <code>sequence</code> 这三个部分构成，每个工厂有自己的 <code>nodeID</code>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> guid <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> guidFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Metex</span><br><span class="line">    nodeID        <span class="keyword">int64</span></span><br><span class="line">    sequence      <span class="keyword">int64</span></span><br><span class="line">    lastTimestamp <span class="keyword">int64</span></span><br><span class="line">    lastID        guid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGUIDFactory</span><span class="params">(nodeID <span class="keyword">int64</span>)</span> *<span class="title">guidFactory</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;guidFactory&#123;</span><br><span class="line">        nodeID: nodeID,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在利用工厂模式生成 <code>GUID</code> 时，首先计算当前时间戳，并且除以1048576（2的20次方），这样是为了去除时间的假随机部分，如果新生成的<code>timestamp</code> 小于 <code>lastTimestamp</code> ，则返回 <code>ErrTimeBackwards</code> 错误，对于相同的时间戳，我们的 <code>sequence</code> 采取递增策略，如果 <code>sequence</code> 达到最大值后归0，则返回 <code>ErrSequenceExpired</code> 错误，如果时间戳不相同，则令 <code>sequence</code> 重新从0开始，最后使三部分拼接组成一个新的 <code>guid</code> ，如果生成的 <code>guid</code> 小于 <code>lastID</code> ，则返回 <code>ErrIDBackwards</code> 错误，如果正常则返回结果。整个计算的过程需要由锁来保护。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *guidFactory)</span> <span class="title">Create</span><span class="params">()</span> <span class="params">(guid, error)</span></span> &#123;</span><br><span class="line">    f.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// divide by 1048576, giving pseudo-milliseconds</span></span><br><span class="line">    ts := time.Now().UnixNano() &gt;&gt; <span class="number">20</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ts &lt; f.lastTimestamp &#123;</span><br><span class="line">        f.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, ErrTimeBackwards</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> f.lastTimestamp == ts &#123;</span><br><span class="line">        f.sequence = (f.sequence + <span class="number">1</span>) &amp; sequenceMask</span><br><span class="line">        <span class="keyword">if</span> f.sequence == <span class="number">0</span> &#123;</span><br><span class="line">            f.Unlock()</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, ErrSequenceExpired</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        f.sequence = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f.lastTimestamp = ts</span><br><span class="line"></span><br><span class="line">    id := guid(((ts - twepoch) &lt;&lt; timestampShift) |</span><br><span class="line">        (f.nodeID &lt;&lt; nodeIDShift) |</span><br><span class="line">        f.sequence)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> id &lt;= f.lastID &#123;</span><br><span class="line">        f.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, ErrIDBackwards</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f.lastID = id</span><br><span class="line"></span><br><span class="line">    f.Unlock()</span><br><span class="line"></span><br><span class="line">    return id, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便结果的表示，我们会将10进制转换为16进制，利用标准库中的 <code>hex</code> 就可以轻松实现了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g guid)</span> <span class="title">Hex</span><span class="params">()</span> <span class="title">MessageID</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> h MessageID</span><br><span class="line">    <span class="keyword">var</span> b [<span class="number">8</span>]<span class="keyword">byte</span></span><br><span class="line">    </span><br><span class="line">    b[<span class="number">0</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">56</span>)</span><br><span class="line">    b[<span class="number">1</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">48</span>)</span><br><span class="line">    b[<span class="number">2</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">40</span>)</span><br><span class="line">    b[<span class="number">3</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">32</span>)</span><br><span class="line">    b[<span class="number">4</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">24</span>)</span><br><span class="line">    b[<span class="number">5</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">16</span>)</span><br><span class="line">    b[<span class="number">6</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">8</span>)</span><br><span class="line">    b[<span class="number">7</span>] = <span class="keyword">byte</span>(g)</span><br><span class="line"></span><br><span class="line">    hex.Encode(h[:], b[:])</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GUID&quot;&gt;&lt;a href=&quot;#GUID&quot; class=&quot;headerlink&quot; title=&quot;GUID&quot;&gt;&lt;/a&gt;GUID&lt;/h1&gt;&lt;p&gt;在点外卖或者网上购物的时候，每个订单中都会有一串独一无二的数字，但是处理订单的服务器肯定不止一台，如何保证多台服务器，也就是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mpg123</title>
    <link href="https://oceanoverflow.github.io/2018/05/21/mpg123/"/>
    <id>https://oceanoverflow.github.io/2018/05/21/mpg123/</id>
    <published>2018-05-21T11:12:06.000Z</published>
    <updated>2018-05-21T11:17:16.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mpg123"><a href="#mpg123" class="headerlink" title="mpg123"></a>mpg123</h1><p>日常生活中，我们都是使用网易云音乐之类的音乐软件听歌，但是你有没有想过，作为程序员，该如何使用命令行来听（zhuang）歌（bi）呢？今天就让我们来实现这个功能吧。</p><p>写代码，一般需要搞清楚三点，输入，输出和算法。如果使用命令行听歌，输入很明确，肯定是音频数据流，数据一般可以通过网上获取，那么输出呢，肯定就是我们耳朵中听到的声音，这两点都比较简单。关键是处理数据和输出数据的算法，之前并没有怎么搞过音乐格式编码和解码之类的东西，不过不要慌，已经有强大的 <code>mpg123</code> 这个命令行工具帮我们搞定这类事情了。</p><p><code>mpg123</code> 需要额外安装，<code>macOS</code> 用户可以使用 <code>homebrew</code> 进行安装。<code>mpg123</code> 可以帮助我们处理 <code>MPEG 1.0/2.0/2.5</code> 格式的数据流，并使用系统默认的音屏设备播放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpg123 [ options ] file-or-URL...</span><br></pre></td></tr></table></figure><p>上面是它的简单使用，<code>[options]</code> 代表额外选项，真正的参数可以是本地音频文件地址或者 <code>URL</code> 地址。一般来说 <code>file/URL</code> 都需要是 <code>MPEG</code> 格式的音频比特流（ <code>audio bit stream</code> ）。</p><p>问题的关键解决之后，下面就可以利用它写一个简单的音乐播放器了，这里播放器具有两种状态，<code>Stopped</code> 和 <code>Playing</code> ，播放器的核心操作依赖 <code>mpg123</code> 实现，<code>exec.Cmd</code> 用于代表这个命令。除此之外，还需要指定输入和输出，输入（ <code>io.ReadCloser</code> ）可以来自 <code>HTTP</code> 得到的数据流，而输出（ <code>io.WriteCloser</code> ）则是该命令的输入管道。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> State <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Stopped State = <span class="literal">iota</span></span><br><span class="line">    Playing</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Player <span class="keyword">struct</span> &#123;</span><br><span class="line">    state      State</span><br><span class="line">    currentURL <span class="keyword">string</span></span><br><span class="line">    mpg123     *exec.Cmd</span><br><span class="line">    src        io.ReadCloser</span><br><span class="line">    dst        io.WriteCloser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为播放音乐需要 <code>mpg123</code> 这个依赖，所以，在程序运行时需要检查其是否存在，<code>exec.LookPath</code> 会在系统路径（ <code>$PATH</code> ）下面寻找，如果不存在，则返回 <code>error</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPlayer</span><span class="params">()</span> <span class="params">(*Player, error)</span></span> &#123;</span><br><span class="line">    _, err := exec.LookPath(<span class="string">"mpg123"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    p := &amp;Player&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> p, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令行听歌的关键还是在于对数据流的处理，通过 <code>io.Copy</code> 方法将数据流进行重定向。 </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stream</span><span class="params">(dst io.WriteCloser, src io.ReadCloser)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> dst.Close()</span><br><span class="line">    <span class="keyword">defer</span> src.Close()</span><br><span class="line">    io.Copy(dst, src)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>mpg123</code> 需要读取音频数据流，在构造命令时，我们使用 <code>-</code> 来指定<code>mpg123</code> 从标准输入中获取数据（ <code>exec.Command(&quot;mpg123&quot;, &quot;-q&quot;, &quot;-&quot;)</code> ），通过 <code>StdinPipe()</code> 方法可以获得连接到此命令的标准输入管道。输入的数据流可以利用 <code>http.Get</code> 获取，然后再利用上述 <code>stream</code> 方法将数据流重定向到 <code>mpg123</code> 的标准输入（ <code>stdin</code> ）中去，这样就可以实现音乐播放了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Player)</span> <span class="title">Play</span><span class="params">(URL <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p.state == Playing &#123;</span><br><span class="line">        p.Stop()</span><br><span class="line">        <span class="keyword">return</span> p.Play(URL)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mpg123 := exec.Command(<span class="string">"mpg123"</span>, <span class="string">"-q"</span>, <span class="string">"-"</span>)</span><br><span class="line">    stdin, err := mpg123.StdinPipe()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        stdin.Close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    err = mpg123.Start()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        stdin.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response, err := http.Get(URL)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.state = Playing</span><br><span class="line">    p.currentURL = URL</span><br><span class="line">    p.mpg123 = mpg123</span><br><span class="line">    p.src = response.Body</span><br><span class="line">    p.dst = stdin</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> stream(p.dst, p.src)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个音乐播放器自然少不了暂停操作。因为输入和输出分别是 <code>io.ReadCloser</code> 和 <code>io.WriteCloser</code> 类型，所以都可以调用 <code>Close</code> 方法来将它们关闭。除此之外还需要将对应的 <code>mpg123</code> 的进程停掉（ <code>p.mpg123.Process.Kill()</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Player)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p.state == Stopped &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    p.state = Stopped</span><br><span class="line">    p.src.Close()</span><br><span class="line">    p.src = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    p.dst.Close()</span><br><span class="line">    p.mpg123.Process.Kill()</span><br><span class="line">    p.mpg123.Wait()</span><br><span class="line">    p.mpg123.Handler = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下最后一个问题就是如何获取各大平台音乐的链接地址，下面给获取网易云音乐歌曲外链地址的方法，这里的参数 <code>id</code> 表示音乐的 <code>id</code> ，其他平台获取方法也应该类似，感兴趣的读者可以自行寻找。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMusicLink</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    s := <span class="string">"http://music.163.com/song/media/outer/url?id=%d.mp3"</span></span><br><span class="line">    addr = fmt.Sprintf(s, id)</span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mpg123&quot;&gt;&lt;a href=&quot;#mpg123&quot; class=&quot;headerlink&quot; title=&quot;mpg123&quot;&gt;&lt;/a&gt;mpg123&lt;/h1&gt;&lt;p&gt;日常生活中，我们都是使用网易云音乐之类的音乐软件听歌，但是你有没有想过，作为程序员，该如何使用命令行来听（z
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Future</title>
    <link href="https://oceanoverflow.github.io/2018/05/20/Future/"/>
    <id>https://oceanoverflow.github.io/2018/05/20/Future/</id>
    <published>2018-05-20T06:04:59.000Z</published>
    <updated>2018-05-20T06:05:42.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p><code>Future</code> 是 <code>java</code> 中比较常见的并发编程解决方案，它采用异步的方式，尽可能减少运行时代码阻塞，很大程度上提高了程序的运行效率，在<code>golang</code> 中我们可以利用 <code>goroutine</code> ， <code>chan</code> 机制和 <code>for select</code> 轻松实现类似的功能。</p><p>其实 <code>Future</code> 的本质就是异步计算的结果，我们用 <code>item interface{}</code> 来放置 <code>Future</code> 的结果，通过读取 <code>triggered</code> 的值来判断异步计算是否已经返回。</p><p><code>New</code> 方法用于构造 <code>Future</code> 任务，它通过监听 <code>Completer</code> 通道来获取异步执行的结果，如果监听超时，则停止监听，返回错误。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Future <span class="keyword">struct</span> &#123;</span><br><span class="line">    triggered <span class="keyword">bool</span></span><br><span class="line">    item      <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    err       error</span><br><span class="line">    lock      sync.Mutex</span><br><span class="line">    wg        sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Completer &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(completer Completer, timeout time.Duration)</span> *<span class="title">Future</span></span> &#123;</span><br><span class="line">    f := &amp;Future&#123;&#125;</span><br><span class="line">    f.wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> listen(f, completer, timeout)</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>listen</code> 是获得异步计算结果的核心，如果 <code>Completer</code> 通道返回，则通过 <code>set</code> 方法设置计算结果，并标记 <code>triggered</code> 为 <code>true</code> ，如果监听超时，则同样标记 <code>triggered</code> 为 <code>true</code> ，但此时应该返回一个错误而非正确的计算结果。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">(f *Future, ch Completer, timeout time.Duration)</span></span> &#123;</span><br><span class="line">    t := time.NewTicker(timeout)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> item := &lt;-ch:</span><br><span class="line">        f.set(item, <span class="literal">nil</span>)</span><br><span class="line">        t.Stop()</span><br><span class="line">    <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">        f.set(<span class="literal">nil</span>, fmt.Errorf(<span class="string">`timeout after %f seconds`</span>, timeout.Seconds()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>Future</code> 返回结果的时机并不确定， 所以我们需要一种方式得知结果是否已经返回，<code>IsDone</code> 方法通过查询 <code>triggered</code> 是否为 <code>true</code> 来得知结果是否已经返回 ，也就是查询事件是否已经触发，这里结果返回和发生超时都可以触发事件。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Future)</span> <span class="title">IsDone</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    done := f.triggered</span><br><span class="line">    f.lock.Unlock()</span><br><span class="line">    <span class="keyword">return</span> done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以无论是结果返回，还是超时发生，我们都要通过 <code>set</code> 方法对 <code>Future</code> 进行设置，来标记 <code>Future</code> 事件完成。设置完通过 <code>f.wg.Done()</code> 来通知所有等待此结果的监听者。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Future)</span> <span class="title">set</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    f.triggered = <span class="literal">true</span></span><br><span class="line">    f.item = item</span><br><span class="line">    f.err = err</span><br><span class="line">    f.lock.Unlock()</span><br><span class="line">    f.wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>Get</code> 方法用于获得 <code>Future</code> 执行的结果，如果此时 <code>Future</code> 已经触发，那么可以直接返回结果，但是如果此时 <code>triggered</code> 为 <code>false</code> ，也就是说那两件事件中一件都没有发生，此时我们只能傻傻地等待（ <code>f.wg.Wait()</code> ） ，直到别人广播（ <code>f.wg.Done()</code> ）来告知事件已经发生。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Future)</span> <span class="title">Get</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    <span class="keyword">if</span> f.triggered &#123;</span><br><span class="line">        f.lock.Unlock()</span><br><span class="line">        <span class="keyword">return</span> f.item, f.err</span><br><span class="line">    &#125;</span><br><span class="line">    f.lock.Unlock()</span><br><span class="line">    </span><br><span class="line">    f.wg.Wait()</span><br><span class="line">    <span class="keyword">return</span> f.item, f.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是应用 <code>Future</code> 的简单例子。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">completer := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">f := New(completer, time.Duration(<span class="number">30</span>*time.Minute))</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    result, err = f.Get()</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">completer &lt;- <span class="string">`test`</span></span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Future&quot;&gt;&lt;a href=&quot;#Future&quot; class=&quot;headerlink&quot; title=&quot;Future&quot;&gt;&lt;/a&gt;Future&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Future&lt;/code&gt; 是 &lt;code&gt;java&lt;/code&gt; 中比较常见的并发编程解决方案
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ADB</title>
    <link href="https://oceanoverflow.github.io/2018/05/19/ADB/"/>
    <id>https://oceanoverflow.github.io/2018/05/19/ADB/</id>
    <published>2018-05-19T07:38:54.000Z</published>
    <updated>2018-05-19T07:48:33.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ADB"><a href="#ADB" class="headerlink" title="ADB"></a>ADB</h1><p>安卓手机相对 <code>iPhone</code> 来说生态系统更加开放，可以做各种各样酷酷的事情，例如通过自己电脑上的命令行来刷刷朋友圈之类的，下面我们来看看如何通过 <code>adb</code> 这个神器来控制我们的安卓机吧。</p><p><code>adb</code> ，全称是 <code>Android Debug Bridge</code> ，也就是安卓调试桥，实际上就是一个命令行工具（并没有这么简单），通过它，我们就可以使用一系列命令来控制我们的手机了。</p><h2 id="adb-架构"><a href="#adb-架构" class="headerlink" title="adb 架构"></a>adb 架构</h2><p>为了更好的理解，我们先来看一下 <code>adb</code> 的基本架构，在整个架构中存在三个重要的组件，<code>client</code> ，<code>ADB Server</code> 和 <code>ADB Daemon</code> 。各个组件之间通过 <code>TCP/IP</code> 或者 <code>USB</code> 进行通信来交流信息。</p><p><img src="https://3.bp.blogspot.com/-IWnB96a3IpI/WmYNlJ_lJ5I/AAAAAAAAADg/6CUlgATGJtYVwrJeTq5lzo1PxAQb2oJtQCLcBGAs/s640/android_buffer_adb_command.png" alt="ADB"></p><ul><li><p>client<br>客户端，用于向 <code>ADB Server</code> 发送命令的工具，可以是命令行工具（ <code>Terminal</code> ）或者是 <code>Android Studio</code> ，存在于我们自己电脑上。</p></li><li><p>ADB Server<br>电脑上的客户端和手机中守护进程之间的中介，类似一座桥（这就是为什么<code>adb</code> 叫做桥的原因了），主要负责两者之间的通信，在本地计算机上作为后台进程运行。我们可以通过 <code>grep</code>  <code>ps</code> 命令的输出，来发现守护进程 <code>adb</code> 正在监听的 <code>TCP</code> 端口。 </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps -e | grep adb</span><br><span class="line">adb -L tcp:5037 fork-server server --reply-fd 4</span><br></pre></td></tr></table></figure><ul><li>ADB Daemon<br>存在于手机之上的守护进程，负责接受并处理来自 <code>ADB Server</code> 的消息。类似的，我们可以通过 <code>adb shell ps | grep adbd</code> 来寻找手机上的<code>adbd</code> 进程及相应的 <code>pid</code> 。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell ps | grep adbd</span><br><span class="line">shell        13336     1   14532    812 0     0 S adbd</span><br></pre></td></tr></table></figure><p>也就是说 <code>client</code> 和 <code>adb server</code> 存在于宿主机之上，采用传统的 <code>C/S</code> 模型，而 <code>adb server</code> 通过 <code>TCP</code> 或 <code>USB</code> 来向手机上的 <code>adb daemon</code> 发送消息。</p><h2 id="adb-通信"><a href="#adb-通信" class="headerlink" title="adb 通信"></a>adb 通信</h2><p>通信肯定会涉及到协议，只有通信的双方都遵守协议才能顺利运行，下面是 <code>abd</code> 协议报文的基本结构，与 <code>HTTP</code> 协议类似，<code>abd</code> 协议同样也处于应用层。传输层既可以采用 <code>USB</code> 来传送，也可以使用我们熟悉的 <code>TCP/IP</code> 。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned command; /* command identifier constant /</span><br><span class="line">unsigned arg1; / first argument /</span><br><span class="line">unsigned arg2; / second argument /</span><br><span class="line">unsigned data_length; / length of payload (0 is allowed) /</span><br><span class="line">unsigned data_crc32; / crc32 of data payload /</span><br><span class="line">unsigned magic; / command ^ 0xffffffff */</span><br></pre></td></tr></table></figure><p>也就是说 <code>adb server</code> 和 <code>adb daemon</code> 之间可以通过两种传输协议来发送 <code>adb</code> 协议报文。</p><h3 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h3><p>采用 <code>USB</code> 进行传输时，我们需要先将手机通过数据线连接到电脑上，注意手机需要进入开发者模式，并且通过相应的权限设置，如果连接成功的话，在命令行中输入 <code>adb devices</code> 就可以看到连接的设备了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">988a1b30374e494a52device</span><br></pre></td></tr></table></figure><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>当然除了 <code>USB</code> 这种传统方式的话，我们还可以利用酷酷的 <code>TCP/IP</code> 进行通信，首先也是通过 <code>USB</code> 连接手机和电脑，并确保两者连接到同一个局域网，在命令行中输入 <code>adb tcpip 5555</code> 使得 <code>adb daemon</code> 监听 <code>5555</code> 端口，然后通过 <code>adb connect &lt;IP_OF_YOUR_ANDROID_PHONE&gt;</code> 命令来连接我们的手机，这里 <code>&lt;IP_OF_YOUR_ANDROID_PHONE&gt;</code> 代表手机的 <code>IP</code> 地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb tcpip 5555</span><br><span class="line">$ adb connect &lt;IP_OF_YOUR_ANDROID_PHONE&gt;</span><br></pre></td></tr></table></figure><p>如果连接成功，再使用 <code>adb devices</code> 命令会获得以下输出，这里的输出和上面有写不同，这里会输出 <code>192.168.1.101:5555</code> ，这样就说明我们已经成功连接，可以拔掉我们的数据线进行通信了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">192.168.1.101:5555device</span><br></pre></td></tr></table></figure><h2 id="adb-常用命令"><a href="#adb-常用命令" class="headerlink" title="adb 常用命令"></a>adb 常用命令</h2><p>正确连接上了我们的手机之后，我们就可以干各种很酷的事情了。</p><h3 id="获取版本信息"><a href="#获取版本信息" class="headerlink" title="获取版本信息"></a>获取版本信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell getprop ro.build.version.release</span><br></pre></td></tr></table></figure><h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb push [source] [destination]</span><br><span class="line">$ adb pull [device file location] [location file location]</span><br></pre></td></tr></table></figure><h3 id="screenshot-和-screenrecord"><a href="#screenshot-和-screenrecord" class="headerlink" title="screenshot 和 screenrecord"></a>screenshot 和 screenrecord</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell screencap -p /sdcard/screenshot.png</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell screenrecord /sdcard/notabletologin.mp4</span><br></pre></td></tr></table></figure><h3 id="手势模拟"><a href="#手势模拟" class="headerlink" title="手势模拟"></a>手势模拟</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell swipe x1 y1 x2 y2</span><br></pre></td></tr></table></figure><h3 id="模拟基本操作"><a href="#模拟基本操作" class="headerlink" title="模拟基本操作"></a>模拟基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Home btn</span><br><span class="line">$ adb shell input keyevent 3 </span><br><span class="line">// Back btn</span><br><span class="line">$ adb shell input keyevent 4 </span><br><span class="line">// Call</span><br><span class="line">$ adb shell input keyevent 5 </span><br><span class="line">// End call</span><br><span class="line">$ adb shell input keyevent 6 </span><br><span class="line">// Turn Android device ON and OFF. It will toggle device to on/off status.</span><br><span class="line">$ adb shell input keyevent 26  </span><br><span class="line">// Camera</span><br><span class="line">$ adb shell input keyevent 27 </span><br><span class="line">// Open browser</span><br><span class="line">$ adb shell input keyevent 64 </span><br><span class="line">// Enter</span><br><span class="line">$ adb shell input keyevent 66 </span><br><span class="line">// Delete (backspace)</span><br><span class="line">$ adb shell input keyevent 67 </span><br><span class="line">// Contacts</span><br><span class="line">$ adb shell input keyevent 207 </span><br><span class="line">// Brightness down/up</span><br><span class="line">$ adb shell input keyevent 220 / 221 </span><br><span class="line">// Cut/Copy/Paste</span><br><span class="line">$ adb shell input keyevent 277 / 278 /279 </span><br><span class="line">// https://developer.android.com/reference/android/view/KeyEvent.html</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ADB&quot;&gt;&lt;a href=&quot;#ADB&quot; class=&quot;headerlink&quot; title=&quot;ADB&quot;&gt;&lt;/a&gt;ADB&lt;/h1&gt;&lt;p&gt;安卓手机相对 &lt;code&gt;iPhone&lt;/code&gt; 来说生态系统更加开放，可以做各种各样酷酷的事情，例如通过自己电脑上的命令行来刷
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Connection Limiter</title>
    <link href="https://oceanoverflow.github.io/2018/05/15/ConnectionLimiter/"/>
    <id>https://oceanoverflow.github.io/2018/05/15/ConnectionLimiter/</id>
    <published>2018-05-15T02:18:24.000Z</published>
    <updated>2018-05-15T11:36:24.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Connection-Limiter"><a href="#Connection-Limiter" class="headerlink" title="Connection Limiter"></a>Connection Limiter</h1><p>作为服务提供商，我们肯定是希望越多客户使用我们的服务越好，为此我们不惜花大价钱雇程序员来搞高并发服务器编程，砸很多的钱买最好的服务器，但是总有些无良用户想要和我们作对，搞很多 <code>HTTP</code> 连接请求恶意占用服务器的资源，导致其他用户的服务体验下降，从而最终导致客户的流失，这种情况我们肯定是希望极力避免的。</p><p>一般来说，正常的客户端（人为操作）不会在短时间内对同一服务发送过多的请求，只有想要实施恶意攻击行为的客户端（例如爬虫）才会同时发送很多请求来占用服务器的资源。为了避免这种情况的发生，我们需要限制同一个 <code>IP</code> 地址的请求数量。</p><p>实现连接限制的思路比较简单，我们通过一个 <code>map</code> 来记录来自同一个 <code>IP</code> 地址的 <code>HTTP</code> 请求的个数，如果在正常范围内，则给予该客户端正常的服务，如果超过上限，此时该客户端被怀疑正在进行爬虫之类的非善意行为，对此我们返回一个错误并拒绝服务该请求。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ConnLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    connections      <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span></span><br><span class="line">    maxConnections   <span class="keyword">int64</span></span><br><span class="line">    totalConnections <span class="keyword">int64</span></span><br><span class="line">    next             http.Handler</span><br><span class="line">    errHandler       ErrorHandler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(next http.Handler, maxConnections <span class="keyword">int64</span>)</span> <span class="params">(*ConnLimiter, error)</span></span> &#123;</span><br><span class="line">    cl := &amp;ConnLimiter &#123;</span><br><span class="line">        maxConnections: maxConnections,</span><br><span class="line">        connections: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>),</span><br><span class="line">        next: next,</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> cl.errHandler == <span class="literal">nil</span> &#123;</span><br><span class="line">        cl.errHandler = defaultErrHandler</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cl, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们是对同一个<code>IP</code> 地址设置连接限制，故对于每个请求，通过读取请求 <code>http.Request</code> 中的 <code>RemoteAddr</code> 来获取 <code>IP</code> 地址。但是上有政策，下游对策，很多写爬虫的人通过代理 <code>IP</code> 池来规避这种审查，这里我们先不讨论如何处理这种情况。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">extractClientIP</span><span class="params">(req *http.Request)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">    vals := strings.SplitN(req.RemoteAddr, <span class="string">":"</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(vals[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, <span class="number">0</span>, fmt.Errorf(<span class="string">"Failed to parse client IP: %v"</span>, req.RemoteAddr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vals[<span class="number">0</span>], <span class="number">1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还需要定义当同一个 <code>IP</code> 地址的连接数量超过最高连接数量的错误 <code>MaxConnError</code> 以及处理该错误的方法。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MaxConnError <span class="keyword">struct</span> &#123;</span><br><span class="line">    max <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MaxConnError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"max connections reached: %d"</span>, m.max)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConnErrHandler <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConnErrHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    statusCode := http.StatusInternalServerError</span><br><span class="line">    w.WriteHeader(statusCode)</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(http.StatusText(statusCode)))   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultErrHandler = &amp;ConnErrHandler&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>acquire</code> 和 <code>release</code> 方法在加锁的条件下对 <code>map</code> 进行操作，这是因为在并发情况下对同一个数据进行读写操作时，会发生数据竞争的情况，所以需要使用 <code>sync.Mutex</code> 来对数据读写进行保护。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl *ConnLimiter)</span> <span class="title">acquire</span><span class="params">(token <span class="keyword">string</span>, amount <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    cl.Lock()</span><br><span class="line">    <span class="keyword">defer</span> cl.Unlock()</span><br><span class="line"></span><br><span class="line">    connections := cl.connections[token]</span><br><span class="line">    <span class="keyword">if</span> connections &gt;= cl.maxConnections &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;MaxConnError&#123;max: cl.maxConnections&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cl.connections[token] += amount</span><br><span class="line">    cl.totalConnections += amount</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl *ConnLimiter)</span> <span class="title">release</span><span class="params">(token <span class="keyword">string</span>, amount <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    cl.Lock()</span><br><span class="line">    <span class="keyword">defer</span> cl.Unlock()</span><br><span class="line"></span><br><span class="line">    cl.connections[token] -= amount</span><br><span class="line">    cl.totalConnections -= amount</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> cl.connections[token] == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(cl.connections, token)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在提供服务（ <code>ServeHTTP</code> ）之前，我们通过 <code>acquire</code> 判断该客户端是否有资格获得服务，如果有资格则使用正常的 <code>handler</code> 来处理，否则则使用 <code>errHandler</code> 来处理，最后服务完了需要将相关资源释放（ <code>release</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl *ConnLimiter)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    token, amount, err := extractClientIP(r)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Errorf(<span class="string">"failed to extract source of the connection: %v"</span>, err)</span><br><span class="line">        cl.errHandler.ServeHTTP(w, r)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = cl.acquire(token, amount); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Debugf(<span class="string">"limiting request source %s: %v"</span>, token, err)</span><br><span class="line">        cl.errHandler.ServeHTTP(w, r)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> cl.release(token, amount)</span><br><span class="line"></span><br><span class="line">    cl.next.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl *ConnLimiter)</span> <span class="title">Wrap</span><span class="params">(h http.Handler)</span></span> &#123;</span><br><span class="line">    cl.next = h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Connection-Limiter&quot;&gt;&lt;a href=&quot;#Connection-Limiter&quot; class=&quot;headerlink&quot; title=&quot;Connection Limiter&quot;&gt;&lt;/a&gt;Connection Limiter&lt;/h1&gt;&lt;p&gt;作为服务提供
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Terminal UI</title>
    <link href="https://oceanoverflow.github.io/2018/05/14/TerminalUI/"/>
    <id>https://oceanoverflow.github.io/2018/05/14/TerminalUI/</id>
    <published>2018-05-14T14:49:04.000Z</published>
    <updated>2018-05-15T11:43:47.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Terminal-UI"><a href="#Terminal-UI" class="headerlink" title="Terminal UI"></a>Terminal UI</h1><p>之前用命令行版本的网易云音乐来听歌（ <code>musicbox</code> ，在 <code>github</code> 上可以搜索到），觉得实在是太 <code>geek</code> 了，但它是用 <code>python</code> 写的，略微容易崩，所以决定试着用 <code>golang</code> 仿造一个，第一步肯定是模仿它的 <code>UI</code> 了，在浏览器中我们用三元老 <code>HTML/CSS/JS</code> 可以很容易撸出一套能看的前端界面来，但估计没几个人知道命令行版本的 <code>UI</code> 应该怎么搞，其实说实话我也不知道，大概搜了一下，发现用 <code>termui</code> 这个库就可以比较轻松撸出一个与 <code>musicbox</code> 类似的界面了，下面我们来看一下如何用代码来实现吧。</p><h2 id="termui-安装"><a href="#termui-安装" class="headerlink" title="termui 安装"></a>termui 安装</h2><p>一般来说我们可以使用 <code>go get</code> 来进行获取安装，但最好使用 <code>dep</code> 来帮助我们管理项目的相关依赖。</p><p><code>go get -u github.com/gizak/termui</code></p><p>然后在代码中 <code>import</code> 就可以了。</p><p><code>import &quot;github.com/gizak/termui&quot;</code></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在使用 <code>termui</code> 时需要先进行初始化（ <code>termui.Init()</code> ），并且最后还要释放资源 <code>defer termui.Close()</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">err := termui.Init()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> termui.Close()</span><br></pre></td></tr></table></figure><h2 id="界面相关数据准备"><a href="#界面相关数据准备" class="headerlink" title="界面相关数据准备"></a>界面相关数据准备</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">strs := []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"   0. 排行榜"</span>,</span><br><span class="line">    <span class="string">"   1. 艺术家"</span>,</span><br><span class="line">    <span class="string">"   2. 新碟上架"</span>,</span><br><span class="line">    <span class="string">"   3. 精选歌单"</span>,</span><br><span class="line">    <span class="string">"   4. 我的歌单"</span>,</span><br><span class="line">    <span class="string">"   5. 主播电台"</span>,</span><br><span class="line">    <span class="string">"   6. 每日推荐"</span>,</span><br><span class="line">    <span class="string">"   7. 私人FM"</span>,</span><br><span class="line">    <span class="string">"   8. 搜索"</span>,</span><br><span class="line">    <span class="string">"   9. 帮助"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">off := []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"   0. 排行榜"</span>,</span><br><span class="line">    <span class="string">"   1. 艺术家"</span>,</span><br><span class="line">    <span class="string">"   2. 新碟上架"</span>,</span><br><span class="line">    <span class="string">"   3. 精选歌单"</span>,</span><br><span class="line">    <span class="string">"   4. 我的歌单"</span>,</span><br><span class="line">    <span class="string">"   5. 主播电台"</span>,</span><br><span class="line">    <span class="string">"   6. 每日推荐"</span>,</span><br><span class="line">    <span class="string">"   7. 私人FM"</span>,</span><br><span class="line">    <span class="string">"   8. 搜索"</span>,</span><br><span class="line">    <span class="string">"   9. 帮助"</span>,</span><br><span class="line">&#125;</span><br><span class="line">on := []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"[-&gt; 0. 排行榜](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 1. 艺术家](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 2. 新碟上架](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 3. 精选歌单](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 4. 我的歌单](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 5. 主播电台](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 6. 每日推荐](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 7. 私人FM](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 8. 搜索](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 9. 帮助](fg-cyan)"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义界面参数"><a href="#定义界面参数" class="headerlink" title="定义界面参数"></a>定义界面参数</h2><p>在使用 <code>termui</code> 时，我们需要确定界面元素及其属性，以及它在命令行中的排版，其实 <code>UI</code> 就是对数据的一种呈现，反正就是你觉得怎么好看就怎么来。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls := termui.List()</span><br><span class="line">ls.Items = strs</span><br><span class="line">ls.ItemFgColor = termui.ColorWhite</span><br><span class="line">ls.BorderLabel = <span class="string">"网易云音乐"</span></span><br><span class="line">ls.Height = <span class="number">12</span></span><br><span class="line">ls.Width = <span class="number">20</span></span><br><span class="line">ls.Y = <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="termui对事件的处理"><a href="#termui对事件的处理" class="headerlink" title="termui对事件的处理"></a>termui对事件的处理</h2><p><code>termui</code> 对事件的处理和 <code>HTTP</code> 处理事件的做法类似，我们需要对不同的事件注册回调函数，例如检测到用户输入 <code>q</code> ，我们注册一个类似的回调函数就可以了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">termui.Handle(<span class="string">"/sys/kbd/q"</span>, <span class="function"><span class="keyword">func</span><span class="params">(termui.Event)</span></span> &#123;</span><br><span class="line">    termui.StopLoop()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>相关事件可以是键盘输入，界面点击，窗口伸缩甚至可以是自定义事件。相关事件触发后，对应的数据可能会发生改变，这样以来用户界面就需要发生改变，我们可以使用 <code>termui.Render</code> 对界面重新进行渲染。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cursor := <span class="number">0</span></span><br><span class="line">termui.Render(ls)</span><br><span class="line">termui.Handle(<span class="string">"/sys/kbd/j"</span>, <span class="function"><span class="keyword">func</span><span class="params">(termui.Event)</span></span> &#123;</span><br><span class="line">    strs[cursor%<span class="built_in">len</span>(strs)] = off[cursor%<span class="built_in">len</span>(strs)]</span><br><span class="line">    cursor++</span><br><span class="line">    <span class="keyword">if</span> cursor == <span class="built_in">len</span>(strs) &#123;</span><br><span class="line">        cursor = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    strs[cursor%<span class="built_in">len</span>(strs)] = on[cursor%<span class="built_in">len</span>(strs)]</span><br><span class="line">    termui.Render(ls)</span><br><span class="line">&#125;)</span><br><span class="line">termui.Handle(<span class="string">"/sys/kbd/k"</span>, <span class="function"><span class="keyword">func</span><span class="params">(termui.Event)</span></span> &#123;</span><br><span class="line">    strs[cursor%<span class="built_in">len</span>(strs)] = off[cursor%<span class="built_in">len</span>(strs)]</span><br><span class="line">    cursor--</span><br><span class="line">    <span class="keyword">if</span> cursor &lt; <span class="number">0</span> &#123;</span><br><span class="line">        cursor = <span class="built_in">len</span>(strs) - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    strs[cursor%<span class="built_in">len</span>(strs)] = on[cursor%<span class="built_in">len</span>(strs)]</span><br><span class="line">    termui.Render(ls)</span><br><span class="line">&#125;)</span><br><span class="line">termui.Loop()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Terminal-UI&quot;&gt;&lt;a href=&quot;#Terminal-UI&quot; class=&quot;headerlink&quot; title=&quot;Terminal UI&quot;&gt;&lt;/a&gt;Terminal UI&lt;/h1&gt;&lt;p&gt;之前用命令行版本的网易云音乐来听歌（ &lt;code&gt;musicbox&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Job Dispatcher</title>
    <link href="https://oceanoverflow.github.io/2018/05/13/JobDispatcher/"/>
    <id>https://oceanoverflow.github.io/2018/05/13/JobDispatcher/</id>
    <published>2018-05-13T13:34:24.000Z</published>
    <updated>2018-05-15T11:48:32.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Job-Dispatcher"><a href="#Job-Dispatcher" class="headerlink" title="Job Dispatcher"></a>Job Dispatcher</h1><p>当处理大量计算密集型任务时，为了提高工作效率，常常会引入多台服务器同时进行处理，但是不同的服务器之间并不清楚自己该处理哪个任务，也就是说服务器自己并不能保证自己处理的任务和别人的任务是不一样的。为了解决上述问题，我们引入 <code>Job Dispatcher</code> 模型。</p><p>我们把处理任务的服务器称为 <code>Worker</code> ，而把分配任务的服务器称为<code>Dispatcher</code> 或者 <code>Master</code> 。<code>Dispatcher</code> 负责给当前处于空闲状态的 <code>Worker</code> 分配任务 （ <code>Job</code> ），当其处理完分配的任务之后，为了不让自己的 <code>CPU</code> 闲置，<code>Worker</code> 会通知 <code>Dispather</code> 自己是可用的（ <code>available</code> ） ，然后 <code>Dispatcher</code> 就可以继续向 <code>Worker</code> 分配任务，直到所有任务全都完成。这样的模型非常 <code>scalable</code> ，引入的 <code>Worker</code> 数量越多，任务完成得越快。</p><h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><p>一个任务我们用结构体 <code>Job</code> 来表示，现在对于此结构体中有什么我们并不关心，这个需要由业务逻辑具体定义。</p><p> <code>Worker</code> 中有三个 <code>channel</code> ，分别用于暂停，接收任务和通知 <code>Dispatcher</code> 任务完成用的。</p><p><code>Worker</code> 肯定需要某种机制停止退出，我们用一个 <code>exit chan struct{}</code> 通道来接收停止信号，如果该通道中收到了停止信号，也就可以说明今天的任务已经全部完成了，<code>Worker</code> 可以回家休息了。</p><p><code>Jobs chan Job</code> 通道很简单，当然就是用于接受任务的啦，相对来说，任务可是做不完的，一个任务做完下一个任务就马不停蹄的赶来了，所以用通道来表示可以说是再合适不过了。</p><p>最后来看一下最复杂的一个通道 <code>WorkerPool chan chan Job</code> ，这啥玩意啊，通道的通道？想想就头大，外层的通道的中包含了 <code>chan Job</code> ，也就是上面说过的 <code>Jobs</code> 通道，其实就代表 <code>Worker</code> 本身， 如果一个 <code>Job</code> 处理完了， <code>Worker</code> 就会处于空闲状态，所以就可以把它放在 <code>WorkerPool</code> 中等待 <code>Dispatcher</code> 来调度了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">    Payload <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">    WorkerPool <span class="keyword">chan</span> <span class="keyword">chan</span> Job</span><br><span class="line">    Jobs       <span class="keyword">chan</span> Job</span><br><span class="line">    exit       <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorker</span><span class="params">(workerPool <span class="keyword">chan</span> <span class="keyword">chan</span> Job)</span> *<span class="title">Worker</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Worker&#123;</span><br><span class="line">        WorkerPool: workerPool,</span><br><span class="line">        Jobs:       <span class="built_in">make</span>(<span class="keyword">chan</span> Job),</span><br><span class="line">        exit:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Stop</code> 方法向 <code>exit</code> 通道发送信号，这样一来 <code>Start</code> 方法中的 <code>select</code> 语句的第二个 <code>case</code> 就会被执行，<code>Worker</code> 就可以退出了。在 <code>Start</code> 方法中，<code>w.WorkerPool &lt;- w.Jobs</code> 会向 <code>WorkerPool</code> 中注册它自己，也就相当于向 <code>Dispatcher</code> 申明自己已经处于空闲状态，随时等待被调度。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            w.WorkerPool &lt;- w.Jobs</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> job := &lt;- w.Jobs:</span><br><span class="line">                <span class="comment">// do some heavy job here</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-w.exit:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        w.exit &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h2><p>所有的任务都是从外界来的（此处我们选择从 <code>JobQueue</code> 中读取），任务到来时并不会直接分配给 <code>Worker</code> ，而是先经过 <code>Dispatcher</code> 的魔爪，<code>Dispatcher</code> 会先判断哪个 <code>Worker</code> 处于空闲状态，然后再分配给空闲的 <code>Worker</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> JobQueue <span class="keyword">chan</span> Job</span><br></pre></td></tr></table></figure><p><code>Dispatcher</code> 结构体中的 <code>WorkerPool chan chan Job</code> 是任务调度实现的核心，我们上述 <code>Worker</code> 中的和 <code>Dispatcher</code> 中的其实是一个东西，<code>Worker</code> 中的是对 <code>Dispatcher</code> 中的一个引用而已。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dispatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">    WorkerPool <span class="keyword">chan</span> <span class="keyword">chan</span> Job</span><br><span class="line">    MaxWorkers <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDispatcher</span><span class="params">(maxWorkers <span class="keyword">int</span>)</span> *<span class="title">Dispatcher</span></span> &#123;</span><br><span class="line">    pool := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> Job, maxWorkers)</span><br><span class="line">    <span class="keyword">return</span> &amp;Dispatcher&#123;</span><br><span class="line">        WorkerPool: pool,</span><br><span class="line">        MaxWorkers: maxWorkers,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Run</code> 方法中起了 <code>MaxWorkers</code> 个 <code>Worker</code> 等待 <code>Dispatcher</code> 给自己分配任务。</p><p>在 <code>dispatch</code> 方法中，<code>Dispatcher</code> 会不断的从 <code>JobQueue</code> 中读取任务，并在 <code>WorkerPool</code> 中选取一个空闲的 <code>Worker</code> （ <code>worker := &lt;-d.WorkerPool</code> ），然后将任务分配给它（ <code>worker &lt;- job</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dispatcher)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; d.MaxWorkers; i++ &#123;</span><br><span class="line">        worker := NewWorker(d.WorkerPool)</span><br><span class="line">        worker.Start()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> d.dispatch()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dispatcher)</span> <span class="title">dispatch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> job := &lt;- JobQueue:</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(job Job)</span></span> &#123;</span><br><span class="line">                worker := &lt;-d.WorkerPool</span><br><span class="line">                worker &lt;- job</span><br><span class="line">            &#125;(job)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Job-Dispatcher&quot;&gt;&lt;a href=&quot;#Job-Dispatcher&quot; class=&quot;headerlink&quot; title=&quot;Job Dispatcher&quot;&gt;&lt;/a&gt;Job Dispatcher&lt;/h1&gt;&lt;p&gt;当处理大量计算密集型任务时，为了提高工作效率
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Reverse Proxy</title>
    <link href="https://oceanoverflow.github.io/2018/05/12/ReverseProxy/"/>
    <id>https://oceanoverflow.github.io/2018/05/12/ReverseProxy/</id>
    <published>2018-05-12T13:30:04.000Z</published>
    <updated>2018-05-15T11:57:53.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reverse-Proxy"><a href="#Reverse-Proxy" class="headerlink" title="Reverse Proxy"></a>Reverse Proxy</h1><p>在正常的 <code>HTTP</code> 服务流程中，客户端向服务器发送 <code>HTTP</code> 请求，服务器收到后会向客户端返回一个 <code>HTTP</code> 答复。但在实际生产环境中，真正处理请求的服务器和客户端之间通常还会引入一个中介，也就是反向代理服务器，在引入了反向代理服务器之后，客户端会先将请求发送给反向代理服务器，反向代理收到该 <code>HTTP</code> 请求后，并不会自己亲自处理该请求，而是将请求转发给真正的处理业务逻辑的服务器，让它去处理，业务逻辑服务器处理完之后，会先将答复返回给反向代理服务器，再由反向代理服务器返回给客户端。</p><p>生活中常见的 <code>NGINX</code> 就常常作为反向代理服务器来使用。那么你可能会问，传统 <code>C/S</code> 模型难道不够好吗，还非要引入一个不知道什么鬼的反向代理来捣乱，引入之后只会把架构变得更复杂，有啥好处？（傲娇状）其实原因很简单，第一反向代理服务器可以当作防火墙来用，它为真正的业务逻辑服务器与外界可能的恶意攻击之间提供了一个屏障，尤其是像银行这种对安全性要求极高的金融机构无论加几个这样的防火墙都不会嫌多。第二点就是它可以提供负载均衡功能，通过使用不同的策略将请求转发给不同的服务器，以达到负载均衡的目的。</p><p>幸运的是，引入反向代理，并不会改变传统的 <code>C/S</code> 编程模型，因为客户端无法感知反向代理服务器的存在，他们只会觉得反向代理服务器就是真正处理业务逻辑的服务器。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/67/Reverse_proxy_h2g2bob.svg/1200px-Reverse_proxy_h2g2bob.svg.png" alt="Reverse Proxy"></p><p>下面我们来实现一个简单的反向代理服务器吧，虽然听着很恐怖，但是不用慌，强大的 <code>Golang</code> 标准库已经实现了反向代理的功能了。<code>httputil</code> 中提供的 <code>ReverseProxy</code> 结构体具有将请求重定向的能力（ <code>Director</code> ），也具有将答复修改的能力（ <code>ModifyResponse</code> ），最重要的是，可以通过 <code>Transport</code> 这个 <code>http.RoundTripper</code> 将我们的代理请求发送出去。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReverseProxy <span class="keyword">struct</span> &#123;</span><br><span class="line">    Director      <span class="function"><span class="keyword">func</span><span class="params">(*http.Request)</span></span></span><br><span class="line"><span class="function">    <span class="title">Transport</span>     <span class="title">http</span>.<span class="title">RoundTripper</span></span></span><br><span class="line"><span class="function">    <span class="title">FlushInterval</span> <span class="title">time</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function">    <span class="title">ErrorLog</span>      *<span class="title">log</span>.<span class="title">Logger</span></span></span><br><span class="line"><span class="function">    <span class="title">BufferPool</span>    <span class="title">BufferPool</span></span></span><br><span class="line"><span class="function">    <span class="title">ModifyReponse</span> <span class="title">func</span><span class="params">(*http.Response)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">RoundTripper</span> <span class="title">interface</span></span> &#123;</span><br><span class="line">    RoundTrip(*http.Request) (*http.Response, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为一个代理服务器，虽然不直接处理业务逻辑，但是最基本的对请求的处理和答复的功能还是要有的，与一般的 <code>HTTP</code> 服务器类似，我们的反向代理服务器 <code>ReverseProxy</code> 也需要有 <code>ServeHTTP(http.ResponseWriter, *http.Request)</code> 这样的方法。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(http.ResponseWriter, *http.Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以为了实现代理请求的功能，我们需要定义一个结构体 <code>handler</code> ，使其实现 <code>ServeHTTP(http.ResponseWriter, *http.Request)</code> 方法，在该方法中我们通过 <code>httputil.NewSingleHostReverseProxy</code> 来构造一个反向代理，并将请求通过 <code>proxy.ServeHTTP(w, r)</code> 方法将请求代理到随机的（随机是为了实现负载均衡）服务器上。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">servers := []<span class="keyword">string</span>&#123;</span><br><span class="line">     <span class="string">"111.222.111.222"</span>,</span><br><span class="line">     <span class="string">"222.111.222.111"</span>,</span><br><span class="line">     <span class="string">"111.233.111.233"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> handler <span class="keyword">struct</span> &#123;</span><br><span class="line">    reverseProxy <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *handler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    addr := servers[rand.Intn(<span class="built_in">len</span>(servers))]</span><br><span class="line">    remote, err := url.Parse(<span class="string">"http://"</span> + addr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    proxy := httputil.NewSingleHostReverseProxy(remote)</span><br><span class="line">    proxy.ServeHTTP(w, r)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们申明一个 <code>http.Server</code> ，在 <code>StartServer</code> 中我们监听指定的端口（ <code>bind</code> ），其对应的 <code>Handler</code> 就是我们之前实现的 <code>handler</code> 结构体，用于把请求代理到 <code>remote</code> 上去，这样以来一个基本的反向代理服务器就实现好了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> srv http.Server</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartServer</span><span class="params">(bind <span class="keyword">string</span>, remote <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"Listening on %s, forwarding to %s"</span>, bind, remote)</span><br><span class="line">    h := &amp;handler&#123;reverseProxy: remote&#125;</span><br><span class="line">    srv.Addr = bind</span><br><span class="line">    srv.Handler = h</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := srv.ListenAndServe(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(<span class="string">"ListenAndServe:"</span> err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StopServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := srv.Shutdown(<span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    StartServer(<span class="string">":8080"</span>, <span class="string">"remote:8080"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中的采用的负载均衡算法只用了非常简单的随机选取策略，这只适合每台服务器性能差别不大的情况，如果服务器之间性能差距较大，我们可以使用 <code>Weighted Round Robin</code> 这样的负载均衡算法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Reverse-Proxy&quot;&gt;&lt;a href=&quot;#Reverse-Proxy&quot; class=&quot;headerlink&quot; title=&quot;Reverse Proxy&quot;&gt;&lt;/a&gt;Reverse Proxy&lt;/h1&gt;&lt;p&gt;在正常的 &lt;code&gt;HTTP&lt;/code&gt; 服务流
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Advisory Lock</title>
    <link href="https://oceanoverflow.github.io/2018/05/12/AdvisoryLock/"/>
    <id>https://oceanoverflow.github.io/2018/05/12/AdvisoryLock/</id>
    <published>2018-05-12T05:26:04.000Z</published>
    <updated>2018-05-15T11:33:27.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Advisory-Lock"><a href="#Advisory-Lock" class="headerlink" title="Advisory Lock"></a>Advisory Lock</h1><p>很多时候，在操作系统中，对于特定应用，我们只希望起一个进程实例，但是操作系统并没有限制同一个应用进程的个数，也就是说，在每个应用运行前，我们需要检测进程是否存在。</p><p>那么如何检测进程是否已经存在了呢，我们可以在进程启动时，生成一个以 <code>.pid</code> 结尾的文件，并向这个文件上加一个建议性锁（ <code>advisory lock</code> ），这样如果有第二个这个的进程起来，它会试着去打开这个 <code>.pid</code> 文件，并试着向这个文件加建议性锁，但由于先起来的进程已经加过锁了，所以第二个进程就没有办法再加锁了，第二个进程知道自己不是第一个起起来的，所以就选择退出。</p><p>等等，刚才说的建议性锁又是什么呢，建议性锁就好像人们指定的一系列规则， 例如交通法规建议人们红灯停，绿灯行，这里的红绿灯就是一个建议性锁，但是总有不听话的人不遵守这些规则，也就是说无视建议性锁的存在。建议性锁并不是强制性的，进程可以选择不去遵守它。</p><p>上面进程的例子就是这样，第二个进程如果观测到文件已经上锁了，如果它不是恶意进程，那么它会选择尊重规则选择退出。</p><h2 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h2><p>下面我们来实现一个文件锁，文件锁的本质就是文件，所以我们选择对 <code>os.File</code> 做一层封装，然后对它添加额外的行为使其成为一个真正的文件锁。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LockFile <span class="keyword">struct</span> &#123;</span><br><span class="line">    *os.File</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLockFile</span><span class="params">(file *os.File)</span> *<span class="title">LockFile</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;LockFile&#123;file&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对文件上锁和解锁的过程其实就是利用系统调用 <code>syscall.Flock</code>，下面是c语言中的系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_SH 1 <span class="comment">/* shared lock */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_EX 2 <span class="comment">/* exclusive lock */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_NB 4 <span class="comment">/* don't block when locking */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_UN 8 <span class="comment">/* unlock */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">flock(<span class="keyword">int</span> fd, <span class="keyword">int</span> operation)</span><br></pre></td></tr></table></figure><p>建议性锁分为两大类：共享锁（ <code>SH</code> ）和专有锁（ <code>EX</code> ），这里我们采用专有锁，也就是利用 <code>LOCK_EX</code> 选项，如果文件已经上过锁了，再次尝试对该文件上锁时，操作会被阻塞，为了避免调用此系统调用的进程被阻塞，我们在系统调用时增加一个 <code>LOCK_NB</code> 选项，也就是非阻塞（ <code>non blocking</code> ）的意思，指定该选项后如果尝试上锁时，文件已经上过锁了，此时则则不会发生阻塞而是返回一个 <code>EWOULDBLOCK</code> 错误，当对文件解锁时，只需要在系统调用时指定 <code>LOCK_UN</code> 选项就可以了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ErrWouldBlock = errors.New(<span class="string">"Resource temporarily unavailable"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *LockFile)</span> <span class="title">Lock</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lockFile(file.Fd())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lockFile</span><span class="params">(fd <span class="keyword">uintptr</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    err := syscall.Flock(<span class="keyword">int</span>(fd), syscall.LOCK_EX|syscall.LOCK_NB)</span><br><span class="line">    <span class="keyword">if</span> err == syscall.EWOULDBLOCK &#123;</span><br><span class="line">        err = ERRWouldBlock</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *LockFile)</span> <span class="title">Unlock</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unlockFile(file.Fd())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unlockFile</span><span class="params">(fd <span class="keyword">uintptr</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    err := syscall.Flock(<span class="keyword">int</span>(fd), syscall.LOCK_UN)</span><br><span class="line">    <span class="keyword">if</span> err == syscall.EWouldBLOCK &#123;</span><br><span class="line">        err = ErrWouldBlock</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>OpenLockFile</code> 方法很简单，就是对 <code>os.OpenFile</code> 方法进行了一层封装，将此方法返回的 <code>file</code> 封装为<code>LockFile</code> 返回供接下去使用。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenLockFile</span><span class="params">(name <span class="keyword">string</span>, perm os.FileMode)</span> <span class="params">(lock *LockFile, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> file *os.File</span><br><span class="line">    <span class="keyword">if</span> file, err = os.OpenFile(name, os.O_RWWR|os.O_CREATE, perm); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        lock = &amp;LockFile&#123;file&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程存在性检测"><a href="#进程存在性检测" class="headerlink" title="进程存在性检测"></a>进程存在性检测</h2><p>文件上锁可以用作进程存在性检测，我们在进程创建时生成一个以 <code>.pid</code> 结尾的文件，并向该文件中写入当前进程的进程号，下面的 <code>WritePid</code> 方法就将当前进程的进程号写入文件起始位置，而 <code>ReadPid</code> 则将此文件中存储的 <code>pid</code> 读取出来，注意这里无论是读操作还是写操作都会先将文件的指针定位到最开始的位置（通过 <code>file.Seek(0, os.SEEK_SET)</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *LockFile)</span> <span class="title">WritePid</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err = file.Seek(<span class="number">0</span>, os.SEEK_SET); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fileLen <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> fileLen, err = fmt.Fprint(file, os.Getpid()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = file.Truncate(<span class="keyword">int64</span>(fileLen)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    err = file.Sync()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *LockFile)</span> <span class="title">ReadPid</span><span class="params">()</span> <span class="params">(pid <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err = file.Seek(<span class="number">0</span>, os.SEEK_SET); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    _, err = fmt.Fscan(file, &amp;pid)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *LockFile)</span> <span class="title">Remove</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err := file.Unlock(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os.Remove(file.Name())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们创建一个 <code>pid</code> 文件时候，我们需要检测其他进程是否已经存在，<code>CreatePidFile</code> 方法会使用 <code>Lock</code> 方法尝试对文件上锁，如果上锁失败，则说明已经有进程对该文件上过锁，此时则应该选择退出，如果上锁成功，则说明自己是第一个进程，并将自己的进程号写入该文件中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreatePidFile</span><span class="params">(name <span class="keyword">string</span>, perm os.FileMode)</span> <span class="params">(lock *LockFile, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> lock, err = OpenLockFile(name, perm); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = lock.Lock(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        lock.Remove()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = lock.WritePid(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        lock.Remove()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadPidFile</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(pid <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> file *os.File</span><br><span class="line">    <span class="keyword">if</span> file, err = os.OpenFile(name, os.O_RDONLY, <span class="number">0640</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    lock := &amp;LockFile&#123;file&#125;</span><br><span class="line">    pid, err = lock.ReadPid()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Advisory-Lock&quot;&gt;&lt;a href=&quot;#Advisory-Lock&quot; class=&quot;headerlink&quot; title=&quot;Advisory Lock&quot;&gt;&lt;/a&gt;Advisory Lock&lt;/h1&gt;&lt;p&gt;很多时候，在操作系统中，对于特定应用，我们只希望起一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Token Bucket</title>
    <link href="https://oceanoverflow.github.io/2018/05/11/TokenBucket/"/>
    <id>https://oceanoverflow.github.io/2018/05/11/TokenBucket/</id>
    <published>2018-05-11T14:05:04.000Z</published>
    <updated>2018-05-15T11:42:28.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Token-Bucket"><a href="#Token-Bucket" class="headerlink" title="Token Bucket"></a>Token Bucket</h1><p>学校里的宽带还是有分三六九等的，如果你钱交的多的，对应带宽自然比较高。但你想过他们是如何限制你的最高带宽的吗？其实用令牌桶（ <code>Token Bucket</code> ）这个算法就可以实现速率限制这个功能。</p><p>那么什么又是令牌桶的，简单的说就是假设你有一个专门用于放令牌的桶，桶的最大容量是有上限的，设为C，而该桶自带一个机制就是每隔固定的一段时间会产生一个令牌，一旦令牌充满了桶，桶中的令牌个数就不会再增加了。接下来是重点，如果你要进行某个需要控制速率的操作，在执行这个操作之前，必须先从桶中拿到这个操作对应的令牌个数，比如规定了操作A需要5个令牌，操作B需要10个令牌，那么如果要执行操作A，则需要从桶中拿出5个令牌，如果桶中的令牌数目不够，就需要等到令牌数量足够时才能进行A操作。由于桶中令牌产生的速率是固定的，而在进行相关操作之前，又必须获得足够数量的令牌，这样就到达了速率限制（ <code>Rate Limiting</code> ）的目的。</p><p>除了速率限制之外，令牌桶算法还具有流量整形（ <code>Traffic Shaping</code> ）的功能，因为令牌桶中的令牌是以恒定的速率产生的，所以一段时间内产生的令牌数量是固定的，如果在某一段时间消耗的令牌数量较多，也就是对应操作的数量很多，那么之后的一段时间的操作数量必定会收到限制，从整体上来看，操作的速率会比较均匀，也就是说流量是以比较均衡的速率向外发送的。</p><p><img src="https://community.cambiumnetworks.com/bstrc49894/attachments/bstrc49894/forums_pmp_450/5991/1/TokenBucket.JPG" alt="Token Bucket"></p><p>下面我们来看一下令牌桶算法的实现，由于令牌桶中非常重要的两个属性就是令牌桶的容量和令牌产生的速率，分别用 <code>capacity</code> 和 <code>rate</code> 来表示，我们使用一个通道来存储令牌，因为我们并不关心令牌的内容，所以我们使用 <code>tokens chan struct{}</code> 来表示这个桶。</p><p>在初始化令牌桶的时候，直接起一个 <code>goroutine</code> 来定时向我们的桶中放入令牌，通过 <code>time.NewTicker</code> 用于定时生产令牌，如果令牌桶满了，则<code>b.tokens &lt;- struct{}{}</code> 操作也会被阻塞。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bucket <span class="keyword">struct</span> &#123;</span><br><span class="line">    capacity <span class="keyword">int64</span></span><br><span class="line">    tokens <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    rate time.Duration</span><br><span class="line">    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBucket</span><span class="params">(rate time.Duration, capacity <span class="keyword">int64</span>)</span> *<span class="title">Bucket</span></span> &#123;</span><br><span class="line">    tokens := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, capacity)</span><br><span class="line">    b := &amp;Bucket&#123;</span><br><span class="line">        capacity: capacity,</span><br><span class="line">        tokens: tokens,</span><br><span class="line">        rate: rate,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(b *Bucket)</span></span> &#123;</span><br><span class="line">        ticker := time.NewTicker(rate)</span><br><span class="line">        <span class="keyword">for</span> _ := <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">            b.tokens &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面给出了设置时间间隔（等效为速率）的方法，时间间隔越短，对应的平均速率就越快，二者成反比关系。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span> <span class="title">GetRate</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">    b.Lock()</span><br><span class="line">    tmp := b.rate</span><br><span class="line">    b.Unlock()</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span> <span class="title">SetRate</span><span class="params">(rate time.Duration)</span></span> &#123;</span><br><span class="line">    b.Lock()</span><br><span class="line">    b.rate = rate</span><br><span class="line">    b.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在进行特定操作之前需要取出固定数量的令牌，可以形象的把令牌想象为存在银行里的钱，把令牌桶想象成银行，如果你想要买一台电脑，你就需要从银行拿出足够的钱，如果银行中没有足够的钱，你只能等到你积累了足够的钱才可以买你想要的电脑。也就是说在执行相应操作之前需要有足够多的令牌才能顺利执行。注意到这个函数是阻塞的，只有在 <code>n</code> 次 <code>&lt;-b.tokens</code> 成功之后，该函数才会返回。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span> <span class="title">withdrawTokens</span><span class="params">(n <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">int64</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">        &lt;-b.tokens</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SpendToken</code> 函数会返回一个通道，其函数内部会起一个 <code>goroutine</code> ，在该 <code>goroutine</code> 里会执行上述 <code>withdrawTokens</code> 方法，由于该函数是阻塞的，所以只有它执行完，才能将返回值放入通道 <code>c</code> 中，然后利用 <code>close(c)</code> 操作将该通道关闭，这样以来别处调用该函数的地方就可以顺利返回了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span> <span class="title">SpendToken</span><span class="params">(n <span class="keyword">uint64</span>)</span> &lt;-<span class="title">chan</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(b *Bucket, n <span class="keyword">uint64</span>, c <span class="keyword">chan</span> error)</span></span> &#123;</span><br><span class="line">        c &lt;- b.withdrawTokens(n)</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;(b, n, c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Drain</code> 方法将桶中的所有令牌一次性放光，具体该在哪里使用它要看具体需求。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span> <span class="title">Drain</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-b.tokens:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="令牌桶的使用"><a href="#令牌桶的使用" class="headerlink" title="令牌桶的使用"></a>令牌桶的使用</h2><p>使用令牌桶之前当然需要新建一个令牌桶，并指定令牌桶的容量及其平均速率。因为使用令牌桶的目的之一就是限制速率，在需要被限速的函数（ <code>RegulatedAction()</code> ）前使用 <code>&lt;-bucket.SpendToken(x)</code> ，该 <code>RegulatedAction</code> 只有等到攒满 <code>x</code> 个令牌才会执行，这样就可以达到限制速率的目的了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bucket := NewBucket(<span class="number">1</span> * time.Second, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">&lt;-bucket.SpendToken(<span class="number">10</span>)</span><br><span class="line">RegulatedAction()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Token-Bucket&quot;&gt;&lt;a href=&quot;#Token-Bucket&quot; class=&quot;headerlink&quot; title=&quot;Token Bucket&quot;&gt;&lt;/a&gt;Token Bucket&lt;/h1&gt;&lt;p&gt;学校里的宽带还是有分三六九等的，如果你钱交的多的，对应带宽自
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Stream Cipher</title>
    <link href="https://oceanoverflow.github.io/2018/05/11/StreamCipher/"/>
    <id>https://oceanoverflow.github.io/2018/05/11/StreamCipher/</id>
    <published>2018-05-11T05:10:04.000Z</published>
    <updated>2018-05-15T11:56:52.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stream-Cipher"><a href="#Stream-Cipher" class="headerlink" title="Stream Cipher"></a>Stream Cipher</h1><p>假如我们有一份很重要的文件想要从本地传输到远程客户端，因为并不想让别人看见我们传输的信息，所以需要使用某种手段将传输的数据保护起来，我们可以选择先将文件加密后再进行传输，别人收到之后再进行相应的解密操作。这种方式对于小文件来说问题倒不是很大，但是如果文件体积非常大，本地对文件进行加密和远程对文件进行解密花费的时间就会很长，这样的话时间效率就非常低了，如果我们可以对该文件边加密边传输，远程客户端也可以边接收边解密的话，时间效率就可以大幅度提升了。</p><p>下面我们来引入流加密解决上述问题，流加密有很多模式，例如 <code>CFB</code>，<code>CTR</code> ，<code>OFB</code> 等。而流加密的核心就是异或操作，使用 <code>XORKeyStream</code> 就可以进行加解密了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cipher</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stream <span class="keyword">interface</span> &#123;</span><br><span class="line">    XORKeyStream(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为加密解密肯定涉及到读写操作，所以我们用一个结构体 <code>writer</code> 实现 <code>io.Writer</code> 这个接口，里面封装了一个 <code>io.Writer</code> 和 <code>cipher.Stream</code> ，基本的思路就是将数据经过 <code>cipher.Stream</code> 的 <code>XORKeyStream</code> 方法写入 <code>io.Writer</code> 中。这里 <code>buf</code> 作为中间读操作和加密操作的缓存。</p><p>考虑到通用性，这里和下面我们使用 <code>io.Writer</code> 和 <code>io.Writer</code> 这样的接口进行抽象操作，而非使用具体的 <code>Writer</code> 或者 <code>Reader</code> 来代替。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bufSize = <span class="number">32</span> * <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> writer <span class="keyword">struct</span> &#123;</span><br><span class="line">    io.Writer</span><br><span class="line">    cipher.Stream</span><br><span class="line">    buf []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(w io.Writer, s cipher.Stream)</span> <span class="title">io</span>.<span class="title">Writer</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;writer&#123;Writer: w, Stream: s, buf: <span class="built_in">make</span>([]<span class="keyword">byte</span>, bufSize)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *writer)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    n, err := w.ReadFrom(bytes.NewBuffer(b))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(n), err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReadFrom</code> 方法使我们的 <code>writer</code> 不断从未加密的 <code>io.Reader</code> 中读取数据到 <code>buf</code> 中，再利用 <code>XORKeyStream</code> 将数据加密后写入自己的 <code>io.Writer</code> 中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *writer)</span> <span class="title">ReadFrom</span><span class="params">(r io.Reader)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        buf := w.buf</span><br><span class="line">        nr, er := r.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> nr &gt; <span class="number">0</span> &#123;</span><br><span class="line">            n += <span class="keyword">int64</span>(nr)</span><br><span class="line">            buf = buf[:nr]</span><br><span class="line">            w.XORKeyStream(buf, buf)</span><br><span class="line">            _, ew := w.Writer.Write(buf)</span><br><span class="line">            <span class="keyword">if</span> ew != <span class="literal">nil</span> &#123;</span><br><span class="line">                err = ew</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> er != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> er != io.EOF &#123;</span><br><span class="line">                err = err</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在读方面，和写的时候类似，我们也在自己定义的结构体 <code>reader</code> 中包含一个 <code>io.Reader</code> 和 <code>cipher.Stream</code> ，基本思路也是从 <code>io.Reader</code> 中读取经过加密的数据，然后再用 <code>cipher.Stream</code> 的 <code>XORKeyStream</code> 方法解密。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> reader <span class="keyword">struct</span> &#123;</span><br><span class="line">    io.Reader</span><br><span class="line">    cipher.Stream</span><br><span class="line">    buf []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(r io.Reader, s cipher.Stream)</span> <span class="title">io</span>.<span class="title">Reader</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;reader&#123;Reader: r, Stream: s, buf: <span class="built_in">make</span>([]<span class="keyword">byte</span>, bufSize)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面实现的 <code>Read</code> 方法利用 <code>io.Reader</code> 读取经过加密后的数据，再利用<code>XORKeyStream</code> 进行解密。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *reader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    n, err := r.Reader.Read(b)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    b = b[:n]</span><br><span class="line">    r.XORKeyStream(b, b)</span><br><span class="line">    <span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WriteTo</code> 方法反复使用上面的 <code>Read</code> 方法将数据解密后写入 <code>io.Writer</code> 中直到结束。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *reader)</span> <span class="title">WriteTo</span><span class="params">(w io.Writer)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        buf := r.buf</span><br><span class="line">        nr, er := r.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> nr &gt; <span class="number">0</span> &#123;</span><br><span class="line">            nw, ew := w.Write(buf[:nr])</span><br><span class="line">            n += <span class="keyword">int64</span>(nw)</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span> ew != <span class="literal">nil</span> &#123;</span><br><span class="line">                err = ew</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> er != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> er != io.EOF &#123;</span><br><span class="line">                err = er</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Stream-Cipher&quot;&gt;&lt;a href=&quot;#Stream-Cipher&quot; class=&quot;headerlink&quot; title=&quot;Stream Cipher&quot;&gt;&lt;/a&gt;Stream Cipher&lt;/h1&gt;&lt;p&gt;假如我们有一份很重要的文件想要从本地传输到远程客户端
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Connection Pool</title>
    <link href="https://oceanoverflow.github.io/2018/05/10/ConnectionPool/"/>
    <id>https://oceanoverflow.github.io/2018/05/10/ConnectionPool/</id>
    <published>2018-05-10T03:40:24.000Z</published>
    <updated>2018-05-15T11:38:26.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Connection-Pool"><a href="#Connection-Pool" class="headerlink" title="Connection Pool"></a>Connection Pool</h1><p>因为 <code>TCP</code> 连接都是客户端主动发起的，也就是说需要经过三次握手才能够进行读写操作，如果客户端需要建立连接的次数较少，那么握手需要的开销倒可以忽略不计，但是如果客户端需要建立成千上万个 <code>TCP</code> 连接，那么就需要成千上万次握手了。如果真是这样，势必会导致系统性能低下，我们引入连接池来解决多次握手的问题。</p><p>连接池（ <code>Connection Pool</code> ）在广义上来说算是资源池，我们之前讲过的  <a href="LeakyBuffer.md">LeakyBuffer</a> 也算是资源池的一种，不过 <code>LeakyBuffer</code> 的目的是反复利用内存资源，减少内存分配的次数。而连接池则是为了减少建立连接的次数，重复利用已有的 <code>TCP</code> 连接。</p><p><img src="https://code.aliyun.com/middlewarerace2018/docs/raw/master/assets/system-architecture.png" alt="ConnPool"></p><p>例如在上图中，<code>Consumer Agent</code> 不断收到来自 <code>Consumer</code> 的 <code>HTTP</code> 请求，它解析请求的内容后，<code>Consumer Agent</code> 就要利用 <code>TCP</code> 连接给 <code>Provider Agent</code> 发送消息，那么如果按照传统的方法我们就需要每一个 <code>HTTP</code> 请求都要对应一个新的 <code>TCP</code> 连接，也就对应新的三次握手，这样的话系统开销会非常大。你可能会问为什么不直接用一个 <code>TCP</code> 连接来解决传输数据的问题，这样的话甚至不用这么多握手操作了，这问题不错，但是考虑到由于 <code>TCP</code> 传输的是应用层的数据，它并不了解应用层传输的信息究竟是什么意思，如果多个客户端发起的连接共用一个 <code>TCP</code> 连接，那么我们还需要写逻辑去区分收到的消息究竟需要属于哪个 <code>HTTP</code> 请求，另外还需要考虑<code>TCP</code> 发送和接受时读写竞争的问题，操作起来比较混乱，还不如重复利用多个 <code>TCP</code> 连接来发送和接受数据来的干净利落。</p><p>总的来说，连接池是一种利用空间换时间的技术。下面我们来看一下如何设计一个连接池。连接池中最核心的操作就是获取一个空闲的 <code>TCP</code> 连接，另外还要考虑连接池资源释放的问题，否则可能会导致内存泄漏。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ErrClosed = errors.New(<span class="string">"pool is closed"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get() (net.Conn, error)</span><br><span class="line">    Close()</span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在正常的 <code>TCP</code> 流程中，<code>Close</code> 会关闭本次连接，底层会进行四个挥手操作，但是我们不希望我们调用 <code>Close</code> 时直接关闭这个连接，而是希望能回收这个连接，所以我们对普通的 <code>net.Conn</code> 做了一层封装，来该改变其 <code>Close</code> 行为（其实这就是装饰器模式的应用），我们想要客户端调用 <code>Close</code> 的时候被我们的连接池所回收而非直接关闭，除非该连接被标记为不可用时 <code>unusable</code> （通过 <code>MarkUnusable</code> ）， 我们才决定关闭本次连接。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PooledConn <span class="keyword">struct</span> &#123;</span><br><span class="line">    net.Conn</span><br><span class="line">    mu  sync.RWMutex</span><br><span class="line">    c   *ConnPool</span><br><span class="line">    unusable <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PooledConn)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    p.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> p.mu.Runlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> p.unusable &#123;</span><br><span class="line">        <span class="keyword">if</span> p.Conn != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p.Conn.Close()      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p.c.put(p.Conn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PooledConn)</span> <span class="title">MarkUnusable</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> p.mu.Unlock()</span><br><span class="line">    p.unusable = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConnPool)</span> <span class="title">wrapConn</span><span class="params">(conn net.Conn)</span> <span class="title">net</span>.<span class="title">Conn</span></span> &#123;</span><br><span class="line">    p := &amp;PooledConn&#123;c: c&#125;</span><br><span class="line">    p.Conn = conn</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接池的构建需要考虑两个问题，一个就是连接创建问题，第二就是回收连接问题，创建我们用一个 <code>Factory</code> 工厂方法来表示，而回收连接可以利用 <code>golang</code> 中的通道机制（ <code>chan</code> ）来进行储存。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Factory <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(net.Conn, error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">ConnPool</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">    mu sync.RWMutex</span><br><span class="line">    conns <span class="keyword">chan</span> net.Conn</span><br><span class="line">    factroy Factory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化连接池时，我们先建立 <code>initialCap</code> 个连接用于刚开始时使用，具体创建可以使用 <code>factory</code> 产生 <code>TCP</code> 连接。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConnPool</span><span class="params">(initialCap, maxCap <span class="keyword">int</span>, factory Factory)</span> <span class="params">(Pool, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> initialCap &lt; <span class="number">0</span> || maxCap &lt;= <span class="number">0</span> || initialCap &gt; maxCap &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> , errors.New(<span class="string">"invalid capacity settings"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c := &amp;ConnPool&#123;</span><br><span class="line">        conns: <span class="built_in">make</span>(<span class="keyword">chan</span> net.Conn, maxCap),</span><br><span class="line">        factory: factory,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; initialCap; i++ &#123;</span><br><span class="line">        conn, err := factory()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            c.Close()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"factory is not able to fill the pool: %s"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        c.conns &lt;- conn</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConnPool)</span> <span class="title">getConnsAndFactory</span><span class="params">()</span> <span class="params">(<span class="keyword">chan</span> net.Conn, Factory)</span></span>&#123;</span><br><span class="line">    c.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">    conns := c.conns</span><br><span class="line">    factory := c.factory</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当客户端使用完一次 <code>TCP</code> 连接后，会主动调用 <code>Close</code> 来关闭此次连接，由于我们重新定义了 <code>Close</code> 函数，当调用 <code>Close</code> 时，连接不会直接关闭而是会重新放回连接池中供其他部分代码使用，从而达到重复使用的目的，如果此时连接池已满，则直接释放该连接。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConnPool)</span> <span class="title">put</span><span class="params">(conn net.Conn)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> conn == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"connection is nil, rejecting"</span>)</span><br><span class="line">    &#125; </span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.conns == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> conn.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> c.conns &lt;- conn:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> conn.Close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的结构体 <code>ConnPool</code> 实现了 <code>Pool</code> 接口。在 <code>Get</code> 方法中我们先得到具体用于存储连接的通道 <code>conns</code> 和用于制造连接的工厂方法 <code>factory</code>，然后试着去通道中拿，和 <code>put</code> 方法类似，如果该通道中还有空闲的 <code>TCP</code> 连接，则直接拿出并经过封装后（ <code>wrapConn</code> ）使用，如果没有则使用工厂方法新建一个 <code>TCP</code> 连接再经过封装后使用。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConnPool)</span> <span class="title">Get</span><span class="params">()</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line">    conns, factory := c.getConnsAndFactory()</span><br><span class="line">    <span class="keyword">if</span> conns == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrClosed</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> conn := &lt;- conns:</span><br><span class="line">        <span class="keyword">if</span> conn == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ErrClosed</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c.wrapConn(conn), <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        conn, err := factory()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c.wrapConn(conn), <span class="literal">nil</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConnPool)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    conns := c.conns</span><br><span class="line">    c.conns. = <span class="literal">nil</span></span><br><span class="line">    c.factory = <span class="literal">nil</span></span><br><span class="line">    c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> conns == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(conns)</span><br><span class="line">    <span class="keyword">for</span> conn := <span class="keyword">range</span> conns &#123;</span><br><span class="line">        conn.Close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConnPool)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    conns, _ := c.getConnsAndFactory()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(conns)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接池的使用"><a href="#连接池的使用" class="headerlink" title="连接池的使用"></a>连接池的使用</h2><p>由于具体的连接逻辑是由客户端决定的，所以 <code>factory</code> 应该由使用者定义。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">factory := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(net.Conn, error)</span></span> &#123;<span class="keyword">return</span> net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:8080"</span>)&#125;</span><br></pre></td></tr></table></figure><p>我们通过 <code>pool.NewConnPool</code> 来新建一个连接池，这里我们指定连接池中初始的连接个数为5，而最大的连接个数为30。通过 <code>p.Get</code> 来获得可用的连接，<code>Get</code> 方法会根据当前池中的情况返回连接，如果池中没有可用的连接则用 <code>factory</code> 方法新建一个，此时系统开销较大，但是这种情况并不常见，所以基本可以忽略不计。如果池中有可用连接，则直接返回，此时开销较小。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p, err := pool.NewConnPool(<span class="number">5</span>, <span class="number">30</span>, factory)</span><br><span class="line"></span><br><span class="line">conn, err := p.Get()</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br></pre></td></tr></table></figure><p>下面给出真正关闭该连接的方法，因为我们重载了 <code>Close</code> 方法，直接调用 <code>Close</code> 只会将此连接放回连接池中，所以需要在真正关闭前将此连接设为不可用（ <code>MarkUnusable</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pc, ok := conn.(*pool.PooledConn); ok &#123;</span><br><span class="line">    pc.MarkUnusable()</span><br><span class="line">    pc.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Connection-Pool&quot;&gt;&lt;a href=&quot;#Connection-Pool&quot; class=&quot;headerlink&quot; title=&quot;Connection Pool&quot;&gt;&lt;/a&gt;Connection Pool&lt;/h1&gt;&lt;p&gt;因为 &lt;code&gt;TCP&lt;/code
      
    
    </summary>
    
    
  </entry>
  
</feed>
