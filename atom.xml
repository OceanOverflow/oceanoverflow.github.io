<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Whyyy</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://oceanoverflow.github.io/"/>
  <updated>2018-05-15T11:36:24.836Z</updated>
  <id>https://oceanoverflow.github.io/</id>
  
  <author>
    <name>Yangyi, Yi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Connection Limiter</title>
    <link href="https://oceanoverflow.github.io/2018/05/15/ConnectionLimiter/"/>
    <id>https://oceanoverflow.github.io/2018/05/15/ConnectionLimiter/</id>
    <published>2018-05-15T02:18:24.000Z</published>
    <updated>2018-05-15T11:36:24.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Connection-Limiter"><a href="#Connection-Limiter" class="headerlink" title="Connection Limiter"></a>Connection Limiter</h1><p>作为服务提供商，我们肯定是希望越多客户使用我们的服务越好，为此我们不惜花大价钱雇程序员来搞高并发服务器编程，砸很多的钱买最好的服务器，但是总有些无良用户想要和我们作对，搞很多 <code>HTTP</code> 连接请求恶意占用服务器的资源，导致其他用户的服务体验下降，从而最终导致客户的流失，这种情况我们肯定是希望极力避免的。</p><p>一般来说，正常的客户端（人为操作）不会在短时间内对同一服务发送过多的请求，只有想要实施恶意攻击行为的客户端（例如爬虫）才会同时发送很多请求来占用服务器的资源。为了避免这种情况的发生，我们需要限制同一个 <code>IP</code> 地址的请求数量。</p><p>实现连接限制的思路比较简单，我们通过一个 <code>map</code> 来记录来自同一个 <code>IP</code> 地址的 <code>HTTP</code> 请求的个数，如果在正常范围内，则给予该客户端正常的服务，如果超过上限，此时该客户端被怀疑正在进行爬虫之类的非善意行为，对此我们返回一个错误并拒绝服务该请求。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ConnLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    connections      <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span></span><br><span class="line">    maxConnections   <span class="keyword">int64</span></span><br><span class="line">    totalConnections <span class="keyword">int64</span></span><br><span class="line">    next             http.Handler</span><br><span class="line">    errHandler       ErrorHandler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(next http.Handler, maxConnections <span class="keyword">int64</span>)</span> <span class="params">(*ConnLimiter, error)</span></span> &#123;</span><br><span class="line">    cl := &amp;ConnLimiter &#123;</span><br><span class="line">        maxConnections: maxConnections,</span><br><span class="line">        connections: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>),</span><br><span class="line">        next: next,</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> cl.errHandler == <span class="literal">nil</span> &#123;</span><br><span class="line">        cl.errHandler = defaultErrHandler</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cl, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们是对同一个<code>IP</code> 地址设置连接限制，故对于每个请求，通过读取请求 <code>http.Request</code> 中的 <code>RemoteAddr</code> 来获取 <code>IP</code> 地址。但是上有政策，下游对策，很多写爬虫的人通过代理 <code>IP</code> 池来规避这种审查，这里我们先不讨论如何处理这种情况。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">extractClientIP</span><span class="params">(req *http.Request)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">    vals := strings.SplitN(req.RemoteAddr, <span class="string">":"</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(vals[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, <span class="number">0</span>, fmt.Errorf(<span class="string">"Failed to parse client IP: %v"</span>, req.RemoteAddr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vals[<span class="number">0</span>], <span class="number">1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还需要定义当同一个 <code>IP</code> 地址的连接数量超过最高连接数量的错误 <code>MaxConnError</code> 以及处理该错误的方法。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MaxConnError <span class="keyword">struct</span> &#123;</span><br><span class="line">    max <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MaxConnError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"max connections reached: %d"</span>, m.max)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConnErrHandler <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConnErrHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    statusCode := http.StatusInternalServerError</span><br><span class="line">    w.WriteHeader(statusCode)</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(http.StatusText(statusCode)))   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultErrHandler = &amp;ConnErrHandler&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>acquire</code> 和 <code>release</code> 方法在加锁的条件下对 <code>map</code> 进行操作，这是因为在并发情况下对同一个数据进行读写操作时，会发生数据竞争的情况，所以需要使用 <code>sync.Mutex</code> 来对数据读写进行保护。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl *ConnLimiter)</span> <span class="title">acquire</span><span class="params">(token <span class="keyword">string</span>, amount <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    cl.Lock()</span><br><span class="line">    <span class="keyword">defer</span> cl.Unlock()</span><br><span class="line"></span><br><span class="line">    connections := cl.connections[token]</span><br><span class="line">    <span class="keyword">if</span> connections &gt;= cl.maxConnections &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;MaxConnError&#123;max: cl.maxConnections&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cl.connections[token] += amount</span><br><span class="line">    cl.totalConnections += amount</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl *ConnLimiter)</span> <span class="title">release</span><span class="params">(token <span class="keyword">string</span>, amount <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    cl.Lock()</span><br><span class="line">    <span class="keyword">defer</span> cl.Unlock()</span><br><span class="line"></span><br><span class="line">    cl.connections[token] -= amount</span><br><span class="line">    cl.totalConnections -= amount</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> cl.connections[token] == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(cl.connections, token)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在提供服务（ <code>ServeHTTP</code> ）之前，我们通过 <code>acquire</code> 判断该客户端是否有资格获得服务，如果有资格则使用正常的 <code>handler</code> 来处理，否则则使用 <code>errHandler</code> 来处理，最后服务完了需要将相关资源释放（ <code>release</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl *ConnLimiter)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    token, amount, err := extractClientIP(r)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Errorf(<span class="string">"failed to extract source of the connection: %v"</span>, err)</span><br><span class="line">        cl.errHandler.ServeHTTP(w, r)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = cl.acquire(token, amount); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Debugf(<span class="string">"limiting request source %s: %v"</span>, token, err)</span><br><span class="line">        cl.errHandler.ServeHTTP(w, r)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> cl.release(token, amount)</span><br><span class="line"></span><br><span class="line">    cl.next.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl *ConnLimiter)</span> <span class="title">Wrap</span><span class="params">(h http.Handler)</span></span> &#123;</span><br><span class="line">    cl.next = h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Connection-Limiter&quot;&gt;&lt;a href=&quot;#Connection-Limiter&quot; class=&quot;headerlink&quot; title=&quot;Connection Limiter&quot;&gt;&lt;/a&gt;Connection Limiter&lt;/h1&gt;&lt;p&gt;作为服务提供
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Terminal UI</title>
    <link href="https://oceanoverflow.github.io/2018/05/14/TerminalUI/"/>
    <id>https://oceanoverflow.github.io/2018/05/14/TerminalUI/</id>
    <published>2018-05-14T14:49:04.000Z</published>
    <updated>2018-05-15T11:43:47.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Terminal-UI"><a href="#Terminal-UI" class="headerlink" title="Terminal UI"></a>Terminal UI</h1><p>之前用命令行版本的网易云音乐来听歌（ <code>musicbox</code> ，在 <code>github</code> 上可以搜索到），觉得实在是太 <code>geek</code> 了，但它是用 <code>python</code> 写的，略微容易崩，所以决定试着用 <code>golang</code> 仿造一个，第一步肯定是模仿它的 <code>UI</code> 了，在浏览器中我们用三元老 <code>HTML/CSS/JS</code> 可以很容易撸出一套能看的前端界面来，但估计没几个人知道命令行版本的 <code>UI</code> 应该怎么搞，其实说实话我也不知道，大概搜了一下，发现用 <code>termui</code> 这个库就可以比较轻松撸出一个与 <code>musicbox</code> 类似的界面了，下面我们来看一下如何用代码来实现吧。</p><h2 id="termui-安装"><a href="#termui-安装" class="headerlink" title="termui 安装"></a>termui 安装</h2><p>一般来说我们可以使用 <code>go get</code> 来进行获取安装，但最好使用 <code>dep</code> 来帮助我们管理项目的相关依赖。</p><p><code>go get -u github.com/gizak/termui</code></p><p>然后在代码中 <code>import</code> 就可以了。</p><p><code>import &quot;github.com/gizak/termui&quot;</code></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在使用 <code>termui</code> 时需要先进行初始化（ <code>termui.Init()</code> ），并且最后还要释放资源 <code>defer termui.Close()</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">err := termui.Init()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> termui.Close()</span><br></pre></td></tr></table></figure><h2 id="界面相关数据准备"><a href="#界面相关数据准备" class="headerlink" title="界面相关数据准备"></a>界面相关数据准备</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">strs := []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"   0. 排行榜"</span>,</span><br><span class="line">    <span class="string">"   1. 艺术家"</span>,</span><br><span class="line">    <span class="string">"   2. 新碟上架"</span>,</span><br><span class="line">    <span class="string">"   3. 精选歌单"</span>,</span><br><span class="line">    <span class="string">"   4. 我的歌单"</span>,</span><br><span class="line">    <span class="string">"   5. 主播电台"</span>,</span><br><span class="line">    <span class="string">"   6. 每日推荐"</span>,</span><br><span class="line">    <span class="string">"   7. 私人FM"</span>,</span><br><span class="line">    <span class="string">"   8. 搜索"</span>,</span><br><span class="line">    <span class="string">"   9. 帮助"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">off := []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"   0. 排行榜"</span>,</span><br><span class="line">    <span class="string">"   1. 艺术家"</span>,</span><br><span class="line">    <span class="string">"   2. 新碟上架"</span>,</span><br><span class="line">    <span class="string">"   3. 精选歌单"</span>,</span><br><span class="line">    <span class="string">"   4. 我的歌单"</span>,</span><br><span class="line">    <span class="string">"   5. 主播电台"</span>,</span><br><span class="line">    <span class="string">"   6. 每日推荐"</span>,</span><br><span class="line">    <span class="string">"   7. 私人FM"</span>,</span><br><span class="line">    <span class="string">"   8. 搜索"</span>,</span><br><span class="line">    <span class="string">"   9. 帮助"</span>,</span><br><span class="line">&#125;</span><br><span class="line">on := []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"[-&gt; 0. 排行榜](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 1. 艺术家](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 2. 新碟上架](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 3. 精选歌单](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 4. 我的歌单](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 5. 主播电台](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 6. 每日推荐](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 7. 私人FM](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 8. 搜索](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 9. 帮助](fg-cyan)"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义界面参数"><a href="#定义界面参数" class="headerlink" title="定义界面参数"></a>定义界面参数</h2><p>在使用 <code>termui</code> 时，我们需要确定界面元素及其属性，以及它在命令行中的排版，其实 <code>UI</code> 就是对数据的一种呈现，反正就是你觉得怎么好看就怎么来。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls := termui.List()</span><br><span class="line">ls.Items = strs</span><br><span class="line">ls.ItemFgColor = termui.ColorWhite</span><br><span class="line">ls.BorderLabel = <span class="string">"网易云音乐"</span></span><br><span class="line">ls.Height = <span class="number">12</span></span><br><span class="line">ls.Width = <span class="number">20</span></span><br><span class="line">ls.Y = <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="termui对事件的处理"><a href="#termui对事件的处理" class="headerlink" title="termui对事件的处理"></a>termui对事件的处理</h2><p><code>termui</code> 对事件的处理和 <code>HTTP</code> 处理事件的做法类似，我们需要对不同的事件注册回调函数，例如检测到用户输入 <code>q</code> ，我们注册一个类似的回调函数就可以了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">termui.Handle(<span class="string">"/sys/kbd/q"</span>, <span class="function"><span class="keyword">func</span><span class="params">(termui.Event)</span></span> &#123;</span><br><span class="line">    termui.StopLoop()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>相关事件可以是键盘输入，界面点击，窗口伸缩甚至可以是自定义事件。相关事件触发后，对应的数据可能会发生改变，这样以来用户界面就需要发生改变，我们可以使用 <code>termui.Render</code> 对界面重新进行渲染。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cursor := <span class="number">0</span></span><br><span class="line">termui.Render(ls)</span><br><span class="line">termui.Handle(<span class="string">"/sys/kbd/j"</span>, <span class="function"><span class="keyword">func</span><span class="params">(termui.Event)</span></span> &#123;</span><br><span class="line">    strs[cursor%<span class="built_in">len</span>(strs)] = off[cursor%<span class="built_in">len</span>(strs)]</span><br><span class="line">    cursor++</span><br><span class="line">    <span class="keyword">if</span> cursor == <span class="built_in">len</span>(strs) &#123;</span><br><span class="line">        cursor = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    strs[cursor%<span class="built_in">len</span>(strs)] = on[cursor%<span class="built_in">len</span>(strs)]</span><br><span class="line">    termui.Render(ls)</span><br><span class="line">&#125;)</span><br><span class="line">termui.Handle(<span class="string">"/sys/kbd/k"</span>, <span class="function"><span class="keyword">func</span><span class="params">(termui.Event)</span></span> &#123;</span><br><span class="line">    strs[cursor%<span class="built_in">len</span>(strs)] = off[cursor%<span class="built_in">len</span>(strs)]</span><br><span class="line">    cursor--</span><br><span class="line">    <span class="keyword">if</span> cursor &lt; <span class="number">0</span> &#123;</span><br><span class="line">        cursor = <span class="built_in">len</span>(strs) - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    strs[cursor%<span class="built_in">len</span>(strs)] = on[cursor%<span class="built_in">len</span>(strs)]</span><br><span class="line">    termui.Render(ls)</span><br><span class="line">&#125;)</span><br><span class="line">termui.Loop()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Terminal-UI&quot;&gt;&lt;a href=&quot;#Terminal-UI&quot; class=&quot;headerlink&quot; title=&quot;Terminal UI&quot;&gt;&lt;/a&gt;Terminal UI&lt;/h1&gt;&lt;p&gt;之前用命令行版本的网易云音乐来听歌（ &lt;code&gt;musicbox&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Job Dispatcher</title>
    <link href="https://oceanoverflow.github.io/2018/05/13/JobDispatcher/"/>
    <id>https://oceanoverflow.github.io/2018/05/13/JobDispatcher/</id>
    <published>2018-05-13T13:34:24.000Z</published>
    <updated>2018-05-15T11:48:32.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Job-Dispatcher"><a href="#Job-Dispatcher" class="headerlink" title="Job Dispatcher"></a>Job Dispatcher</h1><p>当处理大量计算密集型任务时，为了提高工作效率，常常会引入多台服务器同时进行处理，但是不同的服务器之间并不清楚自己该处理哪个任务，也就是说服务器自己并不能保证自己处理的任务和别人的任务是不一样的。为了解决上述问题，我们引入 <code>Job Dispatcher</code> 模型。</p><p>我们把处理任务的服务器称为 <code>Worker</code> ，而把分配任务的服务器称为<code>Dispatcher</code> 或者 <code>Master</code> 。<code>Dispatcher</code> 负责给当前处于空闲状态的 <code>Worker</code> 分配任务 （ <code>Job</code> ），当其处理完分配的任务之后，为了不让自己的 <code>CPU</code> 闲置，<code>Worker</code> 会通知 <code>Dispather</code> 自己是可用的（ <code>available</code> ） ，然后 <code>Dispatcher</code> 就可以继续向 <code>Worker</code> 分配任务，直到所有任务全都完成。这样的模型非常 <code>scalable</code> ，引入的 <code>Worker</code> 数量越多，任务完成得越快。</p><h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><p>一个任务我们用结构体 <code>Job</code> 来表示，现在对于此结构体中有什么我们并不关心，这个需要由业务逻辑具体定义。</p><p> <code>Worker</code> 中有三个 <code>channel</code> ，分别用于暂停，接收任务和通知 <code>Dispatcher</code> 任务完成用的。</p><p><code>Worker</code> 肯定需要某种机制停止退出，我们用一个 <code>exit chan struct{}</code> 通道来接收停止信号，如果该通道中收到了停止信号，也就可以说明今天的任务已经全部完成了，<code>Worker</code> 可以回家休息了。</p><p><code>Jobs chan Job</code> 通道很简单，当然就是用于接受任务的啦，相对来说，任务可是做不完的，一个任务做完下一个任务就马不停蹄的赶来了，所以用通道来表示可以说是再合适不过了。</p><p>最后来看一下最复杂的一个通道 <code>WorkerPool chan chan Job</code> ，这啥玩意啊，通道的通道？想想就头大，外层的通道的中包含了 <code>chan Job</code> ，也就是上面说过的 <code>Jobs</code> 通道，其实就代表 <code>Worker</code> 本身， 如果一个 <code>Job</code> 处理完了， <code>Worker</code> 就会处于空闲状态，所以就可以把它放在 <code>WorkerPool</code> 中等待 <code>Dispatcher</code> 来调度了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">    Payload <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">    WorkerPool <span class="keyword">chan</span> <span class="keyword">chan</span> Job</span><br><span class="line">    Jobs       <span class="keyword">chan</span> Job</span><br><span class="line">    exit       <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorker</span><span class="params">(workerPool <span class="keyword">chan</span> <span class="keyword">chan</span> Job)</span> *<span class="title">Worker</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Worker&#123;</span><br><span class="line">        WorkerPool: workerPool,</span><br><span class="line">        Jobs:       <span class="built_in">make</span>(<span class="keyword">chan</span> Job),</span><br><span class="line">        exit:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Stop</code> 方法向 <code>exit</code> 通道发送信号，这样一来 <code>Start</code> 方法中的 <code>select</code> 语句的第二个 <code>case</code> 就会被执行，<code>Worker</code> 就可以退出了。在 <code>Start</code> 方法中，<code>w.WorkerPool &lt;- w.Jobs</code> 会向 <code>WorkerPool</code> 中注册它自己，也就相当于向 <code>Dispatcher</code> 申明自己已经处于空闲状态，随时等待被调度。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            w.WorkerPool &lt;- w.Jobs</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> job := &lt;- w.Jobs:</span><br><span class="line">                <span class="comment">// do some heavy job here</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-w.exit:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        w.exit &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h2><p>所有的任务都是从外界来的（此处我们选择从 <code>JobQueue</code> 中读取），任务到来时并不会直接分配给 <code>Worker</code> ，而是先经过 <code>Dispatcher</code> 的魔爪，<code>Dispatcher</code> 会先判断哪个 <code>Worker</code> 处于空闲状态，然后再分配给空闲的 <code>Worker</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> JobQueue <span class="keyword">chan</span> Job</span><br></pre></td></tr></table></figure><p><code>Dispatcher</code> 结构体中的 <code>WorkerPool chan chan Job</code> 是任务调度实现的核心，我们上述 <code>Worker</code> 中的和 <code>Dispatcher</code> 中的其实是一个东西，<code>Worker</code> 中的是对 <code>Dispatcher</code> 中的一个引用而已。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dispatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">    WorkerPool <span class="keyword">chan</span> <span class="keyword">chan</span> Job</span><br><span class="line">    MaxWorkers <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDispatcher</span><span class="params">(maxWorkers <span class="keyword">int</span>)</span> *<span class="title">Dispatcher</span></span> &#123;</span><br><span class="line">    pool := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> Job, maxWorkers)</span><br><span class="line">    <span class="keyword">return</span> &amp;Dispatcher&#123;</span><br><span class="line">        WorkerPool: pool,</span><br><span class="line">        MaxWorkers: maxWorkers,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Run</code> 方法中起了 <code>MaxWorkers</code> 个 <code>Worker</code> 等待 <code>Dispatcher</code> 给自己分配任务。</p><p>在 <code>dispatch</code> 方法中，<code>Dispatcher</code> 会不断的从 <code>JobQueue</code> 中读取任务，并在 <code>WorkerPool</code> 中选取一个空闲的 <code>Worker</code> （ <code>worker := &lt;-d.WorkerPool</code> ），然后将任务分配给它（ <code>worker &lt;- job</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dispatcher)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; d.MaxWorkers; i++ &#123;</span><br><span class="line">        worker := NewWorker(d.WorkerPool)</span><br><span class="line">        worker.Start()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> d.dispatch()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dispatcher)</span> <span class="title">dispatch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> job := &lt;- JobQueue:</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(job Job)</span></span> &#123;</span><br><span class="line">                worker := &lt;-d.WorkerPool</span><br><span class="line">                worker &lt;- job</span><br><span class="line">            &#125;(job)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Job-Dispatcher&quot;&gt;&lt;a href=&quot;#Job-Dispatcher&quot; class=&quot;headerlink&quot; title=&quot;Job Dispatcher&quot;&gt;&lt;/a&gt;Job Dispatcher&lt;/h1&gt;&lt;p&gt;当处理大量计算密集型任务时，为了提高工作效率
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Reverse Proxy</title>
    <link href="https://oceanoverflow.github.io/2018/05/12/ReverseProxy/"/>
    <id>https://oceanoverflow.github.io/2018/05/12/ReverseProxy/</id>
    <published>2018-05-12T13:30:04.000Z</published>
    <updated>2018-05-15T11:57:53.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reverse-Proxy"><a href="#Reverse-Proxy" class="headerlink" title="Reverse Proxy"></a>Reverse Proxy</h1><p>在正常的 <code>HTTP</code> 服务流程中，客户端向服务器发送 <code>HTTP</code> 请求，服务器收到后会向客户端返回一个 <code>HTTP</code> 答复。但在实际生产环境中，真正处理请求的服务器和客户端之间通常还会引入一个中介，也就是反向代理服务器，在引入了反向代理服务器之后，客户端会先将请求发送给反向代理服务器，反向代理收到该 <code>HTTP</code> 请求后，并不会自己亲自处理该请求，而是将请求转发给真正的处理业务逻辑的服务器，让它去处理，业务逻辑服务器处理完之后，会先将答复返回给反向代理服务器，再由反向代理服务器返回给客户端。</p><p>生活中常见的 <code>NGINX</code> 就常常作为反向代理服务器来使用。那么你可能会问，传统 <code>C/S</code> 模型难道不够好吗，还非要引入一个不知道什么鬼的反向代理来捣乱，引入之后只会把架构变得更复杂，有啥好处？（傲娇状）其实原因很简单，第一反向代理服务器可以当作防火墙来用，它为真正的业务逻辑服务器与外界可能的恶意攻击之间提供了一个屏障，尤其是像银行这种对安全性要求极高的金融机构无论加几个这样的防火墙都不会嫌多。第二点就是它可以提供负载均衡功能，通过使用不同的策略将请求转发给不同的服务器，以达到负载均衡的目的。</p><p>幸运的是，引入反向代理，并不会改变传统的 <code>C/S</code> 编程模型，因为客户端无法感知反向代理服务器的存在，他们只会觉得反向代理服务器就是真正处理业务逻辑的服务器。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/67/Reverse_proxy_h2g2bob.svg/1200px-Reverse_proxy_h2g2bob.svg.png" alt="Reverse Proxy"></p><p>下面我们来实现一个简单的反向代理服务器吧，虽然听着很恐怖，但是不用慌，强大的 <code>Golang</code> 标准库已经实现了反向代理的功能了。<code>httputil</code> 中提供的 <code>ReverseProxy</code> 结构体具有将请求重定向的能力（ <code>Director</code> ），也具有将答复修改的能力（ <code>ModifyResponse</code> ），最重要的是，可以通过 <code>Transport</code> 这个 <code>http.RoundTripper</code> 将我们的代理请求发送出去。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReverseProxy <span class="keyword">struct</span> &#123;</span><br><span class="line">    Director      <span class="function"><span class="keyword">func</span><span class="params">(*http.Request)</span></span></span><br><span class="line"><span class="function">    <span class="title">Transport</span>     <span class="title">http</span>.<span class="title">RoundTripper</span></span></span><br><span class="line"><span class="function">    <span class="title">FlushInterval</span> <span class="title">time</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function">    <span class="title">ErrorLog</span>      *<span class="title">log</span>.<span class="title">Logger</span></span></span><br><span class="line"><span class="function">    <span class="title">BufferPool</span>    <span class="title">BufferPool</span></span></span><br><span class="line"><span class="function">    <span class="title">ModifyReponse</span> <span class="title">func</span><span class="params">(*http.Response)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">RoundTripper</span> <span class="title">interface</span></span> &#123;</span><br><span class="line">    RoundTrip(*http.Request) (*http.Response, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为一个代理服务器，虽然不直接处理业务逻辑，但是最基本的对请求的处理和答复的功能还是要有的，与一般的 <code>HTTP</code> 服务器类似，我们的反向代理服务器 <code>ReverseProxy</code> 也需要有 <code>ServeHTTP(http.ResponseWriter, *http.Request)</code> 这样的方法。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(http.ResponseWriter, *http.Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以为了实现代理请求的功能，我们需要定义一个结构体 <code>handler</code> ，使其实现 <code>ServeHTTP(http.ResponseWriter, *http.Request)</code> 方法，在该方法中我们通过 <code>httputil.NewSingleHostReverseProxy</code> 来构造一个反向代理，并将请求通过 <code>proxy.ServeHTTP(w, r)</code> 方法将请求代理到随机的（随机是为了实现负载均衡）服务器上。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">servers := []<span class="keyword">string</span>&#123;</span><br><span class="line">     <span class="string">"111.222.111.222"</span>,</span><br><span class="line">     <span class="string">"222.111.222.111"</span>,</span><br><span class="line">     <span class="string">"111.233.111.233"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> handler <span class="keyword">struct</span> &#123;</span><br><span class="line">    reverseProxy <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *handler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    addr := servers[rand.Intn(<span class="built_in">len</span>(servers))]</span><br><span class="line">    remote, err := url.Parse(<span class="string">"http://"</span> + addr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    proxy := httputil.NewSingleHostReverseProxy(remote)</span><br><span class="line">    proxy.ServeHTTP(w, r)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们申明一个 <code>http.Server</code> ，在 <code>StartServer</code> 中我们监听指定的端口（ <code>bind</code> ），其对应的 <code>Handler</code> 就是我们之前实现的 <code>handler</code> 结构体，用于把请求代理到 <code>remote</code> 上去，这样以来一个基本的反向代理服务器就实现好了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> srv http.Server</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartServer</span><span class="params">(bind <span class="keyword">string</span>, remote <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"Listening on %s, forwarding to %s"</span>, bind, remote)</span><br><span class="line">    h := &amp;handler&#123;reverseProxy: remote&#125;</span><br><span class="line">    srv.Addr = bind</span><br><span class="line">    srv.Handler = h</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := srv.ListenAndServe(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(<span class="string">"ListenAndServe:"</span> err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StopServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := srv.Shutdown(<span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    StartServer(<span class="string">":8080"</span>, <span class="string">"remote:8080"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中的采用的负载均衡算法只用了非常简单的随机选取策略，这只适合每台服务器性能差别不大的情况，如果服务器之间性能差距较大，我们可以使用 <code>Weighted Round Robin</code> 这样的负载均衡算法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Reverse-Proxy&quot;&gt;&lt;a href=&quot;#Reverse-Proxy&quot; class=&quot;headerlink&quot; title=&quot;Reverse Proxy&quot;&gt;&lt;/a&gt;Reverse Proxy&lt;/h1&gt;&lt;p&gt;在正常的 &lt;code&gt;HTTP&lt;/code&gt; 服务流
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Advisory Lock</title>
    <link href="https://oceanoverflow.github.io/2018/05/12/AdvisoryLock/"/>
    <id>https://oceanoverflow.github.io/2018/05/12/AdvisoryLock/</id>
    <published>2018-05-12T05:26:04.000Z</published>
    <updated>2018-05-15T11:33:27.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Advisory-Lock"><a href="#Advisory-Lock" class="headerlink" title="Advisory Lock"></a>Advisory Lock</h1><p>很多时候，在操作系统中，对于特定应用，我们只希望起一个进程实例，但是操作系统并没有限制同一个应用进程的个数，也就是说，在每个应用运行前，我们需要检测进程是否存在。</p><p>那么如何检测进程是否已经存在了呢，我们可以在进程启动时，生成一个以 <code>.pid</code> 结尾的文件，并向这个文件上加一个建议性锁（ <code>advisory lock</code> ），这样如果有第二个这个的进程起来，它会试着去打开这个 <code>.pid</code> 文件，并试着向这个文件加建议性锁，但由于先起来的进程已经加过锁了，所以第二个进程就没有办法再加锁了，第二个进程知道自己不是第一个起起来的，所以就选择退出。</p><p>等等，刚才说的建议性锁又是什么呢，建议性锁就好像人们指定的一系列规则， 例如交通法规建议人们红灯停，绿灯行，这里的红绿灯就是一个建议性锁，但是总有不听话的人不遵守这些规则，也就是说无视建议性锁的存在。建议性锁并不是强制性的，进程可以选择不去遵守它。</p><p>上面进程的例子就是这样，第二个进程如果观测到文件已经上锁了，如果它不是恶意进程，那么它会选择尊重规则选择退出。</p><h2 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h2><p>下面我们来实现一个文件锁，文件锁的本质就是文件，所以我们选择对 <code>os.File</code> 做一层封装，然后对它添加额外的行为使其成为一个真正的文件锁。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LockFile <span class="keyword">struct</span> &#123;</span><br><span class="line">    *os.File</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLockFile</span><span class="params">(file *os.File)</span> *<span class="title">LockFile</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;LockFile&#123;file&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对文件上锁和解锁的过程其实就是利用系统调用 <code>syscall.Flock</code>，下面是c语言中的系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_SH 1 <span class="comment">/* shared lock */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_EX 2 <span class="comment">/* exclusive lock */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_NB 4 <span class="comment">/* don't block when locking */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_UN 8 <span class="comment">/* unlock */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">flock(<span class="keyword">int</span> fd, <span class="keyword">int</span> operation)</span><br></pre></td></tr></table></figure><p>建议性锁分为两大类：共享锁（ <code>SH</code> ）和专有锁（ <code>EX</code> ），这里我们采用专有锁，也就是利用 <code>LOCK_EX</code> 选项，如果文件已经上过锁了，再次尝试对该文件上锁时，操作会被阻塞，为了避免调用此系统调用的进程被阻塞，我们在系统调用时增加一个 <code>LOCK_NB</code> 选项，也就是非阻塞（ <code>non blocking</code> ）的意思，指定该选项后如果尝试上锁时，文件已经上过锁了，此时则则不会发生阻塞而是返回一个 <code>EWOULDBLOCK</code> 错误，当对文件解锁时，只需要在系统调用时指定 <code>LOCK_UN</code> 选项就可以了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ErrWouldBlock = errors.New(<span class="string">"Resource temporarily unavailable"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *LockFile)</span> <span class="title">Lock</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lockFile(file.Fd())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lockFile</span><span class="params">(fd <span class="keyword">uintptr</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    err := syscall.Flock(<span class="keyword">int</span>(fd), syscall.LOCK_EX|syscall.LOCK_NB)</span><br><span class="line">    <span class="keyword">if</span> err == syscall.EWOULDBLOCK &#123;</span><br><span class="line">        err = ERRWouldBlock</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *LockFile)</span> <span class="title">Unlock</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unlockFile(file.Fd())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unlockFile</span><span class="params">(fd <span class="keyword">uintptr</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    err := syscall.Flock(<span class="keyword">int</span>(fd), syscall.LOCK_UN)</span><br><span class="line">    <span class="keyword">if</span> err == syscall.EWouldBLOCK &#123;</span><br><span class="line">        err = ErrWouldBlock</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>OpenLockFile</code> 方法很简单，就是对 <code>os.OpenFile</code> 方法进行了一层封装，将此方法返回的 <code>file</code> 封装为<code>LockFile</code> 返回供接下去使用。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenLockFile</span><span class="params">(name <span class="keyword">string</span>, perm os.FileMode)</span> <span class="params">(lock *LockFile, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> file *os.File</span><br><span class="line">    <span class="keyword">if</span> file, err = os.OpenFile(name, os.O_RWWR|os.O_CREATE, perm); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        lock = &amp;LockFile&#123;file&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程存在性检测"><a href="#进程存在性检测" class="headerlink" title="进程存在性检测"></a>进程存在性检测</h2><p>文件上锁可以用作进程存在性检测，我们在进程创建时生成一个以 <code>.pid</code> 结尾的文件，并向该文件中写入当前进程的进程号，下面的 <code>WritePid</code> 方法就将当前进程的进程号写入文件起始位置，而 <code>ReadPid</code> 则将此文件中存储的 <code>pid</code> 读取出来，注意这里无论是读操作还是写操作都会先将文件的指针定位到最开始的位置（通过 <code>file.Seek(0, os.SEEK_SET)</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *LockFile)</span> <span class="title">WritePid</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err = file.Seek(<span class="number">0</span>, os.SEEK_SET); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fileLen <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> fileLen, err = fmt.Fprint(file, os.Getpid()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = file.Truncate(<span class="keyword">int64</span>(fileLen)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    err = file.Sync()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *LockFile)</span> <span class="title">ReadPid</span><span class="params">()</span> <span class="params">(pid <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err = file.Seek(<span class="number">0</span>, os.SEEK_SET); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    _, err = fmt.Fscan(file, &amp;pid)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *LockFile)</span> <span class="title">Remove</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err := file.Unlock(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os.Remove(file.Name())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们创建一个 <code>pid</code> 文件时候，我们需要检测其他进程是否已经存在，<code>CreatePidFile</code> 方法会使用 <code>Lock</code> 方法尝试对文件上锁，如果上锁失败，则说明已经有进程对该文件上过锁，此时则应该选择退出，如果上锁成功，则说明自己是第一个进程，并将自己的进程号写入该文件中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreatePidFile</span><span class="params">(name <span class="keyword">string</span>, perm os.FileMode)</span> <span class="params">(lock *LockFile, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> lock, err = OpenLockFile(name, perm); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = lock.Lock(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        lock.Remove()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = lock.WritePid(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        lock.Remove()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadPidFile</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(pid <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> file *os.File</span><br><span class="line">    <span class="keyword">if</span> file, err = os.OpenFile(name, os.O_RDONLY, <span class="number">0640</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    lock := &amp;LockFile&#123;file&#125;</span><br><span class="line">    pid, err = lock.ReadPid()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Advisory-Lock&quot;&gt;&lt;a href=&quot;#Advisory-Lock&quot; class=&quot;headerlink&quot; title=&quot;Advisory Lock&quot;&gt;&lt;/a&gt;Advisory Lock&lt;/h1&gt;&lt;p&gt;很多时候，在操作系统中，对于特定应用，我们只希望起一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Token Bucket</title>
    <link href="https://oceanoverflow.github.io/2018/05/11/TokenBucket/"/>
    <id>https://oceanoverflow.github.io/2018/05/11/TokenBucket/</id>
    <published>2018-05-11T14:05:04.000Z</published>
    <updated>2018-05-15T11:42:28.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Token-Bucket"><a href="#Token-Bucket" class="headerlink" title="Token Bucket"></a>Token Bucket</h1><p>学校里的宽带还是有分三六九等的，如果你钱交的多的，对应带宽自然比较高。但你想过他们是如何限制你的最高带宽的吗？其实用令牌桶（ <code>Token Bucket</code> ）这个算法就可以实现速率限制这个功能。</p><p>那么什么又是令牌桶的，简单的说就是假设你有一个专门用于放令牌的桶，桶的最大容量是有上限的，设为C，而该桶自带一个机制就是每隔固定的一段时间会产生一个令牌，一旦令牌充满了桶，桶中的令牌个数就不会再增加了。接下来是重点，如果你要进行某个需要控制速率的操作，在执行这个操作之前，必须先从桶中拿到这个操作对应的令牌个数，比如规定了操作A需要5个令牌，操作B需要10个令牌，那么如果要执行操作A，则需要从桶中拿出5个令牌，如果桶中的令牌数目不够，就需要等到令牌数量足够时才能进行A操作。由于桶中令牌产生的速率是固定的，而在进行相关操作之前，又必须获得足够数量的令牌，这样就到达了速率限制（ <code>Rate Limiting</code> ）的目的。</p><p>除了速率限制之外，令牌桶算法还具有流量整形（ <code>Traffic Shaping</code> ）的功能，因为令牌桶中的令牌是以恒定的速率产生的，所以一段时间内产生的令牌数量是固定的，如果在某一段时间消耗的令牌数量较多，也就是对应操作的数量很多，那么之后的一段时间的操作数量必定会收到限制，从整体上来看，操作的速率会比较均匀，也就是说流量是以比较均衡的速率向外发送的。</p><p><img src="https://community.cambiumnetworks.com/bstrc49894/attachments/bstrc49894/forums_pmp_450/5991/1/TokenBucket.JPG" alt="Token Bucket"></p><p>下面我们来看一下令牌桶算法的实现，由于令牌桶中非常重要的两个属性就是令牌桶的容量和令牌产生的速率，分别用 <code>capacity</code> 和 <code>rate</code> 来表示，我们使用一个通道来存储令牌，因为我们并不关心令牌的内容，所以我们使用 <code>tokens chan struct{}</code> 来表示这个桶。</p><p>在初始化令牌桶的时候，直接起一个 <code>goroutine</code> 来定时向我们的桶中放入令牌，通过 <code>time.NewTicker</code> 用于定时生产令牌，如果令牌桶满了，则<code>b.tokens &lt;- struct{}{}</code> 操作也会被阻塞。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bucket <span class="keyword">struct</span> &#123;</span><br><span class="line">    capacity <span class="keyword">int64</span></span><br><span class="line">    tokens <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    rate time.Duration</span><br><span class="line">    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBucket</span><span class="params">(rate time.Duration, capacity <span class="keyword">int64</span>)</span> *<span class="title">Bucket</span></span> &#123;</span><br><span class="line">    tokens := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, capacity)</span><br><span class="line">    b := &amp;Bucket&#123;</span><br><span class="line">        capacity: capacity,</span><br><span class="line">        tokens: tokens,</span><br><span class="line">        rate: rate,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(b *Bucket)</span></span> &#123;</span><br><span class="line">        ticker := time.NewTicker(rate)</span><br><span class="line">        <span class="keyword">for</span> _ := <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">            b.tokens &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面给出了设置时间间隔（等效为速率）的方法，时间间隔越短，对应的平均速率就越快，二者成反比关系。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span> <span class="title">GetRate</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">    b.Lock()</span><br><span class="line">    tmp := b.rate</span><br><span class="line">    b.Unlock()</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span> <span class="title">SetRate</span><span class="params">(rate time.Duration)</span></span> &#123;</span><br><span class="line">    b.Lock()</span><br><span class="line">    b.rate = rate</span><br><span class="line">    b.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在进行特定操作之前需要取出固定数量的令牌，可以形象的把令牌想象为存在银行里的钱，把令牌桶想象成银行，如果你想要买一台电脑，你就需要从银行拿出足够的钱，如果银行中没有足够的钱，你只能等到你积累了足够的钱才可以买你想要的电脑。也就是说在执行相应操作之前需要有足够多的令牌才能顺利执行。注意到这个函数是阻塞的，只有在 <code>n</code> 次 <code>&lt;-b.tokens</code> 成功之后，该函数才会返回。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span> <span class="title">withdrawTokens</span><span class="params">(n <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">int64</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">        &lt;-b.tokens</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SpendToken</code> 函数会返回一个通道，其函数内部会起一个 <code>goroutine</code> ，在该 <code>goroutine</code> 里会执行上述 <code>withdrawTokens</code> 方法，由于该函数是阻塞的，所以只有它执行完，才能将返回值放入通道 <code>c</code> 中，然后利用 <code>close(c)</code> 操作将该通道关闭，这样以来别处调用该函数的地方就可以顺利返回了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span> <span class="title">SpendToken</span><span class="params">(n <span class="keyword">uint64</span>)</span> &lt;-<span class="title">chan</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(b *Bucket, n <span class="keyword">uint64</span>, c <span class="keyword">chan</span> error)</span></span> &#123;</span><br><span class="line">        c &lt;- b.withdrawTokens(n)</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;(b, n, c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Drain</code> 方法将桶中的所有令牌一次性放光，具体该在哪里使用它要看具体需求。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span> <span class="title">Drain</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-b.tokens:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="令牌桶的使用"><a href="#令牌桶的使用" class="headerlink" title="令牌桶的使用"></a>令牌桶的使用</h2><p>使用令牌桶之前当然需要新建一个令牌桶，并指定令牌桶的容量及其平均速率。因为使用令牌桶的目的之一就是限制速率，在需要被限速的函数（ <code>RegulatedAction()</code> ）前使用 <code>&lt;-bucket.SpendToken(x)</code> ，该 <code>RegulatedAction</code> 只有等到攒满 <code>x</code> 个令牌才会执行，这样就可以达到限制速率的目的了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bucket := NewBucket(<span class="number">1</span> * time.Second, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">&lt;-bucket.SpendToken(<span class="number">10</span>)</span><br><span class="line">RegulatedAction()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Token-Bucket&quot;&gt;&lt;a href=&quot;#Token-Bucket&quot; class=&quot;headerlink&quot; title=&quot;Token Bucket&quot;&gt;&lt;/a&gt;Token Bucket&lt;/h1&gt;&lt;p&gt;学校里的宽带还是有分三六九等的，如果你钱交的多的，对应带宽自
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Stream Cipher</title>
    <link href="https://oceanoverflow.github.io/2018/05/11/StreamCipher/"/>
    <id>https://oceanoverflow.github.io/2018/05/11/StreamCipher/</id>
    <published>2018-05-11T05:10:04.000Z</published>
    <updated>2018-05-15T11:56:52.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stream-Cipher"><a href="#Stream-Cipher" class="headerlink" title="Stream Cipher"></a>Stream Cipher</h1><p>假如我们有一份很重要的文件想要从本地传输到远程客户端，因为并不想让别人看见我们传输的信息，所以需要使用某种手段将传输的数据保护起来，我们可以选择先将文件加密后再进行传输，别人收到之后再进行相应的解密操作。这种方式对于小文件来说问题倒不是很大，但是如果文件体积非常大，本地对文件进行加密和远程对文件进行解密花费的时间就会很长，这样的话时间效率就非常低了，如果我们可以对该文件边加密边传输，远程客户端也可以边接收边解密的话，时间效率就可以大幅度提升了。</p><p>下面我们来引入流加密解决上述问题，流加密有很多模式，例如 <code>CFB</code>，<code>CTR</code> ，<code>OFB</code> 等。而流加密的核心就是异或操作，使用 <code>XORKeyStream</code> 就可以进行加解密了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cipher</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stream <span class="keyword">interface</span> &#123;</span><br><span class="line">    XORKeyStream(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为加密解密肯定涉及到读写操作，所以我们用一个结构体 <code>writer</code> 实现 <code>io.Writer</code> 这个接口，里面封装了一个 <code>io.Writer</code> 和 <code>cipher.Stream</code> ，基本的思路就是将数据经过 <code>cipher.Stream</code> 的 <code>XORKeyStream</code> 方法写入 <code>io.Writer</code> 中。这里 <code>buf</code> 作为中间读操作和加密操作的缓存。</p><p>考虑到通用性，这里和下面我们使用 <code>io.Writer</code> 和 <code>io.Writer</code> 这样的接口进行抽象操作，而非使用具体的 <code>Writer</code> 或者 <code>Reader</code> 来代替。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bufSize = <span class="number">32</span> * <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> writer <span class="keyword">struct</span> &#123;</span><br><span class="line">    io.Writer</span><br><span class="line">    cipher.Stream</span><br><span class="line">    buf []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(w io.Writer, s cipher.Stream)</span> <span class="title">io</span>.<span class="title">Writer</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;writer&#123;Writer: w, Stream: s, buf: <span class="built_in">make</span>([]<span class="keyword">byte</span>, bufSize)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *writer)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    n, err := w.ReadFrom(bytes.NewBuffer(b))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(n), err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReadFrom</code> 方法使我们的 <code>writer</code> 不断从未加密的 <code>io.Reader</code> 中读取数据到 <code>buf</code> 中，再利用 <code>XORKeyStream</code> 将数据加密后写入自己的 <code>io.Writer</code> 中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *writer)</span> <span class="title">ReadFrom</span><span class="params">(r io.Reader)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        buf := w.buf</span><br><span class="line">        nr, er := r.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> nr &gt; <span class="number">0</span> &#123;</span><br><span class="line">            n += <span class="keyword">int64</span>(nr)</span><br><span class="line">            buf = buf[:nr]</span><br><span class="line">            w.XORKeyStream(buf, buf)</span><br><span class="line">            _, ew := w.Writer.Write(buf)</span><br><span class="line">            <span class="keyword">if</span> ew != <span class="literal">nil</span> &#123;</span><br><span class="line">                err = ew</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> er != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> er != io.EOF &#123;</span><br><span class="line">                err = err</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在读方面，和写的时候类似，我们也在自己定义的结构体 <code>reader</code> 中包含一个 <code>io.Reader</code> 和 <code>cipher.Stream</code> ，基本思路也是从 <code>io.Reader</code> 中读取经过加密的数据，然后再用 <code>cipher.Stream</code> 的 <code>XORKeyStream</code> 方法解密。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> reader <span class="keyword">struct</span> &#123;</span><br><span class="line">    io.Reader</span><br><span class="line">    cipher.Stream</span><br><span class="line">    buf []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(r io.Reader, s cipher.Stream)</span> <span class="title">io</span>.<span class="title">Reader</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;reader&#123;Reader: r, Stream: s, buf: <span class="built_in">make</span>([]<span class="keyword">byte</span>, bufSize)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面实现的 <code>Read</code> 方法利用 <code>io.Reader</code> 读取经过加密后的数据，再利用<code>XORKeyStream</code> 进行解密。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *reader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    n, err := r.Reader.Read(b)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    b = b[:n]</span><br><span class="line">    r.XORKeyStream(b, b)</span><br><span class="line">    <span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WriteTo</code> 方法反复使用上面的 <code>Read</code> 方法将数据解密后写入 <code>io.Writer</code> 中直到结束。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *reader)</span> <span class="title">WriteTo</span><span class="params">(w io.Writer)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        buf := r.buf</span><br><span class="line">        nr, er := r.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> nr &gt; <span class="number">0</span> &#123;</span><br><span class="line">            nw, ew := w.Write(buf[:nr])</span><br><span class="line">            n += <span class="keyword">int64</span>(nw)</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span> ew != <span class="literal">nil</span> &#123;</span><br><span class="line">                err = ew</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> er != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> er != io.EOF &#123;</span><br><span class="line">                err = er</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Stream-Cipher&quot;&gt;&lt;a href=&quot;#Stream-Cipher&quot; class=&quot;headerlink&quot; title=&quot;Stream Cipher&quot;&gt;&lt;/a&gt;Stream Cipher&lt;/h1&gt;&lt;p&gt;假如我们有一份很重要的文件想要从本地传输到远程客户端
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Connection Pool</title>
    <link href="https://oceanoverflow.github.io/2018/05/10/ConnectionPool/"/>
    <id>https://oceanoverflow.github.io/2018/05/10/ConnectionPool/</id>
    <published>2018-05-10T03:40:24.000Z</published>
    <updated>2018-05-15T11:38:26.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Connection-Pool"><a href="#Connection-Pool" class="headerlink" title="Connection Pool"></a>Connection Pool</h1><p>因为 <code>TCP</code> 连接都是客户端主动发起的，也就是说需要经过三次握手才能够进行读写操作，如果客户端需要建立连接的次数较少，那么握手需要的开销倒可以忽略不计，但是如果客户端需要建立成千上万个 <code>TCP</code> 连接，那么就需要成千上万次握手了。如果真是这样，势必会导致系统性能低下，我们引入连接池来解决多次握手的问题。</p><p>连接池（ <code>Connection Pool</code> ）在广义上来说算是资源池，我们之前讲过的  <a href="LeakyBuffer.md">LeakyBuffer</a> 也算是资源池的一种，不过 <code>LeakyBuffer</code> 的目的是反复利用内存资源，减少内存分配的次数。而连接池则是为了减少建立连接的次数，重复利用已有的 <code>TCP</code> 连接。</p><p><img src="https://code.aliyun.com/middlewarerace2018/docs/raw/master/assets/system-architecture.png" alt="ConnPool"></p><p>例如在上图中，<code>Consumer Agent</code> 不断收到来自 <code>Consumer</code> 的 <code>HTTP</code> 请求，它解析请求的内容后，<code>Consumer Agent</code> 就要利用 <code>TCP</code> 连接给 <code>Provider Agent</code> 发送消息，那么如果按照传统的方法我们就需要每一个 <code>HTTP</code> 请求都要对应一个新的 <code>TCP</code> 连接，也就对应新的三次握手，这样的话系统开销会非常大。你可能会问为什么不直接用一个 <code>TCP</code> 连接来解决传输数据的问题，这样的话甚至不用这么多握手操作了，这问题不错，但是考虑到由于 <code>TCP</code> 传输的是应用层的数据，它并不了解应用层传输的信息究竟是什么意思，如果多个客户端发起的连接共用一个 <code>TCP</code> 连接，那么我们还需要写逻辑去区分收到的消息究竟需要属于哪个 <code>HTTP</code> 请求，另外还需要考虑<code>TCP</code> 发送和接受时读写竞争的问题，操作起来比较混乱，还不如重复利用多个 <code>TCP</code> 连接来发送和接受数据来的干净利落。</p><p>总的来说，连接池是一种利用空间换时间的技术。下面我们来看一下如何设计一个连接池。连接池中最核心的操作就是获取一个空闲的 <code>TCP</code> 连接，另外还要考虑连接池资源释放的问题，否则可能会导致内存泄漏。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ErrClosed = errors.New(<span class="string">"pool is closed"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get() (net.Conn, error)</span><br><span class="line">    Close()</span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在正常的 <code>TCP</code> 流程中，<code>Close</code> 会关闭本次连接，底层会进行四个挥手操作，但是我们不希望我们调用 <code>Close</code> 时直接关闭这个连接，而是希望能回收这个连接，所以我们对普通的 <code>net.Conn</code> 做了一层封装，来该改变其 <code>Close</code> 行为（其实这就是装饰器模式的应用），我们想要客户端调用 <code>Close</code> 的时候被我们的连接池所回收而非直接关闭，除非该连接被标记为不可用时 <code>unusable</code> （通过 <code>MarkUnusable</code> ）， 我们才决定关闭本次连接。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PooledConn <span class="keyword">struct</span> &#123;</span><br><span class="line">    net.Conn</span><br><span class="line">    mu  sync.RWMutex</span><br><span class="line">    c   *ConnPool</span><br><span class="line">    unusable <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PooledConn)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    p.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> p.mu.Runlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> p.unusable &#123;</span><br><span class="line">        <span class="keyword">if</span> p.Conn != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p.Conn.Close()      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p.c.put(p.Conn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PooledConn)</span> <span class="title">MarkUnusable</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> p.mu.Unlock()</span><br><span class="line">    p.unusable = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConnPool)</span> <span class="title">wrapConn</span><span class="params">(conn net.Conn)</span> <span class="title">net</span>.<span class="title">Conn</span></span> &#123;</span><br><span class="line">    p := &amp;PooledConn&#123;c: c&#125;</span><br><span class="line">    p.Conn = conn</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接池的构建需要考虑两个问题，一个就是连接创建问题，第二就是回收连接问题，创建我们用一个 <code>Factory</code> 工厂方法来表示，而回收连接可以利用 <code>golang</code> 中的通道机制（ <code>chan</code> ）来进行储存。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Factory <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(net.Conn, error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">ConnPool</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">    mu sync.RWMutex</span><br><span class="line">    conns <span class="keyword">chan</span> net.Conn</span><br><span class="line">    factroy Factory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化连接池时，我们先建立 <code>initialCap</code> 个连接用于刚开始时使用，具体创建可以使用 <code>factory</code> 产生 <code>TCP</code> 连接。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConnPool</span><span class="params">(initialCap, maxCap <span class="keyword">int</span>, factory Factory)</span> <span class="params">(Pool, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> initialCap &lt; <span class="number">0</span> || maxCap &lt;= <span class="number">0</span> || initialCap &gt; maxCap &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> , errors.New(<span class="string">"invalid capacity settings"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c := &amp;ConnPool&#123;</span><br><span class="line">        conns: <span class="built_in">make</span>(<span class="keyword">chan</span> net.Conn, maxCap),</span><br><span class="line">        factory: factory,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; initialCap; i++ &#123;</span><br><span class="line">        conn, err := factory()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            c.Close()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"factory is not able to fill the pool: %s"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        c.conns &lt;- conn</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConnPool)</span> <span class="title">getConnsAndFactory</span><span class="params">()</span> <span class="params">(<span class="keyword">chan</span> net.Conn, Factory)</span></span>&#123;</span><br><span class="line">    c.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">    conns := c.conns</span><br><span class="line">    factory := c.factory</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当客户端使用完一次 <code>TCP</code> 连接后，会主动调用 <code>Close</code> 来关闭此次连接，由于我们重新定义了 <code>Close</code> 函数，当调用 <code>Close</code> 时，连接不会直接关闭而是会重新放回连接池中供其他部分代码使用，从而达到重复使用的目的，如果此时连接池已满，则直接释放该连接。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConnPool)</span> <span class="title">put</span><span class="params">(conn net.Conn)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> conn == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"connection is nil, rejecting"</span>)</span><br><span class="line">    &#125; </span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.conns == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> conn.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> c.conns &lt;- conn:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> conn.Close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的结构体 <code>ConnPool</code> 实现了 <code>Pool</code> 接口。在 <code>Get</code> 方法中我们先得到具体用于存储连接的通道 <code>conns</code> 和用于制造连接的工厂方法 <code>factory</code>，然后试着去通道中拿，和 <code>put</code> 方法类似，如果该通道中还有空闲的 <code>TCP</code> 连接，则直接拿出并经过封装后（ <code>wrapConn</code> ）使用，如果没有则使用工厂方法新建一个 <code>TCP</code> 连接再经过封装后使用。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConnPool)</span> <span class="title">Get</span><span class="params">()</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line">    conns, factory := c.getConnsAndFactory()</span><br><span class="line">    <span class="keyword">if</span> conns == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrClosed</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> conn := &lt;- conns:</span><br><span class="line">        <span class="keyword">if</span> conn == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ErrClosed</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c.wrapConn(conn), <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        conn, err := factory()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c.wrapConn(conn), <span class="literal">nil</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConnPool)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    conns := c.conns</span><br><span class="line">    c.conns. = <span class="literal">nil</span></span><br><span class="line">    c.factory = <span class="literal">nil</span></span><br><span class="line">    c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> conns == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(conns)</span><br><span class="line">    <span class="keyword">for</span> conn := <span class="keyword">range</span> conns &#123;</span><br><span class="line">        conn.Close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConnPool)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    conns, _ := c.getConnsAndFactory()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(conns)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接池的使用"><a href="#连接池的使用" class="headerlink" title="连接池的使用"></a>连接池的使用</h2><p>由于具体的连接逻辑是由客户端决定的，所以 <code>factory</code> 应该由使用者定义。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">factory := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(net.Conn, error)</span></span> &#123;<span class="keyword">return</span> net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:8080"</span>)&#125;</span><br></pre></td></tr></table></figure><p>我们通过 <code>pool.NewConnPool</code> 来新建一个连接池，这里我们指定连接池中初始的连接个数为5，而最大的连接个数为30。通过 <code>p.Get</code> 来获得可用的连接，<code>Get</code> 方法会根据当前池中的情况返回连接，如果池中没有可用的连接则用 <code>factory</code> 方法新建一个，此时系统开销较大，但是这种情况并不常见，所以基本可以忽略不计。如果池中有可用连接，则直接返回，此时开销较小。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p, err := pool.NewConnPool(<span class="number">5</span>, <span class="number">30</span>, factory)</span><br><span class="line"></span><br><span class="line">conn, err := p.Get()</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br></pre></td></tr></table></figure><p>下面给出真正关闭该连接的方法，因为我们重载了 <code>Close</code> 方法，直接调用 <code>Close</code> 只会将此连接放回连接池中，所以需要在真正关闭前将此连接设为不可用（ <code>MarkUnusable</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pc, ok := conn.(*pool.PooledConn); ok &#123;</span><br><span class="line">    pc.MarkUnusable()</span><br><span class="line">    pc.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Connection-Pool&quot;&gt;&lt;a href=&quot;#Connection-Pool&quot; class=&quot;headerlink&quot; title=&quot;Connection Pool&quot;&gt;&lt;/a&gt;Connection Pool&lt;/h1&gt;&lt;p&gt;因为 &lt;code&gt;TCP&lt;/code
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Morse Code</title>
    <link href="https://oceanoverflow.github.io/2018/05/09/MorseCode/"/>
    <id>https://oceanoverflow.github.io/2018/05/09/MorseCode/</id>
    <published>2018-05-09T09:07:24.000Z</published>
    <updated>2018-05-15T11:52:34.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="morse-code"><a href="#morse-code" class="headerlink" title="morse code"></a>morse code</h1><p>电影无间道中，陈永仁用摩斯密码向自己老大发送消息那一段真的是精彩，印象非常深刻。其实摩斯密码的本质上就是一种消息编码格式，也就是通信双方用规定好的格式进行交流，由于该编码方式二义性小，所以接受方基本可以准确无误的解析出发送方经过编码的信息。</p><h2 id="摩斯密码"><a href="#摩斯密码" class="headerlink" title="摩斯密码"></a>摩斯密码</h2><p>摩斯密码主要编码英文字母，数字和标点符号，摩斯密码与常用的二进制编码不同，它包含了五个元素， 点、划、点和划之间的停顿、每个词之间中等的停顿以及句子之间长的停顿。</p><p><img src="https://cdn-images-1.medium.com/max/443/1*2WrXJ9lDlC8Q0HCO7H3DBQ.png" alt="Morse Code"></p><p>因为摩斯密码的编码方法不止一种，但其基本原理都是相通的，所以这里我们使用国际电信联盟（International Telecommunication Union）制定的编码标准来书写代码。</p><p>下面使用一个 <code>map</code> 作为字典使用，用于记录英文字母、数字和标点符号到摩斯密码的映射关系，因为文章篇幅原因，这里选择省略对应关系。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    morseITU = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">"a"</span>: <span class="string">".-"</span>,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...    </span></span><br><span class="line"></span><br><span class="line">        <span class="string">"0"</span>:  <span class="string">"-----"</span>,   </span><br><span class="line"></span><br><span class="line">        <span class="string">"="</span>:  <span class="string">"-...-"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>编码的过程就是利用字典将我们要映射的字符转为摩斯密码，并且注意每次转换都要附加一个 <code>letterSep</code> ，也就是字符间的分隔符，当遇到原本需要编码的字符串中的空格，则加上 <code>wordSep</code> ，即字分隔符。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeITU</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Encode(s, morseITU, <span class="string">" "</span>, <span class="string">"/"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(s <span class="keyword">string</span>, alphabet <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, letterSep <span class="keyword">string</span>, wordSep <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    res := <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> _, part := <span class="keyword">range</span> s &#123;</span><br><span class="line">        p := <span class="keyword">string</span>(part)</span><br><span class="line">        <span class="keyword">if</span> p == <span class="string">" "</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> wordSep != <span class="string">""</span> &#123;</span><br><span class="line">                res += wordSep + letterSep</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> morseITU[p] != <span class="string">""</span> &#123;</span><br><span class="line">            res += morseITU[p] + letterSep</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> strings.TrimSpace(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><p>解码是编码的逆过程，因为有字符分隔符（letterSep）的存在，所以我们先用 <code>strings.Split(s, letterSep)</code> 得到一组经过摩斯密码编码的字符数组，然后对于每个经过编码的摩斯密码，我们查询字典中是否有该编码存在，如果存在则与返回结果拼接，如果不存在则检查该元素是否为字分隔符，如果还不是的话则返回错误，最后全部成功返回解码后的结果。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeITU</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Decode(s, morseITU, <span class="string">" "</span>, <span class="string">"/"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">(s <span class="keyword">string</span>, alphabet <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, letterSep <span class="keyword">string</span>, wordSep <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    res := <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> _, part := <span class="keyword">range</span> strings.Split(s, letterSep) &#123;</span><br><span class="line">        found := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> key, val := <span class="keyword">range</span> alphabet &#123;</span><br><span class="line">            <span class="keyword">if</span> val == part &#123;</span><br><span class="line">                res += key</span><br><span class="line">                found = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span>    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> part == wordSep &#123;</span><br><span class="line">            res += <span class="string">" "</span></span><br><span class="line">            found = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> found == <span class="literal">false</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res, fmt.Errorf(<span class="string">"unknown character "</span> + part)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;morse-code&quot;&gt;&lt;a href=&quot;#morse-code&quot; class=&quot;headerlink&quot; title=&quot;morse code&quot;&gt;&lt;/a&gt;morse code&lt;/h1&gt;&lt;p&gt;电影无间道中，陈永仁用摩斯密码向自己老大发送消息那一段真的是精彩，印象非常深
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Circuit Breaker</title>
    <link href="https://oceanoverflow.github.io/2018/05/09/CircuitBreaker/"/>
    <id>https://oceanoverflow.github.io/2018/05/09/CircuitBreaker/</id>
    <published>2018-05-09T01:17:24.000Z</published>
    <updated>2018-05-15T11:35:05.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CircuitBreaker"><a href="#CircuitBreaker" class="headerlink" title="CircuitBreaker"></a>CircuitBreaker</h1><p>我们都知道，如果家中因为启动过多大功率电器而导致电流过大，断路开关就会断开以保护这些电路和电器。在分布式系统中，集群中的某些服务器出现异常还是一件非常正常的事情，如果客户端向这些异常的服务器进行 <code>RPC</code> 请求的话，这些服务器会因为异常而无法向客户端返回远程方法调用的结果，因为一般来说 <code>RPC</code> 是阻塞的，客户端会像执行本地方法一样调用 <code>RPC</code> ，也就是说客户端会阻塞在这里无法执行 直到该方法本地超时，但由于为了得到正确的结果，客户端可能会反复多次调用该 <code>RPC</code> ，由于在这段时间内远程服务器都可能无法恢复正常，所以就会导致客户端一直调用该方法，但却无法得到结果，这样就会导致资源的浪费。</p><p>为了避免上述情况的发生，我们可以在程序设计中借鉴断路开关的模式，也就是允许被保护的函数在规定上限内执行，如果一旦出现错误的次数超过上限，则下次函数再次调用时则直接不让其执行（也就是断路开关直接断开），从而避免系统资源的浪费。但是上述方法存在一个问题，就是一旦总的错误次数超过上限，是不是就说明即使现在远程服务器恢复正常，客户端也无法调用了呢。</p><p>解决上述问题也很简单，通过模仿网络中很常见的 <code>Sliding Window</code> ，也就是移动窗口，允许在一定时间窗口内出现特定上限个错误，如果在该时间窗口内出现错误的次数超过上限，则不再允许该函数执行，直到下一个时间窗口的到来才允许它重新执行。</p><p>下面来设计一个滑动窗口版本的断路开关，我们通过判断一个时间窗口 <code>window</code> 内出现的错误次数 <code>failures</code> 是否超过<code>failureThreshold</code> 来决定断路开关是否应该断开（也就是不让函数继续执行）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CircuitBreaker <span class="keyword">struct</span> &#123;</span><br><span class="line">    lastFailureTime  time.Time</span><br><span class="line">    failures         <span class="keyword">uint64</span></span><br><span class="line">    failureThreshold <span class="keyword">uint64</span></span><br><span class="line">    window           time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCircuitBreaker</span><span class="params">(failureThreshold <span class="keyword">uint64</span>, window time.Duration)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;CircuitBreaker&#123;</span><br><span class="line">        failureThreshold: failureThreshold,</span><br><span class="line">        window:           window,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于是滑动窗口，我们需要观察在现在的窗口出现错误的次数是否超过我们规定的次数，如果超过，则表示该函数还没有 <code>ready</code> ，也就是还不能执行，如果该窗口已经过去，那么我们重置（ <code>reset</code> ）断路开关中记录的出错次数，以让函数可以重新执行。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CircuitBreaker)</span> <span class="title">ready</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> time.Since(cb.lastFailureTIme) &gt; cb.window &#123;</span><br><span class="line">        cb.reset()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    failures := atomic.LoadUint64(&amp;cb.failures)</span><br><span class="line">    <span class="keyword">return</span> failures &lt; cb.failureThreshold</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CircuitBreaker)</span> <span class="title">success</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cb.reset()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CircuitBreaker)</span> <span class="title">fail</span><span class="params">()</span></span> &#123;</span><br><span class="line">    atomic.AddUint64(&amp;cb.failures, <span class="number">1</span>)</span><br><span class="line">    cb.lastFailureTime = time.Now()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CircuitBreaker)</span> <span class="title">reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">    atomic.StoreUint64(&amp;cb.failures, <span class="number">0</span>)</span><br><span class="line">    cb.lastFailureTime = time.Now()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，在 <code>CircuitBreaker</code> 保护下，客户端准备调用函数时，会预先检察其是否具备资格，也就是说过去一个时间窗口没有出现超过上限个错误，如果不具备，就报 <code>ErrBreakerOpen</code> 错误，也就是对应下图中的  <code>circuit open</code> ，因为断路开关断开了，自然没有办法继续执行。</p><p>如果具备，则可以让受保护的函数继续执行，但是钥匙它在规定的时间内还没有返回结果，说明出现超时情况，则报<code>ErrBreakerTimeout</code> 错误，并增加错误次数直到其达到上限为止。</p><p><img src="https://martinfowler.com/bliki/images/circuitBreaker/sketch.png" alt="Circuit Breaker"></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrBreakerOpen = errors.New(<span class="string">"breaker open"</span>)</span><br><span class="line">    ErrBreakerTimeout = errors.New(<span class="string">"breaker time out"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CircuitBreaker)</span> <span class="title">Call</span><span class="params">(fn <span class="keyword">func</span>()</span> <span class="title">error</span>, <span class="title">d</span> <span class="title">time</span>.<span class="title">Duration</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">if</span> !cb.ready() &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> d == <span class="number">0</span> &#123;</span><br><span class="line">        err = fn()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            c &lt;- fn()</span><br><span class="line">            <span class="built_in">close</span>(c)</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        t := time.NewTicker(d)</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> e := &lt;-c:</span><br><span class="line">            err = e</span><br><span class="line">        <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">            err = ErrBreakerTimeout</span><br><span class="line">        &#125;</span><br><span class="line">        t.Stop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        cb.success()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cb.fail()</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CircuitBreaker&quot;&gt;&lt;a href=&quot;#CircuitBreaker&quot; class=&quot;headerlink&quot; title=&quot;CircuitBreaker&quot;&gt;&lt;/a&gt;CircuitBreaker&lt;/h1&gt;&lt;p&gt;我们都知道，如果家中因为启动过多大功率电器而
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Colorful Printing</title>
    <link href="https://oceanoverflow.github.io/2018/05/08/ColorfulPrinting/"/>
    <id>https://oceanoverflow.github.io/2018/05/08/ColorfulPrinting/</id>
    <published>2018-05-08T11:48:24.000Z</published>
    <updated>2018-05-15T11:35:50.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Colorful-Printing"><a href="#Colorful-Printing" class="headerlink" title="Colorful Printing"></a>Colorful Printing</h1><p>平时在使用一些命令行工具时，是否经常注意到彩色的 <code>log</code> 打出来呢，然而自己写的命令行工具永远都是清一色白底黑字（或者黑底白字）的输出，是不是会怀疑别人施了黑魔法才让输出变得五彩斑斓，其实要让命令行输出彩色字体并没有那么难，关键就在对其规则的把握。</p><p>为了让字符变色，我们需要规定其伴随的属性，一般来说属性有以下几类。</p><ul><li>基本属性，例如字体粗细，是否为斜体等等</li><li>前景字体颜色</li><li>前景字体颜色（强烈版）</li><li>背景字体颜色</li><li>背景字体颜色（强烈版）</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base attributes</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Reset Attribute = <span class="literal">iota</span></span><br><span class="line">    Bold</span><br><span class="line">    Faint</span><br><span class="line">    Italic</span><br><span class="line">    Underline</span><br><span class="line">    BlinkSlow</span><br><span class="line">    BlinkRapid</span><br><span class="line">    ReverseVideo</span><br><span class="line">    Concealed</span><br><span class="line">    CrossedOut</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Foreground text colors</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    FgBlack Attribute = <span class="literal">iota</span> + <span class="number">30</span></span><br><span class="line">    FgRed</span><br><span class="line">    FgGreen</span><br><span class="line">    FgYellow</span><br><span class="line">    FgBlue</span><br><span class="line">    FgMagenta</span><br><span class="line">    FgCyan</span><br><span class="line">    FgWhite</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Foreground Hi-Intensity text colors</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    FgHiBlack Attribute = <span class="literal">iota</span> + <span class="number">90</span></span><br><span class="line">    FgHiRed</span><br><span class="line">    FgHiGreen</span><br><span class="line">    FgHiYellow</span><br><span class="line">    FgHiBlue</span><br><span class="line">    FgHiMagenta</span><br><span class="line">    FgHiCyan</span><br><span class="line">    FgHiWhite</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Background text colors</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    BgBlack Attribute = <span class="literal">iota</span> + <span class="number">40</span></span><br><span class="line">    BgRed</span><br><span class="line">    BgGreen</span><br><span class="line">    BgYellow</span><br><span class="line">    BgBlue</span><br><span class="line">    BgMagenta</span><br><span class="line">    BgCyan</span><br><span class="line">    BgWhite</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Background Hi-Intensity text colors</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    BgHiBlack Attribute = <span class="literal">iota</span> + <span class="number">100</span></span><br><span class="line">    BgHiRed</span><br><span class="line">    BgHiGreen</span><br><span class="line">    BgHiYellow</span><br><span class="line">    BgHiBlue</span><br><span class="line">    BgHiMagenta</span><br><span class="line">    BgHiCyan</span><br><span class="line">    BgHiWhite</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>让字符变色的关键在于转义字符的使用，转义字符对每个程序员来说肯定都不陌生，它的作用就是让紧随其后的字符变成其他含义，所谓转义转义就是这个意思，我们这里要使用的转义字符是 <code>\x1b</code> ，或者写作  <code>\033</code> ，二者都是可以的，因为十六进制的 <code>1b</code> 和八进制的 <code>33</code> 相等。</p><p>下面我们定义一个 <code>Color</code> 结构体，里面包含一个属性数组，规定了我们的文字会变化成什么样。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> escape = <span class="string">"\x1b"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Attribute <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Color <span class="keyword">struct</span> &#123;</span><br><span class="line">    params []Attribute</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(value ...Attribute)</span> *<span class="title">Color</span></span> &#123;</span><br><span class="line">    c := &amp;Color&#123;params: <span class="built_in">make</span>([]Attribute, <span class="number">0</span>)&#125;</span><br><span class="line">    c.params = <span class="built_in">append</span>(c.params, value...)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如一段文字 <code>how are you?</code> ，我们想要把把中间的 <code>are</code> 变为绿色，我们应该怎么办呢，其实就是分别在 <code>are</code> 的前后加上一些修饰符。</p><p>在 <code>are</code> 的前面加上 <code>\x1b[32m</code> 表示从这之后将后面的字变为绿色。<br>而在 <code>are</code> 的后面加上 <code>\x1b[0m</code> 则表示结束属性变化。</p><p>所以我们在开始变化的时候加上 <code>fmt.Sprintf(&quot;%s[%sm&quot;, escape, c.sequence())</code> ，这里的 <code>escape</code> 就是我们之前提过的转义字符，而 <code>c.sequence()</code> 就是我们规定的属性。</p><p>在变化结束的时候加上 <code>fmt.Sprintf(&quot;%s[%dm&quot;, escape, Reset)</code> ，这里 <code>Reset</code> 就表示重置变化，其值为0。</p><p>注意如果有多个属性，我们使用 <code>;</code> 连接就可以了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Color)</span> <span class="title">sequence</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    format := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(c.params))</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> c.params &#123;</span><br><span class="line">        format[i] = strconv.Itoa(<span class="keyword">int</span>(v))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strings.Join(format, <span class="string">";"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Color)</span> <span class="title">format</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s[%sm"</span>, escape, c.sequence())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Color)</span> <span class="title">unformat</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s[%dm"</span>, escape, Reset)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Color)</span> <span class="title">wrap</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.format() + s + c.unformat() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们对常见的几个函数作一层封装。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Color)</span> <span class="title">Sprint</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.wrap(fmt.Sprint(a...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Color)</span> <span class="title">Sprintln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.wrap(fmt.Sprintln(a...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Color)</span> <span class="title">Sprintf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.wrap(fmt.Sprintf(format, a...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>理清了基本思路，使用它就变的非常简单了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := New(Bold, FgGreen)</span><br><span class="line">    fmt.Println(c.Sprintln(<span class="string">"hello world"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Colorful-Printing&quot;&gt;&lt;a href=&quot;#Colorful-Printing&quot; class=&quot;headerlink&quot; title=&quot;Colorful Printing&quot;&gt;&lt;/a&gt;Colorful Printing&lt;/h1&gt;&lt;p&gt;平时在使用一些命令行
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Weighted Round Robin</title>
    <link href="https://oceanoverflow.github.io/2018/05/08/SmoothWeightedRoundRobin/"/>
    <id>https://oceanoverflow.github.io/2018/05/08/SmoothWeightedRoundRobin/</id>
    <published>2018-05-08T02:29:04.000Z</published>
    <updated>2018-05-15T12:04:29.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Smooth-Weighted-Round-Robin"><a href="#Smooth-Weighted-Round-Robin" class="headerlink" title="Smooth Weighted Round Robin"></a>Smooth Weighted Round Robin</h1><p>我们在之前的文章中就讲过负载均衡，但是那篇文章中的例子比较简单，仅仅是利用随机算法来进行负载均衡，并没有考虑服务器的实际情况，在很多情况下，服务器的性能可能存在显著差异，这时候如果采用随机算法，那么性能较差的服务器会承受过多的压力，而性能较好的服务器则大部分时间处于空闲状态，系统整体的吞吐量就无法上来。</p><p>例如服务器的性能比例如下：<code>{a:3, b: 2, c:1}</code> ，一般来说可以使用加权的轮询算法（ <code>Weighted Round Robin</code> ）进行负载均衡，但是普通的加权轮询会得出类似这样的序列， <code>a a a b b c</code> ，这样的序列有一个问题，就是它并不够平滑，我们更希望得到像这样的序列 <code>a b a c b a</code> 。也就是说一般的轮询调度在调度的过程中并没有考虑瞬时的情况，所以会导致对某一台服务器的瞬时访问。</p><p>下面我们就来介绍一下平滑版本的加权轮询算法，来解决上述瞬时访问可能出现的问题。我们对每个节点赋予两个权重， <code>Weight</code> ，这是一个较为固定的值，就是前面给出的 <code>{a:3, b: 2, c:1}</code> ，还需要一个 <code>CurrentWeight</code> 来记录当前的权重，初始时均为0，这个权重是在每次选择节点时动态变化的。</p><p>例如现在有三台服务器，其权重比值为 <code>{a:3, b: 2, c:1}</code> ，刚开始时它们的 <code>CurrentWeight</code> 均为0，按照下面的算法，每一回合中各个节点的 <code>CurrentWeight</code> 都会加上它相应的的 <code>Weight</code> ，<code>total</code> 变量则用于记录每一个节点增加的 <code>Weight</code> 的总和，并记录当前权重最高的那一个节点，也就是我们的 <code>best</code> ，在一轮计算之后，再让 <code>best</code> 节点的 <code>CurrentWeight</code> 减去 <code>total</code> 值。</p><p>也就是说开始时每台服务器的 <code>CurrentWeight</code> 为 <code>{a:0, b: 0, c:0}</code> ，在选择节点的过程中，每个节点均会加上自己对应的 <code>Weight</code> ，这样就变成 <code>{a:3, b: 2, c:1}</code> ， 此时 <code>best=a</code> ， 最后 a 对应的 <code>CurrentWeight</code> 要减去 <code>total</code> ，也就是 <code>{a:-3, b: 2, c:1}</code>  。</p><p>然后 <code>{a:-3, b: 2, c:1}</code> 作为下一轮挑选节点时的初始状态，以此类推，最后可以得到下面这样的序列  <code>a b a c b a</code> ，这样就不会导致对服务器 <code>a</code> 集中访问的情况，也就是说访问序列更加平滑了。</p><p>整个周期计算的流程如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a   b   c</span><br><span class="line">0   0   0</span><br><span class="line"></span><br><span class="line">3   2   1   Next() : a</span><br><span class="line">-3  2   1</span><br><span class="line"></span><br><span class="line">0   4   2   Next() : b</span><br><span class="line">0  -2   2</span><br><span class="line"></span><br><span class="line">3   0   3   Next() : a</span><br><span class="line">-3  0   3</span><br><span class="line"></span><br><span class="line">0   2   4   Next() : c</span><br><span class="line">0   2   -2 </span><br><span class="line"></span><br><span class="line">3   4   -1  Next() : b</span><br><span class="line">3  -2   -1</span><br><span class="line"></span><br><span class="line">6   0   0   Next() : a</span><br><span class="line">0   0   0</span><br></pre></td></tr></table></figure><h2 id="普通版本平滑轮询调度算法"><a href="#普通版本平滑轮询调度算法" class="headerlink" title="普通版本平滑轮询调度算法"></a>普通版本平滑轮询调度算法</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Weighted <span class="keyword">struct</span> &#123;</span><br><span class="line">    Server <span class="keyword">string</span></span><br><span class="line">    Weight <span class="keyword">int</span></span><br><span class="line">    CurrentWeight <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通版本的算法，每次选择结点的时候，我们为每个候选结点的 <code>CurrentWeight</code> 增加 <code>Weight</code> ，选取 <code>CurrentWeight</code> 最大的节点作为我们最后返回的结果，然后将该节点减去所有节点增加的 <code>Weight</code> 之和。 </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Next</span><span class="params">(servers []*Weighted)</span> <span class="params">(best *Weight)</span></span> &#123;</span><br><span class="line">    total := <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(servers); i++ &#123;</span><br><span class="line">        w := servers[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> w == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        w.CurrentWeight += w.Weight</span><br><span class="line">        total += w.CurrentWeight </span><br><span class="line">        <span class="keyword">if</span> best == <span class="literal">nil</span> || w.CurrentWeight &gt; best.CurrentWeight &#123;</span><br><span class="line">            best = w</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> best == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    best.CurrentWeight -= total</span><br><span class="line">    <span class="keyword">return</span> best</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="考虑节点失效情况时的算法"><a href="#考虑节点失效情况时的算法" class="headerlink" title="考虑节点失效情况时的算法"></a>考虑节点失效情况时的算法</h2><p>上面那种算法不能很好的应对节点失效的情况，为了解决节点失效时的这种突发情况，我们多引入一个权重也就是 <code>EffectiveWeight</code> ，该权重初始时与 <code>Weight</code> 的值相同，例如上述的例子中都是  <code>{a:3, b: 2, c:1}</code> ，但是 <code>EffectiveWeight</code> 会在节点失败的时候清0，当节点恢复正常时再慢慢递增直到达到原本的 <code>Weight</code> ，这样就能很好地考虑了节点失效再重启时的真实情况。因为引入了 <code>EffectiveWeight</code> ， 我们在相应计算的时候就不直接采用 <code>Weight</code> 而是直接使用<code>EffectiveWeight</code> 来代替计算。 </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Weighted <span class="keyword">struct</span> &#123;</span><br><span class="line">    Server <span class="keyword">string</span></span><br><span class="line">    Weight <span class="keyword">int</span></span><br><span class="line">    CurrentWeight <span class="keyword">int</span></span><br><span class="line">    EffectiveWeight <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Weighted)</span> <span class="title">fail</span><span class="params">()</span></span> &#123;</span><br><span class="line">    w.EffetiveWeight -= w.Weight</span><br><span class="line">    <span class="keyword">if</span> w.EffectiveWeight &lt; <span class="number">0</span> &#123;</span><br><span class="line">        w.EffectiveWeight = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Next</span><span class="params">(servers []*Weighted)</span> <span class="params">(best *Weight)</span></span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(servers); i++ &#123;</span><br><span class="line">        w := servers[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> w == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        w.CurrentWeight += w.EffectiveWeight</span><br><span class="line">        total += w.EffectiveWeight</span><br><span class="line">        <span class="keyword">if</span> w.EffectiveWeight &lt; w.Weight &#123;</span><br><span class="line">            w.EffectiveWeight++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> best == <span class="literal">nil</span> || w.CurrentWeight &gt; best.CurrentWeight &#123;</span><br><span class="line">            best = w</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> best == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    best.CurrentWeight -= total</span><br><span class="line">    <span class="keyword">return</span> best</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Smooth-Weighted-Round-Robin&quot;&gt;&lt;a href=&quot;#Smooth-Weighted-Round-Robin&quot; class=&quot;headerlink&quot; title=&quot;Smooth Weighted Round Robin&quot;&gt;&lt;/a&gt;Smoot
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Magnet Link</title>
    <link href="https://oceanoverflow.github.io/2018/05/07/MagnetLink/"/>
    <id>https://oceanoverflow.github.io/2018/05/07/MagnetLink/</id>
    <published>2018-05-07T07:15:24.000Z</published>
    <updated>2018-05-15T11:50:46.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Magnet-Link"><a href="#Magnet-Link" class="headerlink" title="Magnet Link"></a>Magnet Link</h1><p>相信大部分人都使用过磁力链接来下载过网上的文件吧，但是估计很少人会去关心那稀奇古怪的磁力链接究竟是什么鬼，今天就让我们来解析一下磁力链接，看一下它里面隐藏的信息吧。</p><p>其实类似下面这种看似复杂的链接地址也就是由几个部分组成，开头的 <code>magnet</code> 我们把它称为 <code>scheme</code> 或者说是协议名，就像一般的 <code>http</code> 地址一样，<code>http</code> 也算是一种协议名，紧接着 <code>magnet:?</code> 后面就是几对键值对了，一般键值对之间以 <code>&amp;</code> 符号划分，常见的键有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">magnet:?xt=urn:btih:0FF55426B9713084FF5229A16D21712B1E6C1625&amp;dn=%e5%8d%97%e5%be%81%e5%8c%97%e6%88%98%20-%206415&amp;tr=http%3a%2f%2ftracker.nexushd.org%2fannounce.php%3fpasskey%3d346ae8170f8427b078512150f3683285</span><br></pre></td></tr></table></figure><ul><li><code>xt</code> ：eXact Topic 的缩写，其实本质上就是一个文件的哈希值，用于唯一标示这个文件而存在的，这是整个磁力链接中不可或缺的一部分，少了它，基本上链接地址就无法解析了。</li><li><code>dn</code> ：Display Name 的缩写，这个是用于向用户展示的文件的名称，这一项可以没有。</li><li><code>tr</code> ： Tracker 的缩写，表示Tracker服务器的地址，取决于使用的技术，这一项也是选填的。</li><li><code>ws</code> ： Web Seed 的缩写，表示网络种子，选填。</li><li><code>urn</code> ：Uniform Resource Name 的缩写，也就是统一资源名称。</li><li><code>btih</code> ： BitTorrent Info Hash 的缩写，表示种子的散列函数。</li></ul><p>知道了磁力链接地址中的关键信息，也就基本可以看懂链接地址中的各个部分分别代表什么含义了，但是由于其中一些信息还是经过特殊编码的，人类读起来还是比较费劲<br>的，所以我们还是实现代码来解析它吧。</p><p>首先，来定义一个结构体来定义一下磁力链接中的组成部分，这里只选了几个重要的，<code>InfoHash</code> 代表的就是 <code>&quot;urn:btih:&quot;</code> 后面那一部分玩意儿，<code>Trackers</code> 数组代表的就是 <code>Tracker</code> 服务器的地址，<code>DisplayName</code> 就对应磁力链接中的 <code>dn</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Magnet <span class="keyword">struct</span> &#123;</span><br><span class="line">    InfoHash Hash</span><br><span class="line">    Trackers []<span class="keyword">string</span></span><br><span class="line">    DisplayName <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xtPrefix = <span class="string">"urn:btih:"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m Magnet)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    ret : = <span class="string">"magnet:?xt="</span></span><br><span class="line">    ret += xtPrefix + hex.EncodeToString(m.InfoHash[:])</span><br><span class="line">    <span class="keyword">if</span> m.DisplayName != <span class="string">""</span> &#123;</span><br><span class="line">        ret += <span class="string">"&amp;dn="</span> + url.QueryEscape(m.DisplayName)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, tr := <span class="keyword">range</span> m.Trackers &#123;</span><br><span class="line">        ret += <span class="string">"&amp;tr="</span> + url.QueryEscape(tr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析磁力链接的过程和解析一般的 <code>url</code> 的过程非常类似，关键的部分是哈希值部分的解析，由于 <code>BTIH</code> 这个部分的哈希值可能用 <code>Hex</code> 编码也可能用 <code>Base32</code> 编码，所以我们要根据其哈希长度选择解码的方式，这里定义了一个函数变量 <code>var decode func(dst, src []byte) (int, error)</code> 用于接受我们具体的解码函数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseMagnetURI</span><span class="params">(uri <span class="keyword">string</span>)</span> <span class="params">(m Magnet, err eror)</span></span> &#123;</span><br><span class="line">    u, err := url.Parse(uri)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        err = fmt.Errorf(<span class="string">"error parsing uri : %s"</span>, err) </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> u.Scheme != <span class="string">"magnet"</span> &#123;</span><br><span class="line">        err = fmt.Errorf(<span class="string">"unexpected scheme: %q"</span>, u.Scheme)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    xt := u.Query().Get(<span class="string">"xt"</span>)</span><br><span class="line">    <span class="keyword">if</span> !strings.HasPrefix(xtPrefix) &#123;</span><br><span class="line">        err = fmt.Errorf(<span class="string">"bad xt parameter"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    infoHash := xt[<span class="built_in">len</span>(xtPrefix):]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> decode <span class="function"><span class="keyword">func</span><span class="params">(dst, src []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="function">    <span class="title">switch</span> <span class="title">len</span><span class="params">(infoHash)</span></span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">40</span>:</span><br><span class="line">        decode = hex.Decode</span><br><span class="line">    <span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">        decode = base32.StdEncoding.Decode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> decode == <span class="literal">nil</span> &#123;</span><br><span class="line">        err = fmt.Errorf(<span class="string">"unhandled xt parameter encoding: encoded lenght"</span>, <span class="built_in">len</span>(infoHash))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    n, err := decode(m.InfoHash[:], []<span class="keyword">byte</span>(infoHash))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        err = fmt.Errorf(<span class="string">"error decoding xt: %s"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n != <span class="number">20</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(n)</span><br><span class="line">    &#125;</span><br><span class="line">    m.DisplayName = u.Query().Get(<span class="string">"dn"</span>)</span><br><span class="line">    m.Trackers = u.Query()[<span class="string">"tr"</span>]</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Magnet-Link&quot;&gt;&lt;a href=&quot;#Magnet-Link&quot; class=&quot;headerlink&quot; title=&quot;Magnet Link&quot;&gt;&lt;/a&gt;Magnet Link&lt;/h1&gt;&lt;p&gt;相信大部分人都使用过磁力链接来下载过网上的文件吧，但是估计很少人会去
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PubSub</title>
    <link href="https://oceanoverflow.github.io/2018/05/06/PubSub/"/>
    <id>https://oceanoverflow.github.io/2018/05/06/PubSub/</id>
    <published>2018-05-06T11:08:04.000Z</published>
    <updated>2018-05-15T11:57:24.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PubSub"><a href="#PubSub" class="headerlink" title="PubSub"></a>PubSub</h1><p>消息的发布和订阅这种设计模式在大型开源项目中还是会经常被使用到的，它的要点是一堆消息订阅者（ <code>Subscriber</code> ）会订阅某个自己感兴趣的 <code>topic</code> ，一旦发布者（ <code>Publisher</code> ）向这个 <code>topic</code> 发布消息，消息的订阅者就能收到该消息。</p><p>这种设计模式的灵感其实就来自于现实生活之中，我们（ <code>Subscriber</code> ）向我们感兴趣的杂志社订阅想要阅读的月刊，那么我们订阅的消息（算一个 <code>subscription</code> ）就会被杂志社（ <code>Publisher</code> ）记录下来，一旦杂志可以上市发行了，杂志社就会主动向我们推送（ <code>Publish</code> ）杂志消息。</p><p><img src="https://docs.oracle.com/cd/E19575-01/819-3669/images/jms-publishSubscribe.gif" alt="PubSub"></p><p>下面我们来实现一个简单的发布者订阅者模型吧。</p><p>由于这个模型的核心就在于很多 <code>subscriber</code> 会向某一个 <code>topic</code> 订阅消息，所以需要一个结构体来记录特定的 <code>topic</code> 对应的所有 <code>subscriber</code> ，这里 <code>subscriber</code> 用一个集合（ <code>Set</code> ）来表示。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PubSub <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    subscriptions <span class="keyword">map</span>[<span class="keyword">string</span>]*Set</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Set <span class="keyword">struct</span> &#123;</span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    lock *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPubSub</span><span class="params">()</span> *<span class="title">PubSub</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;PubSub&#123;</span><br><span class="line">        subscriptions: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*Set),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Subscription</code> 应该具有监听行为，通过 <code>Listen</code> 来获取 <code>Publisher</code> 发布的消息。而结构体 <code>subscription</code> 则相当于一个订阅的注册信息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Subscription <span class="keyword">interface</span> &#123;</span><br><span class="line">    Listen() (<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> subscription <span class="keyword">struct</span> &#123;</span><br><span class="line">    topic <span class="keyword">string</span></span><br><span class="line">    ttl   time.Duration</span><br><span class="line">    c     <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (s *subscription) Listen() (<span class="keyword">interface</span>&#123;&#125;, error) &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(s.ttl):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"timed out"</span>)</span><br><span class="line">    <span class="keyword">case</span> iterm := &lt;-s.c:</span><br><span class="line">        <span class="keyword">return</span> item, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实订阅和取消订阅的本质就是将自己从订阅名单（ <code>subscriptions map[string]*Set</code> ）里面进行增加或删除的操作，因为我们向杂志社订阅了某本杂志，那么关于我们的订阅信息一定会在杂志出版商那里存在。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PubSub)</span> <span class="title">Subscribe</span><span class="params">(topic <span class="keyword">string</span>, ttl time.Duration)</span> <span class="title">Subscription</span></span> &#123;</span><br><span class="line">    sub := &amp;subscription&#123;</span><br><span class="line">        topic: topic.</span><br><span class="line">        ttl:   ttl,</span><br><span class="line">        c:     <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, subscriptionBuffSize),</span><br><span class="line">    &#125;</span><br><span class="line">    ps.Lock()</span><br><span class="line">    s, exists := ps.subscriptions[topic]</span><br><span class="line">    <span class="keyword">if</span> !exists &#123;</span><br><span class="line">        s = NewSet()</span><br><span class="line">        ps.subscriptions[topic] = s</span><br><span class="line">    &#125;</span><br><span class="line">    ps.Unlock()</span><br><span class="line"></span><br><span class="line">    s.Add(sub)</span><br><span class="line">    time.AfterFunc(ttl, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ps.unSubscribe(sub)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PubSub)</span> <span class="title">unSubscribe</span><span class="params">(sub *subscription)</span></span> &#123;</span><br><span class="line">    ps.Lock()</span><br><span class="line">    <span class="keyword">defer</span> ps.Unlock()</span><br><span class="line">    ps.subscriptions[sub.topic].Remove(sub)</span><br><span class="line">    <span class="keyword">if</span> ps.subscriptions[sub.topic].Size() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">delete</span>(ps.subscriptions, sub.topic)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们订阅的杂志终于要发布了，杂志的出版社会根据自己手中的订阅名单，逐一向订阅该 <code>topic</code> 的订阅者发送杂志，当然只有订阅了的人才能收到。但是由于订阅者可能出去旅游了，也就是说他最近并没有调用 <code>Listen</code> 将收到的订阅消息拿出，而我们接受订阅消息的邮箱大小是有上限的（ <code>c: make(chan interface{}, subscriptionBuffSize)</code> ，我们设置了<code>subscriptionBuffSize</code> 来表示一个通道中最多可以存放的消息数量），如果该邮箱内已有的消息超出这个限制，则选择不将消息放入邮箱中，否则则将消息放入这个邮箱中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PubSub)</span> <span class="title">Publish</span><span class="params">(topic <span class="keyword">string</span>, item <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ps.RLock()</span><br><span class="line">    <span class="keyword">defer</span> ps.RUnlock()</span><br><span class="line">    s, subscribed := ps.subscriptions[topic]</span><br><span class="line">    <span class="keyword">if</span> !subscribed &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"no subscribers"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, sub := <span class="keyword">range</span> s.ToArray() &#123;</span><br><span class="line">        c := sub.(*subscription).c</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(c) == subscriptionBuffSize &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        c &lt;- item</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PubSub&quot;&gt;&lt;a href=&quot;#PubSub&quot; class=&quot;headerlink&quot; title=&quot;PubSub&quot;&gt;&lt;/a&gt;PubSub&lt;/h1&gt;&lt;p&gt;消息的发布和订阅这种设计模式在大型开源项目中还是会经常被使用到的，它的要点是一堆消息订阅者（ &lt;code&gt;S
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WebSocket</title>
    <link href="https://oceanoverflow.github.io/2018/05/05/WebSocket/"/>
    <id>https://oceanoverflow.github.io/2018/05/05/WebSocket/</id>
    <published>2018-05-05T02:52:04.000Z</published>
    <updated>2018-05-15T12:05:17.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>如果服务器会定期地更新消息，但是具体的时间间隔并不确定，客户端为了能够及时拿取最新的消息，就得不断的发送 <code>HTTP</code> 请求来轮询服务器，也就是说为了能够及时获取最新资讯，由于 <code>HTTP</code> 本身的特点，服务请求的发起方只能是客户端，服务器本身并没有消息推送的功能，这样就导致了资源浪费的问题，很多客户端发送的请求都是无效的，当客户端和服务器一对一交流时倒还好，如果很多客户端向服务器以这样的形式咨询，服务器将会承受非常大的压力了。</p><p>所以，为了避免资源浪费，我们来引入 <code>WebSocket</code> 解决上述问题，<code>WebSocket</code> 可以说是 <code>HTTP</code> 协议的一个升级，它同样基于 <code>TCP</code> 之上，但与传输层的 <code>socket</code> 不同，它的 <code>socket</code> 是应用层的概念。要想使用 <code>WebSocket</code> ，客户端和服务器必须同时支持才可以使用。</p><p><code>WebSocket</code> 中比较重要的一个阶段就是握手阶段了，如下图所示，客户端向服务器发送一个协议升级的 <code>HTTP</code> 请求，并且附带上一些其他的元信息用于握手。</p><p><img src="http://www.cuelogic.com/blog/wp-content/uploads/2013/11/websocketlifecycle_30624_l.png" alt="WebSocket"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Request headers from client</span><br><span class="line"></span><br><span class="line">GET /mychat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure><p>服务器收到该协议升级的 <code>HTTP</code> 请求后，会返回一个 <code>HTTP</code> 答复，向客户端确认同意建立 <code>WebSocket</code> 连接，从此之后，它们之间就不再用 <code>HTTP</code> 的形式交流了，而是直接改用 <code>WebSocket</code> 格式的报文进行交流，服务器也具备了相应推送消息的能力了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Response headers from server</span><br><span class="line"></span><br><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><p>下面我们来看一下使用 <code>&quot;github.com/gorilla/websocket&quot;</code> 时各个步骤对应的代码吧。</p><p>客户端代码的风格和使用 <code>TCP</code> 进行编程非常类似，第一步，客户端向服务器发送协议升级请求，对应<br><code>websocket.DefaultDialer.Dial(u.string(), nil)</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addr = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:8080"</span>, <span class="string">"http service addr"</span>)</span><br><span class="line">u := url.URL&#123;Scheme: <span class="string">"ws"</span>, Host: *addr, Path: <span class="string">"/echo"</span>&#125;</span><br><span class="line">log.Printf(<span class="string">"connecting to %s"</span>, u.String())</span><br><span class="line"></span><br><span class="line">c, _, err := websocket.DefaultDialer.Dial(u.<span class="keyword">string</span>(), <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">"dial:"</span>, err)</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br></pre></td></tr></table></figure><p>在服务端处理 <code>WebSocket</code> 请求与处理 <code>HTTP</code> 请求类似，我们同样需要定义一个 <code>handler</code> ，但与普通处理 <code>HTTP</code> 请求不同的是，此 <code>handler</code> 会对协议进行升级，也就是 <code>upgrader.Upgrade(w, r, nil)</code> ，这段代码相当于服务端向客户端发送一个协议升级的确认消息。在这之后，服务器就可以一直读取客户端发来的请求和向客户端返回答复了（代码的逻辑在 <code>for</code> 循环之中），也就是说服务器只起了一个 <code>handler</code> 来处理这段 <code>session</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    c, err := upgrader.Upgrade(w, r, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Print(<span class="string">"upgrade:"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> c.Close()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        mt, message, err := c.ReadMessage()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">"read:"</span>, err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        log.Printf(<span class="string">"recv: %s"</span>, message)</span><br><span class="line">        err = c.WriteMessage(mt, message)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">"write:"</span>, err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"echo"</span>, echo)</span><br><span class="line">    log.Fatal(http.ListenAndServe(*addr, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端在握手之后就可以读取和发送数据，在这里，由于在 <code>WebSocket</code> 中服务器可以主动向客户端推送数据，所以我们起一个 <code>goroutine</code> 专门用于接受服务器主动推送的数据（ <code>c.ReadMessage()</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        _, message, err := c.ReadMessage()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">"read:"</span>, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        log.Printf(<span class="string">"recv:"</span>, message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是客户端发送数据的逻辑，这里我们每隔一秒钟向服务器发送当前的时间，<code>c.WriteMessage(websocket.TextMessage, []byte(t.string()))</code> ，这里我们注意到，<code>WebSocket</code> 中的消息是有类型的，这个函数的第一个参数就是指明该消息的类型，这里我们使用 <code>websocket.TextMessage</code> 。</p><p>那么如何让这段 <code>session</code> 结束呢，结束会话一般来说都是客户端主动发起的，客户端主要发送一个结束对话的消息类型就可以了，<br><code>c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, &quot;&quot;))</code> ，这里注意该结束对话的消息类型为 <code>websocket.CloseMessage</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ticker := time.NewTicker(time.Second)</span><br><span class="line"><span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">interrupt := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(interrupt, os.Interrupt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">case</span> t := &lt;-ticker.C:</span><br><span class="line">        err := c.WriteMessage(websocket.TextMessage, []<span class="keyword">byte</span>(t.String()))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">"write:"</span>, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> &lt;-interrupt:</span><br><span class="line">        log.Println(<span class="string">"interrupt"</span>)</span><br><span class="line">        </span><br><span class="line">        err := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, <span class="string">""</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">"write close:"</span>, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;WebSocket&quot;&gt;&lt;a href=&quot;#WebSocket&quot; class=&quot;headerlink&quot; title=&quot;WebSocket&quot;&gt;&lt;/a&gt;WebSocket&lt;/h1&gt;&lt;p&gt;如果服务器会定期地更新消息，但是具体的时间间隔并不确定，客户端为了能够及时拿取最新的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>dep</title>
    <link href="https://oceanoverflow.github.io/2018/05/05/dep/"/>
    <id>https://oceanoverflow.github.io/2018/05/05/dep/</id>
    <published>2018-05-05T02:47:24.000Z</published>
    <updated>2018-05-15T11:44:24.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dep"><a href="#dep" class="headerlink" title="dep"></a>dep</h1><p>在写大型工程项目的时候，难免会依赖第三方的库（自己重复造轮子肯定不现实），如果依赖的库数量非常多时，自己去手动管理肯定是不现实的，所以我们需要一个依赖管理工具帮助我们管理依赖的库。就像 <code>node</code> 有 <code>npm</code> ，<code>java</code> 有 <code>maven</code> 。而 <code>golang</code> 之前一直没有一个官方推荐的依赖管理工具，所以第三方的依赖管理工具 <code>glide</code> ，<code>govendor</code> 之类的就应运而生，但由于不是官方出品的，自己用起来心里总有些毛毛的，后来，<code>golang</code> 官方终于推出了 <code>dep</code> 这个依赖管理工具，终于给我们这些强迫症患者安了一个心。下面我们就以一个demo为例子，看看<code>dep</code> 如何使用吧。</p><p><img src="https://github.com/golang/dep/raw/master/docs/assets/DigbyShadows.png" alt="godep"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>由于 <code>dep</code> 是一个命令行工具，安装起来也非常的方便，下面给出两种安装方式。</p><h4 id="二进制安装"><a href="#二进制安装" class="headerlink" title="二进制安装"></a>二进制安装</h4><p>这种安装方法通用型比较强，下面的命令会根据你的操作系统直接安装相应的二进制。</p><p><code>$ curl https://raw.githubusercontent.com/golang/dep/master/install.sh | sh</code></p><h4 id="macOS-安装"><a href="#macOS-安装" class="headerlink" title="macOS 安装"></a>macOS 安装</h4><p>但是 <code>macOS</code> 用户一般还是比较习惯于使用<code>brew</code> 的，使用 <code>brew</code> 也是<code>no-brainer</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew install dep</span><br><span class="line">$ brew upgrade dep</span><br></pre></td></tr></table></figure><h2 id="vendor-机制"><a href="#vendor-机制" class="headerlink" title="vendor 机制"></a>vendor 机制</h2><p>要了解 <code>dep</code> 存在的必要性就不得不提 <code>vendor</code> 机制了，我们都知道如果我们在 <code>go</code> 文件中导入一个非标准库，在编译时 <code>go</code> 会在 <code>$GOPATH</code> 下面去寻找它，但是这就导致一个问题，如果两个项目A和B同时用到了这个库，但是A和B对这个库的版本需求是不同的，这样就很难办了，毕竟在 <code>$GOPATH</code> 下面只能存在一个版本的库，所以为了解决这种情况，在<code>Go1.5</code>的时候，就出现 <code>vendor</code> 文件夹这个机制，也就是说，<code>go</code> 在编译项目的时候，会去这个项目目录下面寻找是否存在 <code>vendor</code> 这个文件夹，并且 <code>vendor</code> 下面是否存在我们需要的库，如果有则使用它，如果没有则去 <code>$GOPATH</code> 下去寻找。</p><p>例如项目C依赖 <code>github.com/aaa/bbb</code> 这个库，那么 <code>go</code> 在编译时回去查看当前项目目录下有没有<code>vendor/github.com/aaa/bbb</code> 这个文件夹目录，如果有则使用这个版本，如果没有再去 <code>$GOPATH</code> 下面去找。而 <code>dep</code> 就是为了帮我们管理 <code>vendor</code> 这个目录下面的依赖而存在的。</p><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>例如我们要写一个与 <code>WebSocket</code> 相关的项目，无奈 <code>golang</code> 的标准库里实现的 <code>WebSocket</code> 我们并不是非常满意，所以我们去 <code>github</code> 上面搜了一下，最后发现 <code>girilla</code> 家的 <code>websocket</code> 库还是比较符合我们项目的需求的，所以决定使用它。</p><p>第一步就是新建一个 <code>dep</code> 项目，使用 <code>dep init</code> 命令，会帮我们生成两个文件和一个空的 <code>vendor</code> 文件夹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ dep init</span><br><span class="line">$ ls</span><br><span class="line">Gopkg.toml Gopkg.lock vendor/</span><br></pre></td></tr></table></figure><p>然后我们写了一个 <code>main.go</code> 文件用于存放我们项目的所有逻辑（bad practice），这个文件除了标准库之外当然还导入了我们需要的 <code>websocket</code> 依赖。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"html/template"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">"github.com/gorilla/websocket"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>编辑完之后，在命令行中输入 <code>dep ensure</code> ，<code>dep</code> 会扫描我们当前项目中所有的依赖，并找出我们依赖的三方库，然后更新相应的文件（Gopkg.toml 和 Gopkg.lock），并更新我们的 <code>vendor</code> 文件夹，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Gopkg.lock</span><br><span class="line">├── Gopkg.toml</span><br><span class="line">├── main.go</span><br><span class="line">└── vendor</span><br><span class="line">    └── github.com</span><br><span class="line">        └── gorilla</span><br><span class="line">            └── websocket</span><br><span class="line">                ├── AUTHORS</span><br><span class="line">                ├── LICENSE</span><br><span class="line">                ├── README.md</span><br><span class="line">                ├── client.go</span><br><span class="line">                ├── client_clone.go</span><br><span class="line">                ├── client_clone_legacy.go</span><br><span class="line">                ├── compression.go</span><br><span class="line">                ├── conn.go</span><br><span class="line">                ├── conn_read.go</span><br><span class="line">                ├── conn_read_legacy.go</span><br><span class="line">                ├── doc.go</span><br><span class="line">                ├── json.go</span><br><span class="line">                ├── mask.go</span><br><span class="line">                ├── mask_safe.go</span><br><span class="line">                ├── prepared.go</span><br><span class="line">                ├── server.go</span><br><span class="line">                └── util.go</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>反正以后用 <code>dep</code> 作为go项目的依赖管理工具准没错的，如果你用 <code>glide</code> 或者 <code>govendor</code> 之类的还是趁早投靠 <code>dep</code> 吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;dep&quot;&gt;&lt;a href=&quot;#dep&quot; class=&quot;headerlink&quot; title=&quot;dep&quot;&gt;&lt;/a&gt;dep&lt;/h1&gt;&lt;p&gt;在写大型工程项目的时候，难免会依赖第三方的库（自己重复造轮子肯定不现实），如果依赖的库数量非常多时，自己去手动管理肯定是不现实的，所
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Crawler</title>
    <link href="https://oceanoverflow.github.io/2018/05/05/Crawler/"/>
    <id>https://oceanoverflow.github.io/2018/05/05/Crawler/</id>
    <published>2018-05-05T02:05:24.000Z</published>
    <updated>2018-05-15T11:38:13.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Crawler"><a href="#Crawler" class="headerlink" title="Crawler"></a>Crawler</h1><p>爬虫算是练习并发编程的一个非常好的例子了，因为它既不枯燥，难度也不大，而且能在短时间内产出一个有趣的结果。爬虫一般通过某种搜索算法（深度优先搜索或者广度优先搜索）在互联网这个海量数据库中去寻找我们感兴趣的东西，如果使用得当的话，爬虫可以极大地提高我们的工作效率。</p><p>那么接下去我们从一个单线程的爬虫程序出发，然后慢慢将它改造成一个并发的爬虫程序。在这里，我们并不关心究竟如何去匹配我们感兴趣的元素(例如使用CSS进行元素匹配)，而是给出一个爬虫的基本思路。</p><p>首先，爬虫中非常重要的一个步骤就是匹配当前搜索的网页中的元素，并将符合我们要求的东西下载或保存起来，并且还会记录当前网页中的超链接地址，以便于我们继续进行深度优先搜索或者广度优先搜索。一般来说，我们感兴趣的东西都是符合特定规则的，而具体的规则我们可以在单个网页上进行正则匹配来获取，但是，由于不同网页的匹配规则并不相同，所以我们定义一个interface来抽象该行为。在这之后无论我们想要爬豆瓣还是新浪微博亦或是其他自己感兴趣的网站，只要重新定义一个结构体实现该方法就可以。</p><p><code>Fetcher</code> 这个 <code>interface</code> 定义了如下行为，从一个特定的url去取我们感兴趣的内容以及这个网页上的所有的url链接。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">interface</span> &#123;</span><br><span class="line">    Fetch(url <span class="keyword">string</span>) (body <span class="keyword">string</span>, urls []<span class="keyword">string</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如我们要爬豆瓣网上的东西，我们只要定义好一个结构体，并且实现上述<code>Fetch</code> 方法就可以了。所以无论以后你决定改爬别的网站了，再定义如下的结构体并实现相应的方法就可以了，这就是为什么上面我们定义了一个 <code>Fetcher</code> interface 来抽象这个行为的原因了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">    body <span class="keyword">string</span></span><br><span class="line">    urls []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> doubanFetcher <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">map</span>[<span class="keyword">string</span>]*Result</span><br><span class="line">    sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *doubanFetcher)</span> <span class="title">Fetch</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(body <span class="keyword">string</span>, urls []<span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">     <span class="comment">// 这里写具体的匹配逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>爬虫还有一个重点就是搜索的策略，应该是广度优先还是深度优先，但是所有的链接形成为拓扑图并不一定是一个有向无环图，所以我们的爬虫在爬取的过程中可能会遇到相同的链接，但是注意这个逻辑同样应在在 <code>Fetch</code> 函数中实现。</p><h2 id="单线程版本实现"><a href="#单线程版本实现" class="headerlink" title="单线程版本实现"></a>单线程版本实现</h2><p>下面我们来看一下单线程深度优先的爬虫应该怎么写。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Crawl</span><span class="params">(url <span class="keyword">string</span>, depth <span class="keyword">int</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> depth &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body, urls, err := fetcher.Fetch(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Founf: %s %q\n"</span>, url, body)</span><br><span class="line">    <span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        Crawl(u, depth<span class="number">-1</span>, fetcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于是深度优先搜索，所以我们用递归的策略来进行搜索，递归最重要的一点就是递归条件的出口条件，如果递归函数没有出口，那么就是死循环了。这里我们在函数的参数中引入一个深度的变量来控制是否应该继续进行递归，如果当前深度小于等于0，则退出。然后用 <code>fether</code>  来 <code>Fetch</code> 对应的 <code>url</code>上的内容，由于使用了接口，所以让我们这个函数的实现变得非常的灵活，而不是局限于哪个具体的实现，这就是接口的好处。然后根据当前网页中的链接进行深度优先搜索，<code>Crawl(u, depth-1, fetcher)</code> ，每搜索一层，深度减一，直到条件不再满足就可以退出了。</p><p>不过上述的爬虫还是单线程的，单线程的效率肯定不高，因为程序大部分时间都是在等待 <code>I/O</code>，<code>CPU</code> 大部分时间都是空闲的，所以，为了提高 <code>CPU</code>的占用率，我们应该考虑使用并发。</p><h2 id="并发版本实现"><a href="#并发版本实现" class="headerlink" title="并发版本实现"></a>并发版本实现</h2><p>在 <code>golang</code> 里面写并发程序是相对比较简单的，但是也没有那么简单，下面的实现就是比较tricky的。这里为什么叫它并发而不是多线程呢，是因为<code>golang</code> 中的 <code>go</code> 机制并不是以线程作为基本单位的。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Crawl</span><span class="params">(url <span class="keyword">string</span>, depth <span class="keyword">int</span>, fetcher Fetcher, ret <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(ret)</span><br><span class="line">    <span class="keyword">if</span> depth &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body, urls, err := fetcher.Fetch(url) </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ret &lt;- err.Error()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    ret &lt;- fmt.Sprintf(<span class="string">"Found: %s %q"</span>, url, body)</span><br><span class="line"></span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="built_in">len</span>(urls))</span><br><span class="line">    <span class="keyword">for</span> i, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        result := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">        <span class="keyword">go</span> Crawl(u, depth<span class="number">-1</span>, fetcher, result)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line">        <span class="keyword">for</span> s := <span class="keyword">range</span> result[i] &#123;</span><br><span class="line">            ret &lt;- s</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并发版本和单线程版本的基本框架是一样的，有下面几个区别。</p><p>首先我们定义个一个 <code>chan string</code> 也就是一个通道，一般来说，<code>go</code> 和<code>chan</code> 都是手拉手用在一起的。这个通道用于接受我们爬虫的结果。</p><p>这个通道在整个函数返回时会关闭，也就是函数最初用的 <code>defer close(ret)</code> 。</p><p>当 <code>fetch.Fetch(url)</code> 方法返回时，也就是这个网页中的内容已经检索完毕了，我们将结果放到刚才的通道中等待其他地方的程序读取该通道中的内容。</p><p>下面就是函数的精髓了，由于上面通过 <code>fetch.Fetch(url)</code> 获得了一个<code>urls</code> 数组，因为要进行深度优先搜索，我们为这个 <code>urls</code> 中的 <code>url</code> 也准备一个 <code>chan string</code> 用于存储它们抓取的内容，然后调用 <code>go Crawl(u, depth-1, fetcher, result)</code> 来并发爬取。</p><p>也就是说下面这段函数很快就返回了，但是它们并不一定都已经拿到相应的内容了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">    result := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> Crawl(u, depth<span class="number">-1</span>, fetcher, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，我们要等待它们拿回内容，下面代码的意思就是子任务完成后，将它拿到的内容传给上一层的通道中。这个就好比在一个公司中，<code>CEO</code> 将任务分别分配给下面各个部门的 <code>Manager</code> ，然后各个部门的 <code>Manager</code> 又细分任务后将任务分给部门下面的各个 <code>Worker</code> ，<code>Worker</code> 完成自己的任务后，将任务结果传给负责自己的 <code>Manager</code> ，然后由 <code>Manager</code> 再汇报给 <code>CEO</code> 。<code>CEO</code> 是总任务的分配者同时也是所有结果的收集者。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line">    <span class="keyword">for</span> s := <span class="keyword">range</span> result[i] &#123;</span><br><span class="line">        ret &lt;- s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>并发程序能充分利用现在 <code>CPU</code> 的所有核心，它利用单线程程序运行中部分代码段会因为等待 <code>I/O</code>（例如发送http请求和等待http答复）而占用 <code>CPU</code> 时间的特点，同时启动多个 <code>goroutine</code> 来最大程度上占用 <code>CPU</code> 时间，从而提高程序的运行效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Crawler&quot;&gt;&lt;a href=&quot;#Crawler&quot; class=&quot;headerlink&quot; title=&quot;Crawler&quot;&gt;&lt;/a&gt;Crawler&lt;/h1&gt;&lt;p&gt;爬虫算是练习并发编程的一个非常好的例子了，因为它既不枯燥，难度也不大，而且能在短时间内产出一个有趣的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker &amp; Golang</title>
    <link href="https://oceanoverflow.github.io/2018/05/04/Docker/"/>
    <id>https://oceanoverflow.github.io/2018/05/04/Docker/</id>
    <published>2018-05-04T09:01:24.000Z</published>
    <updated>2018-05-15T11:44:49.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-amp-Golang"><a href="#Docker-amp-Golang" class="headerlink" title="Docker &amp; Golang"></a>Docker &amp; Golang</h1><p>还记得 <code>java</code> 当初响遍大江南北的口号吗，<code>Write one，run anywhere</code> ，到了互联网时代，<code>Docker</code> 这家公司打出了更为牛逼的口号，<code>Build，Ship，and Run Any App，Anywhere</code> ，它们两者有类似的地方，都是为了追求各种平台的兼容性和通用性。<code>java</code> 的跨平台是因为它在不同平台下有不同的 <code>jvm</code> 实现，不过它仅仅局限于 <code>java</code> 这个生态系统里面，相比之下，<code>Docker</code> 的野心就更大了，它并没有给我们把编程语言给限定死了，它提供了一个与操作系统隔离的环境，可以让我们写任何应用，而且可以在几乎所有平台下跑。</p><p>具体 <code>Docker</code> 的细节这里就不具体探讨了，网上也有一堆文章，今天我们主要看一下如何使用它，也就是如何将我们的应用打包成一个 <code>Docker</code> 镜像。</p><p>下面我们要实现的是一个用 <code>golang</code> 写的 <code>http</code> 服务器，但是这个服务器并不是跑在裸机上，而是跑在 <code>Docker</code> 容器中的。顺便一提，<code>Docker</code> 也是用 <code>golang</code> 写的哦，是不是感觉很厉害呢。</p><h2 id="书写自己的应用逻辑"><a href="#书写自己的应用逻辑" class="headerlink" title="书写自己的应用逻辑"></a>书写自己的应用逻辑</h2><p>下面定义了我们要实现的 <code>http</code> 服务器的前端，无奈直男不会写 <code>CSS</code> ，就用 <code>HTML</code> 写了一下最基本的提交 <code>FORM</code> 表单的功能。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/hash"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">            interface: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"interface"</span>&gt;</span></span><br><span class="line">            method: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"method"</span>&gt;</span></span><br><span class="line">            parameterTypesString: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"parameterTypesString"</span>&gt;</span></span><br><span class="line">            parameter: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"parameter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"hash"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面使用了golang中的标准库 <code>net/http</code> 和 <code>html/template</code> 起一个服务器，我们自己定义的 <code>hashHandler</code> 会根据请求的类型分别进行处理，如果是 <code>GET</code> 请求则展示我们的前端界面，如果是 <code>POST</code> 请求则处理我们浏览器提交的表单并将表单输出到命令行中。到这里，一个非常简单的 <code>http</code> 服务器就写好了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"html/template"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"method: "</span>, r.Method)</span><br><span class="line">    <span class="keyword">if</span> r.Method == <span class="string">"GET"</span> &#123;</span><br><span class="line">        t, _ := template.ParseFiles(<span class="string">"hash.tpl"</span>)</span><br><span class="line">        t.Execute(w, <span class="literal">nil</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.ParseForm()</span><br><span class="line">        <span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"key: %s, value: %s\n"</span>, k, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/hash"</span>, hashHandler)</span><br><span class="line">    err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dockerfile的撰写"><a href="#Dockerfile的撰写" class="headerlink" title="Dockerfile的撰写"></a>Dockerfile的撰写</h2><p>到现在，就没我们 <code>golang</code> 什么事情了，有请我们今天的主角 <code>Docker</code> 登场了。为了能让我们的 <code>http</code> 服务器在容器中运行，我们需要写一个 <code>Dockerfile</code> ，<code>Dockerfile</code> 的作用就是让 <code>Docker</code> 知道该如何构建镜像，当然平时大部分时候我们都可以直接用别人打包好的镜像，但是自己会写 <code>Dockerfile</code> 也是一个非常重要的能力哦。</p><p><code>FROM</code> 指令指定了我们的基础镜像是什么，也就是说我们构建的镜像是基于哪个镜像的基础之上的，这里 <code>golang:alpine</code> 作为我们的基础镜像。而<code>COPY</code> 指令则将我们的文件从操作系统中拷贝到容器环境中。<code>WORKDIR</code> 命令则制定了在 <code>Docker</code> 内部的工作目录，类似于 <code>cd</code> 命令，<code>RUN</code> 命令在容器中执行指令，这里我们把go源文件编译成二进制。<code>CMD</code> 指令指定了启动该容器时内部应该执行的命令。当然 <code>Dockerfile</code> 的命令还有很多，具体还是参考官方的文档吧。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:alpine</span><br><span class="line"><span class="keyword">COPY</span> . /home</span><br><span class="line">WORKDIR /home</span><br><span class="line">RUN go build -o server ./server.go</span><br><span class="line">CMD /home/server</span><br></pre></td></tr></table></figure><p>写完了 <code>Dockerfile</code> ，就可以构建镜像了，不过构建镜像的事情我可干不来，还是交给 <code>Docker</code> 去做吧。下面的命令就帮助我们构建一个名为 <code>oceanoverflow/server</code> 的 <code>golang</code> 服务器镜像。构建镜像的过程可能会比较花时间，需要耐心等待。</p><p><code>$ docker build -t oceanoverflow/server .</code></p><h2 id="运行Docker容器"><a href="#运行Docker容器" class="headerlink" title="运行Docker容器"></a>运行Docker容器</h2><p>构建完了我们使用 <code>docker image ls</code> 就可以看到我们新构建的镜像啦，最后一步就是起容器服务了。</p><p><code>-p</code> 命令这里将容器内的端口8080映射到操作系统的端口8080上去，如果不指定8080，那我们在自己的操作系统上就无法获取到它提供的服务，所以 <code>-p</code> 还是非常重要的。</p><p><code>$ docker run -p 8080:8080 --rm -it go-server</code></p><p>如果一切无误，到浏览器中输入 <code>localhost:8080/hash</code> 就可以看到我们跑在 <code>Docker</code> 里面的 <code>http</code> 服务器已经成功地跑起来啦。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>让自己的应用跑在 <code>Docker</code> 容器中非常简单，第一步就是构建自己的应用程序的源码，第二步正确编写适应自己业务场景的 <code>Dockerfile</code> 然后利用 <code>Docker</code> 自带的功能打包成一个镜像，最后一步就是运行容器了。就这么三步走，可谓是 <code>Docker</code>在手，天下我有了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker-amp-Golang&quot;&gt;&lt;a href=&quot;#Docker-amp-Golang&quot; class=&quot;headerlink&quot; title=&quot;Docker &amp;amp; Golang&quot;&gt;&lt;/a&gt;Docker &amp;amp; Golang&lt;/h1&gt;&lt;p&gt;还记得 &lt;c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Screenshot</title>
    <link href="https://oceanoverflow.github.io/2018/05/02/Screenshot/"/>
    <id>https://oceanoverflow.github.io/2018/05/02/Screenshot/</id>
    <published>2018-05-02T12:29:04.000Z</published>
    <updated>2018-05-15T11:47:33.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Golang获取手机屏幕截图"><a href="#使用Golang获取手机屏幕截图" class="headerlink" title="使用Golang获取手机屏幕截图"></a>使用Golang获取手机屏幕截图</h1><p>在今年年前的时候，像冲顶大会，芝士超人这样的答题赚钱类应用异常火爆，当然了，聪明的程序猿们也不是吃素的，为了提高答对题目的概率，就写了一些程序（脚本）来自动化答题过程，整个作弊的思路并不难，关键点就在于获取手机的当前截屏，然后通过文字识别来获取题目的信息，最后再调用浏览器搜索答案，在浏览器中出现最多的那个基本就可以锁定是答案了（当然还有其他的作弊方法，这里不一一列举），这种作弊方法在初期真是屡试不爽，所以今天就让我们来看一下整个作弊流程的关键环节——自动获取手机截屏的代码实现吧。</p><p>因为手机分为 <code>Android</code> 阵营和 <code>iOS</code> 阵营，而且两者实现截屏的方法也稍有不同，所以我们先定义一个 <code>Screenshot</code> interface对两种平台进行抽象，之后会分别定义 <code>iOS</code> 和 <code>Android</code> 这两个结构体来实现这个接口（有没有慢慢开始体会到 <code>interface</code> 的好处呢），下面的代码中我们也利用了工厂模式来返回 <code>Screenshot</code> 实例。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Screenshot <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetImage() (image.Image. error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewScreenshot</span><span class="params">(cfg *Config)</span> <span class="title">Screenshot</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> cfg.Device == <span class="string">"iOS"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> NewIOS(cfg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NewAndroid(cfg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config &#123;</span><br><span class="line">    Device     <span class="keyword">string</span></span><br><span class="line">    WdaAddress <span class="keyword">string</span></span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Android-实现"><a href="#Android-实现" class="headerlink" title="Android 实现"></a>Android 实现</h2><p>我们先定义个 <code>Android</code> 结构体，这个结构体实现了 <code>GetImage</code> 方法，所以可以在上面的工厂方法中作为 <code>Screenshot</code> 接口返回。而在真正运行我们的代码之前，我们需要确保安卓机已经正确地连接至电脑，并且要确保电脑上已经安装过 <code>adb</code> 这个命令行工具。这里实现截屏主要靠调用 <code>adb</code> 的 <code>screencap</code> 和 <code>pull</code> 这两个子命令，<code>screencap</code> 对当前手机进行截屏并保存到手机本地，<code>pull</code> 命令将手机上的截图传到电脑本地（然后就可以接着一通骚操作了），我们通过 <code>exec.Command</code> 接口对 <code>adb</code> 进行调用，整体思路比较清晰，难点应该就在我们不熟悉 <code>adb</code> 命令的使用。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Android <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAndroid</span><span class="params">(cfg *Config)</span> *<span class="title">Android</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(Android)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(android *Android)</span> <span class="title">GetImage</span><span class="params">()</span> <span class="params">(img image.Image, err error)</span></span> &#123;</span><br><span class="line">    err := exec.Command(<span class="string">"adb"</span>, <span class="string">"shell"</span>, <span class="string">"screencap"</span>, <span class="string">"-p"</span>. <span class="string">"/sdcard/screenshot.png"</span>).Run()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    dstImagePath := <span class="string">"/Desktop"</span> + <span class="string">"origin.png"</span></span><br><span class="line">    err = exec.Command(<span class="string">"adb"</span>, <span class="string">"pull"</span>, <span class="string">"/sdcard/screenshot.png"</span>, dstImgPath).Run()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    f, err := os.Open(dstImagePath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    <span class="keyword">return</span> png.Decode(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iOS-实现"><a href="#iOS-实现" class="headerlink" title="iOS 实现"></a>iOS 实现</h2><p>依葫芦画瓢，同样定义一个 <code>IOS</code> 结构体，来实现 <code>GetImage</code> 方法，在具体截屏的实现中，由于 <code>iOS</code> 系统的封闭性，所以自然没有像 <code>Android</code> 的 <code>adb</code> 那样的命令行调试工具，不过也不是说啥事也做不了，在 <code>iOS</code> 中，我们可以向特定接口地址 <code>wdaAddress</code> 发送 <code>http</code> 的<code>GET</code> 请求，然后通过解析返回的 <code>json</code> 数据，这个 <code>json</code> 数据中就编码了我们的图片信息，然后再利用 <code>base64</code> 进行解码获得一个字节数组，再对该字节数组进行 <code>png</code> 解码，最终就可以获得我们想要的 <code>image</code> 了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IOS <span class="keyword">struct</span> &#123;</span><br><span class="line">    wdaAddress <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> screenshotRes &#123;</span><br><span class="line">    Value     <span class="keyword">string</span> <span class="string">`json:"value"`</span></span><br><span class="line">    SessionID <span class="keyword">string</span> <span class="string">`json:"sessionId"`</span></span><br><span class="line">    Status    <span class="keyword">int</span>    <span class="string">`json:"status"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIOS</span><span class="params">(cfg *Config)</span> *<span class="title">IOS</span></span> &#123;</span><br><span class="line">    ios := <span class="built_in">new</span>(IOS)</span><br><span class="line">    ios.wdaAddress = cfg.WdaAddress</span><br><span class="line">    <span class="keyword">if</span> ios.wdaAddress == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"Please specify the wda address"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ios</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ios *IOS)</span> <span class="title">GetImage</span><span class="params">()</span> <span class="params">(img image.Image, err error)</span></span> &#123;</span><br><span class="line">    body, err := util.HTTPGet(ios.wdaAddress)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    res := <span class="built_in">new</span>(screenshotRes)</span><br><span class="line">    err = json.Unmarshal(body, res)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    pngValue, err := base64.stdEncoding.DecodeString(res.Value)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    src, err := png.Decode(bytes.NewReader(pngValue))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    img = src</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本篇博客中，我们看到了工厂模式在具体程序设计中的应用，灵活使用工厂模式可以提供我们工程代码的水平，也见识到了如何利用 <code>adb</code> 工具对 <code>Android</code> 机器进行调试，当然了 <code>adb</code> 的功能不仅仅局限于上述两点，它还可以干非常多的事情，有兴趣的小伙伴可以自己研究一下，最后还有就是因为 <code>iOS</code> 系统本身的封闭性，我们只能通过调用web接口来获取其截图信息。</p><p>最后，作为程序员圈子里的一员，在日常生活中还是要多思考，啥东西要是可以用代码实现自动化，就马上动手去实现它吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用Golang获取手机屏幕截图&quot;&gt;&lt;a href=&quot;#使用Golang获取手机屏幕截图&quot; class=&quot;headerlink&quot; title=&quot;使用Golang获取手机屏幕截图&quot;&gt;&lt;/a&gt;使用Golang获取手机屏幕截图&lt;/h1&gt;&lt;p&gt;在今年年前的时候，像冲顶大会
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Load Balancing Using etcd</title>
    <link href="https://oceanoverflow.github.io/2018/05/02/LoadBalancing/"/>
    <id>https://oceanoverflow.github.io/2018/05/02/LoadBalancing/</id>
    <published>2018-05-02T10:12:24.000Z</published>
    <updated>2018-05-15T11:50:10.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-etcd-进行负载均衡"><a href="#使用-etcd-进行负载均衡" class="headerlink" title="使用 etcd 进行负载均衡"></a>使用 etcd 进行负载均衡</h1><p>当服务提供者（Service Provider）将服务注册到 <code>etcd</code> 之后，为了更加理想地分配任务·，我们就要考虑负载均衡问题了，负载均衡的核心就是把让任务合理地分摊到多个执行单元上执行，以期获得更高的吞吐量或者说是数据处理能力，通俗点讲就是大家都有肉吃，没有人会撑死也没人会饿死，大家都得到适合自己的那一份。</p><p>下图中，<code>Service Consumer</code> 即服务的消费者，它通过向 <code>Provider</code> 源源不断地发送服务请求，负载均衡问题要解决的问题就是如何将请求合理地分配给不同的 <code>Service Provider</code> 处理，例如，我们下图中有三台服务提供者，假如服务提供者的服务都是比较消耗时间的（例如计算哈希值），为了增加整个系统的吞吐量，我们要考虑合适的任务分配策略，这就是负载均衡的核心所在，要是只将请求发送给其中一台 <code>Service Provider</code>，那么其它两台都会空闲着不执行任务，这样的话整个系统的吞吐量肯定就上不来了，毕竟没有充分的利用所有的资源，所以，我们要把任务平均地分配给每个执行单元去处理。</p><p><img src="https://code.aliyun.com/middlewarerace2018/docs/raw/master/assets/system-architecture.png" alt="loadbalancing"></p><p>下面我们来实现一个负载均衡的例子，实现的思路非常简单，定义一个 <code>LoadBalancingService</code> 结构体，其中的 <code>etcdClient</code> 用于与 <code>etcd</code> 进行沟通交流以获取相应的注册信息，<code>nodes</code>，<code>nodeMap</code>，<code>nodeCount</code> 用于记录已经注册在 <code>etcd</code> 的服务提供者的信息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LoadBalancingService <span class="keyword">struct</span> &#123;</span><br><span class="line">    etcdClient client.Client</span><br><span class="line">    connected  <span class="keyword">bool</span></span><br><span class="line">    nodes      []<span class="keyword">string</span></span><br><span class="line">    nodeMap    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">    nodeCount  <span class="keyword">int</span></span><br><span class="line">    sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *LoadBalancingService)</span> <span class="title">watch</span><span class="params">(watcher client.Watcher)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        resp, err := watcher.Next(context.Background())</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> resp.Action == <span class="string">"set"</span> &#123;</span><br><span class="line">                n := resp.Node.Value</span><br><span class="line">                s.addNode(n)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> resp.Action == <span class="string">"delete"</span> &#123;</span><br><span class="line">                n := resp.PrevNode.Value</span><br><span class="line">                s.removeNode(n)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的核心就是 <code>Watcher</code> 机制，在新事件到来之前，<code>Watcher</code> 的<code>Next</code> 方法会一直阻塞，直到事件返回为止，一般来说都是在 <code>for</code> 循环中调用 <code>Next</code> 以期达到轮询（polling）的效果。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Watcher <span class="keyword">interface</span> &#123;</span><br><span class="line">    Next(context.Context) (*Response, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Connect</code> 函数就是用于客户端与 <code>etcd</code> 连接并根据 <code>serviceName</code> 读取当前已经注册过的服务，并通过 <code>watch</code> 机制不断地更新当前可用的服务。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span>  <span class="params">(s *LoadBalancingService)</span> <span class="title">Connect</span><span class="params">(serviceName <span class="keyword">string</span>, endPoints []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s.connected &#123;</span><br><span class="line">        log.Println(<span class="string">"Can't connect twice"</span>)</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"Already connected"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.nodeMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    s.nodeCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    cfg := client.Config&#123;</span><br><span class="line">        Endpoints:   endpoints,</span><br><span class="line">        Transport:   client.DefaultTransport,</span><br><span class="line">        HeaderTimeoutPerRequest: time.Second,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    s.etcdClient, err = client.New(cfg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    kapi := client.NewKeysAPI(s.etcdClient)</span><br><span class="line"></span><br><span class="line">    resp, err := kapi.Get(context.Background(), serviceName, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> resp.Node.Dir &#123;</span><br><span class="line">            <span class="keyword">for</span> _, peer := resp.Node.Nodes &#123;</span><br><span class="line">                n := peer.Value</span><br><span class="line">                s.addNode(n)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    watcher := kapi.Watcher(serviceName, &amp;client.WatcherOptions&#123;Recursive: <span class="literal">true</span>&#125;)</span><br><span class="line">    <span class="keyword">go</span> s.watch(watcher)</span><br><span class="line">    service.connected = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetNode</code> 采用了随机算法获取当前节点群中的随机节点进行处理我们的任务，这里是负载均衡算法的核心，说白了中随机挑选一个进行发送服务请求让服务提供者进行处理。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *LoadBalancingService)</span> <span class="title">GetNode</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !s.connected &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"Must call connect first"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.RLock()</span><br><span class="line">    <span class="keyword">defer</span> s.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s.nodeCount == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, ErrEmptyService </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.nodes[rand.Intn(s.nodeCount)], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addNode</code> 和 <code>removeNode</code> 分别对应远程服务提供者数量增加或者减少时的情况，并更新 <code>LoadBalancingService</code> 结构体中相应的数据结构。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *LoadBalancingService)</span> <span class="title">addNode</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    s.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _, ok := s.nodeMap[key]; ok &#123;</span><br><span class="line">        <span class="keyword">if</span> s.nodeCount &gt;= <span class="built_in">len</span>(s.nodes) &#123;</span><br><span class="line">            s.nodes = <span class="built_in">append</span>(s.nodes, key)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.nodes[s.nodeCount] = key</span><br><span class="line">        &#125;</span><br><span class="line">        s.nodeMap[key] = s.nodeCount</span><br><span class="line">        s.nodeCount++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *LoadBalancingService)</span> <span class="title">removeNode</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    s.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> index, ok := s.nodeMap[key]; ok &#123;</span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt; <span class="built_in">len</span>(s.nodes)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">            s.nodes[i] = s.nodes[i+<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        s.nodeCount--</span><br><span class="line">        <span class="built_in">delete</span>(s.nodeMap, key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="负载均衡算法的改良"><a href="#负载均衡算法的改良" class="headerlink" title="负载均衡算法的改良"></a>负载均衡算法的改良</h2><p>在上面的例子中，我们采用的是随机算法，这种是基于每台处理任务的 <code>Service Provider</code> 性能差不多的情况下作出的抉择，但是现实生活中情况并不总是如此，每台服务器的性能，网络带宽都存在着或多或少的差异，所以，我们需要根据实际情况，对负载均衡的分配方法作相应的改进。</p><p>假设我们的服务提供者的平均综合性能比值为1:2:3，那么每台服务提供者任务分配的比例也应该是1:2:3，所谓能者多劳就是这个意思了。在其他情况下我们也可以根据流量比例分配任务，反正还是要具体问题具体分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用-etcd-进行负载均衡&quot;&gt;&lt;a href=&quot;#使用-etcd-进行负载均衡&quot; class=&quot;headerlink&quot; title=&quot;使用 etcd 进行负载均衡&quot;&gt;&lt;/a&gt;使用 etcd 进行负载均衡&lt;/h1&gt;&lt;p&gt;当服务提供者（Service Provide
      
    
    </summary>
    
    
  </entry>
  
</feed>
