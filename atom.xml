<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Whyyy</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://oceanoverflow.github.io/"/>
  <updated>2018-05-22T03:51:22.076Z</updated>
  <id>https://oceanoverflow.github.io/</id>
  
  <author>
    <name>Yangyi, Yi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GUID</title>
    <link href="https://oceanoverflow.github.io/2018/05/22/GUID/"/>
    <id>https://oceanoverflow.github.io/2018/05/22/GUID/</id>
    <published>2018-05-22T03:49:08.000Z</published>
    <updated>2018-05-22T03:51:22.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GUID"><a href="#GUID" class="headerlink" title="GUID"></a>GUID</h1><p>在点外卖或者网上购物的时候，每个订单中都会有一串独一无二的数字，但是处理订单的服务器肯定不止一台，如何保证多台服务器，也就是说一个计算机集群中，在相互独立的情况下（不沟通自己生成的订单号的信息）不生成相同的订单号码呢，下面我们就来介绍一种全球唯一标识符（ <code>GUID</code> ）的生成算法。</p><p>这里我们的 <code>GUID</code> 共64比特。<code>sequence</code> 部分占12比特，<code>nodeID</code> 占10比特，偏移10比特，时间戳 <code>timestamp</code> 占剩余的42比特，偏移22比特。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------------------+----------+------------+</span><br><span class="line">|                timestamp                  |nodeIDBits|sequenceBits|</span><br><span class="line">+-------------------------------------------+----------+------------+</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    nodeIDBits = <span class="keyword">uint64</span>(<span class="number">10</span>)</span><br><span class="line">    sequenceBits = <span class="keyword">uint64</span>(<span class="number">12</span>)</span><br><span class="line">    nodeIDShift = sequenceBits</span><br><span class="line">    timestampShift = sequenceBits + nodeIDBits</span><br><span class="line">    sequenceMask   = <span class="keyword">int64</span>(<span class="number">-1</span>) ^ (<span class="keyword">int64</span>(<span class="number">-1</span>) &lt;&lt; sequenceBits)</span><br><span class="line"></span><br><span class="line">    twepoch = <span class="keyword">int64</span>(<span class="number">1288834974288</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrIDBackwards = errors.New(<span class="string">"ID went backward"</span>)</span><br><span class="line">    ErrTimeBackwards = errors.New(<span class="string">"time has gone backwards"</span>)</span><br><span class="line">    ErrSequenceExpired = errors.New(<span class="string">"sequence expired"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>下面我们定义一个生成 <code>guid</code> 的工厂， <code>guid</code> 由 <code>timestamp</code>  ，<code>nodeID</code> 和 <code>sequence</code> 这三个部分构成，每个工厂有自己的 <code>nodeID</code>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> guid <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> guidFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Metex</span><br><span class="line">    nodeID        <span class="keyword">int64</span></span><br><span class="line">    sequence      <span class="keyword">int64</span></span><br><span class="line">    lastTimestamp <span class="keyword">int64</span></span><br><span class="line">    lastID        guid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGUIDFactory</span><span class="params">(nodeID <span class="keyword">int64</span>)</span> *<span class="title">guidFactory</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;guidFactory&#123;</span><br><span class="line">        nodeID: nodeID,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在利用工厂模式生成 <code>GUID</code> 时，首先计算当前时间戳，并且除以1048576（2的20次方），这样是为了去除时间的假随机部分，如果新生成的<code>timestamp</code> 小于 <code>lastTimestamp</code> ，则返回 <code>ErrTimeBackwards</code> 错误，对于相同的时间戳，我们的 <code>sequence</code> 采取递增策略，如果 <code>sequence</code> 达到最大值后归0，则返回 <code>ErrSequenceExpired</code> 错误，如果时间戳不相同，则令 <code>sequence</code> 重新从0开始，最后使三部分拼接组成一个新的 <code>guid</code> ，如果生成的 <code>guid</code> 小于 <code>lastID</code> ，则返回 <code>ErrIDBackwards</code> 错误，如果正常则返回结果。整个计算的过程需要由锁来保护。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *guidFactory)</span> <span class="title">Create</span><span class="params">()</span> <span class="params">(guid, error)</span></span> &#123;</span><br><span class="line">    f.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// divide by 1048576, giving pseudo-milliseconds</span></span><br><span class="line">    ts := time.Now().UnixNano() &gt;&gt; <span class="number">20</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ts &lt; f.lastTimestamp &#123;</span><br><span class="line">        f.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, ErrTimeBackwards</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> f.lastTimestamp == ts &#123;</span><br><span class="line">        f.sequence = (f.sequence + <span class="number">1</span>) &amp; sequenceMask</span><br><span class="line">        <span class="keyword">if</span> f.sequence == <span class="number">0</span> &#123;</span><br><span class="line">            f.Unlock()</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, ErrSequenceExpired</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        f.sequence = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f.lastTimestamp = ts</span><br><span class="line"></span><br><span class="line">    id := guid(((ts - twepoch) &lt;&lt; timestampShift) |</span><br><span class="line">        (f.nodeID &lt;&lt; nodeIDShift) |</span><br><span class="line">        f.sequence)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> id &lt;= f.lastID &#123;</span><br><span class="line">        f.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, ErrIDBackwards</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f.lastID = id</span><br><span class="line"></span><br><span class="line">    f.Unlock()</span><br><span class="line"></span><br><span class="line">    return id, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便结果的表示，我们会将10进制转换为16进制，利用标准库中的 <code>hex</code> 就可以轻松实现了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g guid)</span> <span class="title">Hex</span><span class="params">()</span> <span class="title">MessageID</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> h MessageID</span><br><span class="line">    <span class="keyword">var</span> b [<span class="number">8</span>]<span class="keyword">byte</span></span><br><span class="line">    </span><br><span class="line">    b[<span class="number">0</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">56</span>)</span><br><span class="line">    b[<span class="number">1</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">48</span>)</span><br><span class="line">    b[<span class="number">2</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">40</span>)</span><br><span class="line">    b[<span class="number">3</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">32</span>)</span><br><span class="line">    b[<span class="number">4</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">24</span>)</span><br><span class="line">    b[<span class="number">5</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">16</span>)</span><br><span class="line">    b[<span class="number">6</span>] = <span class="keyword">byte</span>(g &gt;&gt; <span class="number">8</span>)</span><br><span class="line">    b[<span class="number">7</span>] = <span class="keyword">byte</span>(g)</span><br><span class="line"></span><br><span class="line">    hex.Encode(h[:], b[:])</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GUID&quot;&gt;&lt;a href=&quot;#GUID&quot; class=&quot;headerlink&quot; title=&quot;GUID&quot;&gt;&lt;/a&gt;GUID&lt;/h1&gt;&lt;p&gt;在点外卖或者网上购物的时候，每个订单中都会有一串独一无二的数字，但是处理订单的服务器肯定不止一台，如何保证多台服务器，也就是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mpg123</title>
    <link href="https://oceanoverflow.github.io/2018/05/21/mpg123/"/>
    <id>https://oceanoverflow.github.io/2018/05/21/mpg123/</id>
    <published>2018-05-21T11:12:06.000Z</published>
    <updated>2018-05-21T11:17:16.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mpg123"><a href="#mpg123" class="headerlink" title="mpg123"></a>mpg123</h1><p>日常生活中，我们都是使用网易云音乐之类的音乐软件听歌，但是你有没有想过，作为程序员，该如何使用命令行来听（zhuang）歌（bi）呢？今天就让我们来实现这个功能吧。</p><p>写代码，一般需要搞清楚三点，输入，输出和算法。如果使用命令行听歌，输入很明确，肯定是音频数据流，数据一般可以通过网上获取，那么输出呢，肯定就是我们耳朵中听到的声音，这两点都比较简单。关键是处理数据和输出数据的算法，之前并没有怎么搞过音乐格式编码和解码之类的东西，不过不要慌，已经有强大的 <code>mpg123</code> 这个命令行工具帮我们搞定这类事情了。</p><p><code>mpg123</code> 需要额外安装，<code>macOS</code> 用户可以使用 <code>homebrew</code> 进行安装。<code>mpg123</code> 可以帮助我们处理 <code>MPEG 1.0/2.0/2.5</code> 格式的数据流，并使用系统默认的音屏设备播放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mpg123 [ options ] file-or-URL...</span><br></pre></td></tr></table></figure><p>上面是它的简单使用，<code>[options]</code> 代表额外选项，真正的参数可以是本地音频文件地址或者 <code>URL</code> 地址。一般来说 <code>file/URL</code> 都需要是 <code>MPEG</code> 格式的音频比特流（ <code>audio bit stream</code> ）。</p><p>问题的关键解决之后，下面就可以利用它写一个简单的音乐播放器了，这里播放器具有两种状态，<code>Stopped</code> 和 <code>Playing</code> ，播放器的核心操作依赖 <code>mpg123</code> 实现，<code>exec.Cmd</code> 用于代表这个命令。除此之外，还需要指定输入和输出，输入（ <code>io.ReadCloser</code> ）可以来自 <code>HTTP</code> 得到的数据流，而输出（ <code>io.WriteCloser</code> ）则是该命令的输入管道。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> State <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Stopped State = <span class="literal">iota</span></span><br><span class="line">    Playing</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Player <span class="keyword">struct</span> &#123;</span><br><span class="line">    state      State</span><br><span class="line">    currentURL <span class="keyword">string</span></span><br><span class="line">    mpg123     *exec.Cmd</span><br><span class="line">    src        io.ReadCloser</span><br><span class="line">    dst        io.WriteCloser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为播放音乐需要 <code>mpg123</code> 这个依赖，所以，在程序运行时需要检查其是否存在，<code>exec.LookPath</code> 会在系统路径（ <code>$PATH</code> ）下面寻找，如果不存在，则返回 <code>error</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPlayer</span><span class="params">()</span> <span class="params">(*Player, error)</span></span> &#123;</span><br><span class="line">    _, err := exec.LookPath(<span class="string">"mpg123"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    p := &amp;Player&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> p, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令行听歌的关键还是在于对数据流的处理，通过 <code>io.Copy</code> 方法将数据流进行重定向。 </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stream</span><span class="params">(dst io.WriteCloser, src io.ReadCloser)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> dst.Close()</span><br><span class="line">    <span class="keyword">defer</span> src.Close()</span><br><span class="line">    io.Copy(dst, src)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>mpg123</code> 需要读取音频数据流，在构造命令时，我们使用 <code>-</code> 来指定<code>mpg123</code> 从标准输入中获取数据（ <code>exec.Command(&quot;mpg123&quot;, &quot;-q&quot;, &quot;-&quot;)</code> ），通过 <code>StdinPipe()</code> 方法可以获得连接到此命令的标准输入管道。输入的数据流可以利用 <code>http.Get</code> 获取，然后再利用上述 <code>stream</code> 方法将数据流重定向到 <code>mpg123</code> 的标准输入（ <code>stdin</code> ）中去，这样就可以实现音乐播放了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Player)</span> <span class="title">Play</span><span class="params">(URL <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p.state == Playing &#123;</span><br><span class="line">        p.Stop()</span><br><span class="line">        <span class="keyword">return</span> p.Play(URL)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mpg123 := exec.Command(<span class="string">"mpg123"</span>, <span class="string">"-q"</span>, <span class="string">"-"</span>)</span><br><span class="line">    stdin, err := mpg123.StdinPipe()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        stdin.Close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    err = mpg123.Start()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        stdin.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response, err := http.Get(URL)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.state = Playing</span><br><span class="line">    p.currentURL = URL</span><br><span class="line">    p.mpg123 = mpg123</span><br><span class="line">    p.src = response.Body</span><br><span class="line">    p.dst = stdin</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> stream(p.dst, p.src)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个音乐播放器自然少不了暂停操作。因为输入和输出分别是 <code>io.ReadCloser</code> 和 <code>io.WriteCloser</code> 类型，所以都可以调用 <code>Close</code> 方法来将它们关闭。除此之外还需要将对应的 <code>mpg123</code> 的进程停掉（ <code>p.mpg123.Process.Kill()</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Player)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p.state == Stopped &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    p.state = Stopped</span><br><span class="line">    p.src.Close()</span><br><span class="line">    p.src = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    p.dst.Close()</span><br><span class="line">    p.mpg123.Process.Kill()</span><br><span class="line">    p.mpg123.Wait()</span><br><span class="line">    p.mpg123.Handler = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下最后一个问题就是如何获取各大平台音乐的链接地址，下面给获取网易云音乐歌曲外链地址的方法，这里的参数 <code>id</code> 表示音乐的 <code>id</code> ，其他平台获取方法也应该类似，感兴趣的读者可以自行寻找。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMusicLink</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    s := <span class="string">"http://music.163.com/song/media/outer/url?id=%d.mp3"</span></span><br><span class="line">    addr = fmt.Sprintf(s, id)</span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mpg123&quot;&gt;&lt;a href=&quot;#mpg123&quot; class=&quot;headerlink&quot; title=&quot;mpg123&quot;&gt;&lt;/a&gt;mpg123&lt;/h1&gt;&lt;p&gt;日常生活中，我们都是使用网易云音乐之类的音乐软件听歌，但是你有没有想过，作为程序员，该如何使用命令行来听（z
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Future</title>
    <link href="https://oceanoverflow.github.io/2018/05/20/Future/"/>
    <id>https://oceanoverflow.github.io/2018/05/20/Future/</id>
    <published>2018-05-20T06:04:59.000Z</published>
    <updated>2018-05-20T06:05:42.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p><code>Future</code> 是 <code>java</code> 中比较常见的并发编程解决方案，它采用异步的方式，尽可能减少运行时代码阻塞，很大程度上提高了程序的运行效率，在<code>golang</code> 中我们可以利用 <code>goroutine</code> ， <code>chan</code> 机制和 <code>for select</code> 轻松实现类似的功能。</p><p>其实 <code>Future</code> 的本质就是异步计算的结果，我们用 <code>item interface{}</code> 来放置 <code>Future</code> 的结果，通过读取 <code>triggered</code> 的值来判断异步计算是否已经返回。</p><p><code>New</code> 方法用于构造 <code>Future</code> 任务，它通过监听 <code>Completer</code> 通道来获取异步执行的结果，如果监听超时，则停止监听，返回错误。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Future <span class="keyword">struct</span> &#123;</span><br><span class="line">    triggered <span class="keyword">bool</span></span><br><span class="line">    item      <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    err       error</span><br><span class="line">    lock      sync.Mutex</span><br><span class="line">    wg        sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Completer &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(completer Completer, timeout time.Duration)</span> *<span class="title">Future</span></span> &#123;</span><br><span class="line">    f := &amp;Future&#123;&#125;</span><br><span class="line">    f.wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> listen(f, completer, timeout)</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>listen</code> 是获得异步计算结果的核心，如果 <code>Completer</code> 通道返回，则通过 <code>set</code> 方法设置计算结果，并标记 <code>triggered</code> 为 <code>true</code> ，如果监听超时，则同样标记 <code>triggered</code> 为 <code>true</code> ，但此时应该返回一个错误而非正确的计算结果。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">(f *Future, ch Completer, timeout time.Duration)</span></span> &#123;</span><br><span class="line">    t := time.NewTicker(timeout)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> item := &lt;-ch:</span><br><span class="line">        f.set(item, <span class="literal">nil</span>)</span><br><span class="line">        t.Stop()</span><br><span class="line">    <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">        f.set(<span class="literal">nil</span>, fmt.Errorf(<span class="string">`timeout after %f seconds`</span>, timeout.Seconds()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>Future</code> 返回结果的时机并不确定， 所以我们需要一种方式得知结果是否已经返回，<code>IsDone</code> 方法通过查询 <code>triggered</code> 是否为 <code>true</code> 来得知结果是否已经返回 ，也就是查询事件是否已经触发，这里结果返回和发生超时都可以触发事件。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Future)</span> <span class="title">IsDone</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    done := f.triggered</span><br><span class="line">    f.lock.Unlock()</span><br><span class="line">    <span class="keyword">return</span> done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以无论是结果返回，还是超时发生，我们都要通过 <code>set</code> 方法对 <code>Future</code> 进行设置，来标记 <code>Future</code> 事件完成。设置完通过 <code>f.wg.Done()</code> 来通知所有等待此结果的监听者。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Future)</span> <span class="title">set</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    f.triggered = <span class="literal">true</span></span><br><span class="line">    f.item = item</span><br><span class="line">    f.err = err</span><br><span class="line">    f.lock.Unlock()</span><br><span class="line">    f.wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>Get</code> 方法用于获得 <code>Future</code> 执行的结果，如果此时 <code>Future</code> 已经触发，那么可以直接返回结果，但是如果此时 <code>triggered</code> 为 <code>false</code> ，也就是说那两件事件中一件都没有发生，此时我们只能傻傻地等待（ <code>f.wg.Wait()</code> ） ，直到别人广播（ <code>f.wg.Done()</code> ）来告知事件已经发生。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Future)</span> <span class="title">Get</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    <span class="keyword">if</span> f.triggered &#123;</span><br><span class="line">        f.lock.Unlock()</span><br><span class="line">        <span class="keyword">return</span> f.item, f.err</span><br><span class="line">    &#125;</span><br><span class="line">    f.lock.Unlock()</span><br><span class="line">    </span><br><span class="line">    f.wg.Wait()</span><br><span class="line">    <span class="keyword">return</span> f.item, f.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是应用 <code>Future</code> 的简单例子。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">completer := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">f := New(completer, time.Duration(<span class="number">30</span>*time.Minute))</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    result, err = f.Get()</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">completer &lt;- <span class="string">`test`</span></span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Future&quot;&gt;&lt;a href=&quot;#Future&quot; class=&quot;headerlink&quot; title=&quot;Future&quot;&gt;&lt;/a&gt;Future&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Future&lt;/code&gt; 是 &lt;code&gt;java&lt;/code&gt; 中比较常见的并发编程解决方案
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ADB</title>
    <link href="https://oceanoverflow.github.io/2018/05/19/ADB/"/>
    <id>https://oceanoverflow.github.io/2018/05/19/ADB/</id>
    <published>2018-05-19T07:38:54.000Z</published>
    <updated>2018-05-19T07:48:33.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ADB"><a href="#ADB" class="headerlink" title="ADB"></a>ADB</h1><p>安卓手机相对 <code>iPhone</code> 来说生态系统更加开放，可以做各种各样酷酷的事情，例如通过自己电脑上的命令行来刷刷朋友圈之类的，下面我们来看看如何通过 <code>adb</code> 这个神器来控制我们的安卓机吧。</p><p><code>adb</code> ，全称是 <code>Android Debug Bridge</code> ，也就是安卓调试桥，实际上就是一个命令行工具（并没有这么简单），通过它，我们就可以使用一系列命令来控制我们的手机了。</p><h2 id="adb-架构"><a href="#adb-架构" class="headerlink" title="adb 架构"></a>adb 架构</h2><p>为了更好的理解，我们先来看一下 <code>adb</code> 的基本架构，在整个架构中存在三个重要的组件，<code>client</code> ，<code>ADB Server</code> 和 <code>ADB Daemon</code> 。各个组件之间通过 <code>TCP/IP</code> 或者 <code>USB</code> 进行通信来交流信息。</p><p><img src="https://3.bp.blogspot.com/-IWnB96a3IpI/WmYNlJ_lJ5I/AAAAAAAAADg/6CUlgATGJtYVwrJeTq5lzo1PxAQb2oJtQCLcBGAs/s640/android_buffer_adb_command.png" alt="ADB"></p><ul><li><p>client<br>客户端，用于向 <code>ADB Server</code> 发送命令的工具，可以是命令行工具（ <code>Terminal</code> ）或者是 <code>Android Studio</code> ，存在于我们自己电脑上。</p></li><li><p>ADB Server<br>电脑上的客户端和手机中守护进程之间的中介，类似一座桥（这就是为什么<code>adb</code> 叫做桥的原因了），主要负责两者之间的通信，在本地计算机上作为后台进程运行。我们可以通过 <code>grep</code>  <code>ps</code> 命令的输出，来发现守护进程 <code>adb</code> 正在监听的 <code>TCP</code> 端口。 </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps -e | grep adb</span><br><span class="line">adb -L tcp:5037 fork-server server --reply-fd 4</span><br></pre></td></tr></table></figure><ul><li>ADB Daemon<br>存在于手机之上的守护进程，负责接受并处理来自 <code>ADB Server</code> 的消息。类似的，我们可以通过 <code>adb shell ps | grep adbd</code> 来寻找手机上的<code>adbd</code> 进程及相应的 <code>pid</code> 。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell ps | grep adbd</span><br><span class="line">shell        13336     1   14532    812 0     0 S adbd</span><br></pre></td></tr></table></figure><p>也就是说 <code>client</code> 和 <code>adb server</code> 存在于宿主机之上，采用传统的 <code>C/S</code> 模型，而 <code>adb server</code> 通过 <code>TCP</code> 或 <code>USB</code> 来向手机上的 <code>adb daemon</code> 发送消息。</p><h2 id="adb-通信"><a href="#adb-通信" class="headerlink" title="adb 通信"></a>adb 通信</h2><p>通信肯定会涉及到协议，只有通信的双方都遵守协议才能顺利运行，下面是 <code>abd</code> 协议报文的基本结构，与 <code>HTTP</code> 协议类似，<code>abd</code> 协议同样也处于应用层。传输层既可以采用 <code>USB</code> 来传送，也可以使用我们熟悉的 <code>TCP/IP</code> 。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned command; /* command identifier constant /</span><br><span class="line">unsigned arg1; / first argument /</span><br><span class="line">unsigned arg2; / second argument /</span><br><span class="line">unsigned data_length; / length of payload (0 is allowed) /</span><br><span class="line">unsigned data_crc32; / crc32 of data payload /</span><br><span class="line">unsigned magic; / command ^ 0xffffffff */</span><br></pre></td></tr></table></figure><p>也就是说 <code>adb server</code> 和 <code>adb daemon</code> 之间可以通过两种传输协议来发送 <code>adb</code> 协议报文。</p><h3 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h3><p>采用 <code>USB</code> 进行传输时，我们需要先将手机通过数据线连接到电脑上，注意手机需要进入开发者模式，并且通过相应的权限设置，如果连接成功的话，在命令行中输入 <code>adb devices</code> 就可以看到连接的设备了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">988a1b30374e494a52device</span><br></pre></td></tr></table></figure><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>当然除了 <code>USB</code> 这种传统方式的话，我们还可以利用酷酷的 <code>TCP/IP</code> 进行通信，首先也是通过 <code>USB</code> 连接手机和电脑，并确保两者连接到同一个局域网，在命令行中输入 <code>adb tcpip 5555</code> 使得 <code>adb daemon</code> 监听 <code>5555</code> 端口，然后通过 <code>adb connect &lt;IP_OF_YOUR_ANDROID_PHONE&gt;</code> 命令来连接我们的手机，这里 <code>&lt;IP_OF_YOUR_ANDROID_PHONE&gt;</code> 代表手机的 <code>IP</code> 地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb tcpip 5555</span><br><span class="line">$ adb connect &lt;IP_OF_YOUR_ANDROID_PHONE&gt;</span><br></pre></td></tr></table></figure><p>如果连接成功，再使用 <code>adb devices</code> 命令会获得以下输出，这里的输出和上面有写不同，这里会输出 <code>192.168.1.101:5555</code> ，这样就说明我们已经成功连接，可以拔掉我们的数据线进行通信了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">192.168.1.101:5555device</span><br></pre></td></tr></table></figure><h2 id="adb-常用命令"><a href="#adb-常用命令" class="headerlink" title="adb 常用命令"></a>adb 常用命令</h2><p>正确连接上了我们的手机之后，我们就可以干各种很酷的事情了。</p><h3 id="获取版本信息"><a href="#获取版本信息" class="headerlink" title="获取版本信息"></a>获取版本信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell getprop ro.build.version.release</span><br></pre></td></tr></table></figure><h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb push [source] [destination]</span><br><span class="line">$ adb pull [device file location] [location file location]</span><br></pre></td></tr></table></figure><h3 id="screenshot-和-screenrecord"><a href="#screenshot-和-screenrecord" class="headerlink" title="screenshot 和 screenrecord"></a>screenshot 和 screenrecord</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell screencap -p /sdcard/screenshot.png</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell screenrecord /sdcard/notabletologin.mp4</span><br></pre></td></tr></table></figure><h3 id="手势模拟"><a href="#手势模拟" class="headerlink" title="手势模拟"></a>手势模拟</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell swipe x1 y1 x2 y2</span><br></pre></td></tr></table></figure><h3 id="模拟基本操作"><a href="#模拟基本操作" class="headerlink" title="模拟基本操作"></a>模拟基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Home btn</span><br><span class="line">$ adb shell input keyevent 3 </span><br><span class="line">// Back btn</span><br><span class="line">$ adb shell input keyevent 4 </span><br><span class="line">// Call</span><br><span class="line">$ adb shell input keyevent 5 </span><br><span class="line">// End call</span><br><span class="line">$ adb shell input keyevent 6 </span><br><span class="line">// Turn Android device ON and OFF. It will toggle device to on/off status.</span><br><span class="line">$ adb shell input keyevent 26  </span><br><span class="line">// Camera</span><br><span class="line">$ adb shell input keyevent 27 </span><br><span class="line">// Open browser</span><br><span class="line">$ adb shell input keyevent 64 </span><br><span class="line">// Enter</span><br><span class="line">$ adb shell input keyevent 66 </span><br><span class="line">// Delete (backspace)</span><br><span class="line">$ adb shell input keyevent 67 </span><br><span class="line">// Contacts</span><br><span class="line">$ adb shell input keyevent 207 </span><br><span class="line">// Brightness down/up</span><br><span class="line">$ adb shell input keyevent 220 / 221 </span><br><span class="line">// Cut/Copy/Paste</span><br><span class="line">$ adb shell input keyevent 277 / 278 /279 </span><br><span class="line">// https://developer.android.com/reference/android/view/KeyEvent.html</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ADB&quot;&gt;&lt;a href=&quot;#ADB&quot; class=&quot;headerlink&quot; title=&quot;ADB&quot;&gt;&lt;/a&gt;ADB&lt;/h1&gt;&lt;p&gt;安卓手机相对 &lt;code&gt;iPhone&lt;/code&gt; 来说生态系统更加开放，可以做各种各样酷酷的事情，例如通过自己电脑上的命令行来刷
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Connection Limiter</title>
    <link href="https://oceanoverflow.github.io/2018/05/15/ConnectionLimiter/"/>
    <id>https://oceanoverflow.github.io/2018/05/15/ConnectionLimiter/</id>
    <published>2018-05-15T02:18:24.000Z</published>
    <updated>2018-05-15T11:36:24.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Connection-Limiter"><a href="#Connection-Limiter" class="headerlink" title="Connection Limiter"></a>Connection Limiter</h1><p>作为服务提供商，我们肯定是希望越多客户使用我们的服务越好，为此我们不惜花大价钱雇程序员来搞高并发服务器编程，砸很多的钱买最好的服务器，但是总有些无良用户想要和我们作对，搞很多 <code>HTTP</code> 连接请求恶意占用服务器的资源，导致其他用户的服务体验下降，从而最终导致客户的流失，这种情况我们肯定是希望极力避免的。</p><p>一般来说，正常的客户端（人为操作）不会在短时间内对同一服务发送过多的请求，只有想要实施恶意攻击行为的客户端（例如爬虫）才会同时发送很多请求来占用服务器的资源。为了避免这种情况的发生，我们需要限制同一个 <code>IP</code> 地址的请求数量。</p><p>实现连接限制的思路比较简单，我们通过一个 <code>map</code> 来记录来自同一个 <code>IP</code> 地址的 <code>HTTP</code> 请求的个数，如果在正常范围内，则给予该客户端正常的服务，如果超过上限，此时该客户端被怀疑正在进行爬虫之类的非善意行为，对此我们返回一个错误并拒绝服务该请求。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ConnLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    connections      <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span></span><br><span class="line">    maxConnections   <span class="keyword">int64</span></span><br><span class="line">    totalConnections <span class="keyword">int64</span></span><br><span class="line">    next             http.Handler</span><br><span class="line">    errHandler       ErrorHandler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(next http.Handler, maxConnections <span class="keyword">int64</span>)</span> <span class="params">(*ConnLimiter, error)</span></span> &#123;</span><br><span class="line">    cl := &amp;ConnLimiter &#123;</span><br><span class="line">        maxConnections: maxConnections,</span><br><span class="line">        connections: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>),</span><br><span class="line">        next: next,</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> cl.errHandler == <span class="literal">nil</span> &#123;</span><br><span class="line">        cl.errHandler = defaultErrHandler</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cl, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们是对同一个<code>IP</code> 地址设置连接限制，故对于每个请求，通过读取请求 <code>http.Request</code> 中的 <code>RemoteAddr</code> 来获取 <code>IP</code> 地址。但是上有政策，下游对策，很多写爬虫的人通过代理 <code>IP</code> 池来规避这种审查，这里我们先不讨论如何处理这种情况。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">extractClientIP</span><span class="params">(req *http.Request)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">    vals := strings.SplitN(req.RemoteAddr, <span class="string">":"</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(vals[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, <span class="number">0</span>, fmt.Errorf(<span class="string">"Failed to parse client IP: %v"</span>, req.RemoteAddr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vals[<span class="number">0</span>], <span class="number">1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还需要定义当同一个 <code>IP</code> 地址的连接数量超过最高连接数量的错误 <code>MaxConnError</code> 以及处理该错误的方法。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MaxConnError <span class="keyword">struct</span> &#123;</span><br><span class="line">    max <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MaxConnError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"max connections reached: %d"</span>, m.max)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConnErrHandler <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ConnErrHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    statusCode := http.StatusInternalServerError</span><br><span class="line">    w.WriteHeader(statusCode)</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(http.StatusText(statusCode)))   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultErrHandler = &amp;ConnErrHandler&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>acquire</code> 和 <code>release</code> 方法在加锁的条件下对 <code>map</code> 进行操作，这是因为在并发情况下对同一个数据进行读写操作时，会发生数据竞争的情况，所以需要使用 <code>sync.Mutex</code> 来对数据读写进行保护。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl *ConnLimiter)</span> <span class="title">acquire</span><span class="params">(token <span class="keyword">string</span>, amount <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    cl.Lock()</span><br><span class="line">    <span class="keyword">defer</span> cl.Unlock()</span><br><span class="line"></span><br><span class="line">    connections := cl.connections[token]</span><br><span class="line">    <span class="keyword">if</span> connections &gt;= cl.maxConnections &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;MaxConnError&#123;max: cl.maxConnections&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cl.connections[token] += amount</span><br><span class="line">    cl.totalConnections += amount</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl *ConnLimiter)</span> <span class="title">release</span><span class="params">(token <span class="keyword">string</span>, amount <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    cl.Lock()</span><br><span class="line">    <span class="keyword">defer</span> cl.Unlock()</span><br><span class="line"></span><br><span class="line">    cl.connections[token] -= amount</span><br><span class="line">    cl.totalConnections -= amount</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> cl.connections[token] == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(cl.connections, token)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在提供服务（ <code>ServeHTTP</code> ）之前，我们通过 <code>acquire</code> 判断该客户端是否有资格获得服务，如果有资格则使用正常的 <code>handler</code> 来处理，否则则使用 <code>errHandler</code> 来处理，最后服务完了需要将相关资源释放（ <code>release</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl *ConnLimiter)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    token, amount, err := extractClientIP(r)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Errorf(<span class="string">"failed to extract source of the connection: %v"</span>, err)</span><br><span class="line">        cl.errHandler.ServeHTTP(w, r)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = cl.acquire(token, amount); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Debugf(<span class="string">"limiting request source %s: %v"</span>, token, err)</span><br><span class="line">        cl.errHandler.ServeHTTP(w, r)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> cl.release(token, amount)</span><br><span class="line"></span><br><span class="line">    cl.next.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cl *ConnLimiter)</span> <span class="title">Wrap</span><span class="params">(h http.Handler)</span></span> &#123;</span><br><span class="line">    cl.next = h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Connection-Limiter&quot;&gt;&lt;a href=&quot;#Connection-Limiter&quot; class=&quot;headerlink&quot; title=&quot;Connection Limiter&quot;&gt;&lt;/a&gt;Connection Limiter&lt;/h1&gt;&lt;p&gt;作为服务提供
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Terminal UI</title>
    <link href="https://oceanoverflow.github.io/2018/05/14/TerminalUI/"/>
    <id>https://oceanoverflow.github.io/2018/05/14/TerminalUI/</id>
    <published>2018-05-14T14:49:04.000Z</published>
    <updated>2018-05-15T11:43:47.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Terminal-UI"><a href="#Terminal-UI" class="headerlink" title="Terminal UI"></a>Terminal UI</h1><p>之前用命令行版本的网易云音乐来听歌（ <code>musicbox</code> ，在 <code>github</code> 上可以搜索到），觉得实在是太 <code>geek</code> 了，但它是用 <code>python</code> 写的，略微容易崩，所以决定试着用 <code>golang</code> 仿造一个，第一步肯定是模仿它的 <code>UI</code> 了，在浏览器中我们用三元老 <code>HTML/CSS/JS</code> 可以很容易撸出一套能看的前端界面来，但估计没几个人知道命令行版本的 <code>UI</code> 应该怎么搞，其实说实话我也不知道，大概搜了一下，发现用 <code>termui</code> 这个库就可以比较轻松撸出一个与 <code>musicbox</code> 类似的界面了，下面我们来看一下如何用代码来实现吧。</p><h2 id="termui-安装"><a href="#termui-安装" class="headerlink" title="termui 安装"></a>termui 安装</h2><p>一般来说我们可以使用 <code>go get</code> 来进行获取安装，但最好使用 <code>dep</code> 来帮助我们管理项目的相关依赖。</p><p><code>go get -u github.com/gizak/termui</code></p><p>然后在代码中 <code>import</code> 就可以了。</p><p><code>import &quot;github.com/gizak/termui&quot;</code></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在使用 <code>termui</code> 时需要先进行初始化（ <code>termui.Init()</code> ），并且最后还要释放资源 <code>defer termui.Close()</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">err := termui.Init()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> termui.Close()</span><br></pre></td></tr></table></figure><h2 id="界面相关数据准备"><a href="#界面相关数据准备" class="headerlink" title="界面相关数据准备"></a>界面相关数据准备</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">strs := []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"   0. 排行榜"</span>,</span><br><span class="line">    <span class="string">"   1. 艺术家"</span>,</span><br><span class="line">    <span class="string">"   2. 新碟上架"</span>,</span><br><span class="line">    <span class="string">"   3. 精选歌单"</span>,</span><br><span class="line">    <span class="string">"   4. 我的歌单"</span>,</span><br><span class="line">    <span class="string">"   5. 主播电台"</span>,</span><br><span class="line">    <span class="string">"   6. 每日推荐"</span>,</span><br><span class="line">    <span class="string">"   7. 私人FM"</span>,</span><br><span class="line">    <span class="string">"   8. 搜索"</span>,</span><br><span class="line">    <span class="string">"   9. 帮助"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">off := []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"   0. 排行榜"</span>,</span><br><span class="line">    <span class="string">"   1. 艺术家"</span>,</span><br><span class="line">    <span class="string">"   2. 新碟上架"</span>,</span><br><span class="line">    <span class="string">"   3. 精选歌单"</span>,</span><br><span class="line">    <span class="string">"   4. 我的歌单"</span>,</span><br><span class="line">    <span class="string">"   5. 主播电台"</span>,</span><br><span class="line">    <span class="string">"   6. 每日推荐"</span>,</span><br><span class="line">    <span class="string">"   7. 私人FM"</span>,</span><br><span class="line">    <span class="string">"   8. 搜索"</span>,</span><br><span class="line">    <span class="string">"   9. 帮助"</span>,</span><br><span class="line">&#125;</span><br><span class="line">on := []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"[-&gt; 0. 排行榜](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 1. 艺术家](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 2. 新碟上架](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 3. 精选歌单](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 4. 我的歌单](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 5. 主播电台](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 6. 每日推荐](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 7. 私人FM](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 8. 搜索](fg-cyan)"</span>,</span><br><span class="line">    <span class="string">"[-&gt; 9. 帮助](fg-cyan)"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义界面参数"><a href="#定义界面参数" class="headerlink" title="定义界面参数"></a>定义界面参数</h2><p>在使用 <code>termui</code> 时，我们需要确定界面元素及其属性，以及它在命令行中的排版，其实 <code>UI</code> 就是对数据的一种呈现，反正就是你觉得怎么好看就怎么来。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls := termui.List()</span><br><span class="line">ls.Items = strs</span><br><span class="line">ls.ItemFgColor = termui.ColorWhite</span><br><span class="line">ls.BorderLabel = <span class="string">"网易云音乐"</span></span><br><span class="line">ls.Height = <span class="number">12</span></span><br><span class="line">ls.Width = <span class="number">20</span></span><br><span class="line">ls.Y = <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="termui对事件的处理"><a href="#termui对事件的处理" class="headerlink" title="termui对事件的处理"></a>termui对事件的处理</h2><p><code>termui</code> 对事件的处理和 <code>HTTP</code> 处理事件的做法类似，我们需要对不同的事件注册回调函数，例如检测到用户输入 <code>q</code> ，我们注册一个类似的回调函数就可以了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">termui.Handle(<span class="string">"/sys/kbd/q"</span>, <span class="function"><span class="keyword">func</span><span class="params">(termui.Event)</span></span> &#123;</span><br><span class="line">    termui.StopLoop()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>相关事件可以是键盘输入，界面点击，窗口伸缩甚至可以是自定义事件。相关事件触发后，对应的数据可能会发生改变，这样以来用户界面就需要发生改变，我们可以使用 <code>termui.Render</code> 对界面重新进行渲染。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cursor := <span class="number">0</span></span><br><span class="line">termui.Render(ls)</span><br><span class="line">termui.Handle(<span class="string">"/sys/kbd/j"</span>, <span class="function"><span class="keyword">func</span><span class="params">(termui.Event)</span></span> &#123;</span><br><span class="line">    strs[cursor%<span class="built_in">len</span>(strs)] = off[cursor%<span class="built_in">len</span>(strs)]</span><br><span class="line">    cursor++</span><br><span class="line">    <span class="keyword">if</span> cursor == <span class="built_in">len</span>(strs) &#123;</span><br><span class="line">        cursor = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    strs[cursor%<span class="built_in">len</span>(strs)] = on[cursor%<span class="built_in">len</span>(strs)]</span><br><span class="line">    termui.Render(ls)</span><br><span class="line">&#125;)</span><br><span class="line">termui.Handle(<span class="string">"/sys/kbd/k"</span>, <span class="function"><span class="keyword">func</span><span class="params">(termui.Event)</span></span> &#123;</span><br><span class="line">    strs[cursor%<span class="built_in">len</span>(strs)] = off[cursor%<span class="built_in">len</span>(strs)]</span><br><span class="line">    cursor--</span><br><span class="line">    <span class="keyword">if</span> cursor &lt; <span class="number">0</span> &#123;</span><br><span class="line">        cursor = <span class="built_in">len</span>(strs) - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    strs[cursor%<span class="built_in">len</span>(strs)] = on[cursor%<span class="built_in">len</span>(strs)]</span><br><span class="line">    termui.Render(ls)</span><br><span class="line">&#125;)</span><br><span class="line">termui.Loop()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Terminal-UI&quot;&gt;&lt;a href=&quot;#Terminal-UI&quot; class=&quot;headerlink&quot; title=&quot;Terminal UI&quot;&gt;&lt;/a&gt;Terminal UI&lt;/h1&gt;&lt;p&gt;之前用命令行版本的网易云音乐来听歌（ &lt;code&gt;musicbox&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Job Dispatcher</title>
    <link href="https://oceanoverflow.github.io/2018/05/13/JobDispatcher/"/>
    <id>https://oceanoverflow.github.io/2018/05/13/JobDispatcher/</id>
    <published>2018-05-13T13:34:24.000Z</published>
    <updated>2018-05-15T11:48:32.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Job-Dispatcher"><a href="#Job-Dispatcher" class="headerlink" title="Job Dispatcher"></a>Job Dispatcher</h1><p>当处理大量计算密集型任务时，为了提高工作效率，常常会引入多台服务器同时进行处理，但是不同的服务器之间并不清楚自己该处理哪个任务，也就是说服务器自己并不能保证自己处理的任务和别人的任务是不一样的。为了解决上述问题，我们引入 <code>Job Dispatcher</code> 模型。</p><p>我们把处理任务的服务器称为 <code>Worker</code> ，而把分配任务的服务器称为<code>Dispatcher</code> 或者 <code>Master</code> 。<code>Dispatcher</code> 负责给当前处于空闲状态的 <code>Worker</code> 分配任务 （ <code>Job</code> ），当其处理完分配的任务之后，为了不让自己的 <code>CPU</code> 闲置，<code>Worker</code> 会通知 <code>Dispather</code> 自己是可用的（ <code>available</code> ） ，然后 <code>Dispatcher</code> 就可以继续向 <code>Worker</code> 分配任务，直到所有任务全都完成。这样的模型非常 <code>scalable</code> ，引入的 <code>Worker</code> 数量越多，任务完成得越快。</p><h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><p>一个任务我们用结构体 <code>Job</code> 来表示，现在对于此结构体中有什么我们并不关心，这个需要由业务逻辑具体定义。</p><p> <code>Worker</code> 中有三个 <code>channel</code> ，分别用于暂停，接收任务和通知 <code>Dispatcher</code> 任务完成用的。</p><p><code>Worker</code> 肯定需要某种机制停止退出，我们用一个 <code>exit chan struct{}</code> 通道来接收停止信号，如果该通道中收到了停止信号，也就可以说明今天的任务已经全部完成了，<code>Worker</code> 可以回家休息了。</p><p><code>Jobs chan Job</code> 通道很简单，当然就是用于接受任务的啦，相对来说，任务可是做不完的，一个任务做完下一个任务就马不停蹄的赶来了，所以用通道来表示可以说是再合适不过了。</p><p>最后来看一下最复杂的一个通道 <code>WorkerPool chan chan Job</code> ，这啥玩意啊，通道的通道？想想就头大，外层的通道的中包含了 <code>chan Job</code> ，也就是上面说过的 <code>Jobs</code> 通道，其实就代表 <code>Worker</code> 本身， 如果一个 <code>Job</code> 处理完了， <code>Worker</code> 就会处于空闲状态，所以就可以把它放在 <code>WorkerPool</code> 中等待 <code>Dispatcher</code> 来调度了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">    Payload <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">    WorkerPool <span class="keyword">chan</span> <span class="keyword">chan</span> Job</span><br><span class="line">    Jobs       <span class="keyword">chan</span> Job</span><br><span class="line">    exit       <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorker</span><span class="params">(workerPool <span class="keyword">chan</span> <span class="keyword">chan</span> Job)</span> *<span class="title">Worker</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Worker&#123;</span><br><span class="line">        WorkerPool: workerPool,</span><br><span class="line">        Jobs:       <span class="built_in">make</span>(<span class="keyword">chan</span> Job),</span><br><span class="line">        exit:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Stop</code> 方法向 <code>exit</code> 通道发送信号，这样一来 <code>Start</code> 方法中的 <code>select</code> 语句的第二个 <code>case</code> 就会被执行，<code>Worker</code> 就可以退出了。在 <code>Start</code> 方法中，<code>w.WorkerPool &lt;- w.Jobs</code> 会向 <code>WorkerPool</code> 中注册它自己，也就相当于向 <code>Dispatcher</code> 申明自己已经处于空闲状态，随时等待被调度。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            w.WorkerPool &lt;- w.Jobs</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> job := &lt;- w.Jobs:</span><br><span class="line">                <span class="comment">// do some heavy job here</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-w.exit:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        w.exit &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h2><p>所有的任务都是从外界来的（此处我们选择从 <code>JobQueue</code> 中读取），任务到来时并不会直接分配给 <code>Worker</code> ，而是先经过 <code>Dispatcher</code> 的魔爪，<code>Dispatcher</code> 会先判断哪个 <code>Worker</code> 处于空闲状态，然后再分配给空闲的 <code>Worker</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> JobQueue <span class="keyword">chan</span> Job</span><br></pre></td></tr></table></figure><p><code>Dispatcher</code> 结构体中的 <code>WorkerPool chan chan Job</code> 是任务调度实现的核心，我们上述 <code>Worker</code> 中的和 <code>Dispatcher</code> 中的其实是一个东西，<code>Worker</code> 中的是对 <code>Dispatcher</code> 中的一个引用而已。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dispatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">    WorkerPool <span class="keyword">chan</span> <span class="keyword">chan</span> Job</span><br><span class="line">    MaxWorkers <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDispatcher</span><span class="params">(maxWorkers <span class="keyword">int</span>)</span> *<span class="title">Dispatcher</span></span> &#123;</span><br><span class="line">    pool := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> Job, maxWorkers)</span><br><span class="line">    <span class="keyword">return</span> &amp;Dispatcher&#123;</span><br><span class="line">        WorkerPool: pool,</span><br><span class="line">        MaxWorkers: maxWorkers,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Run</code> 方法中起了 <code>MaxWorkers</code> 个 <code>Worker</code> 等待 <code>Dispatcher</code> 给自己分配任务。</p><p>在 <code>dispatch</code> 方法中，<code>Dispatcher</code> 会不断的从 <code>JobQueue</code> 中读取任务，并在 <code>WorkerPool</code> 中选取一个空闲的 <code>Worker</code> （ <code>worker := &lt;-d.WorkerPool</code> ），然后将任务分配给它（ <code>worker &lt;- job</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dispatcher)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; d.MaxWorkers; i++ &#123;</span><br><span class="line">        worker := NewWorker(d.WorkerPool)</span><br><span class="line">        worker.Start()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> d.dispatch()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dispatcher)</span> <span class="title">dispatch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> job := &lt;- JobQueue:</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(job Job)</span></span> &#123;</span><br><span class="line">                worker := &lt;-d.WorkerPool</span><br><span class="line">                worker &lt;- job</span><br><span class="line">            &#125;(job)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Job-Dispatcher&quot;&gt;&lt;a href=&quot;#Job-Dispatcher&quot; class=&quot;headerlink&quot; title=&quot;Job Dispatcher&quot;&gt;&lt;/a&gt;Job Dispatcher&lt;/h1&gt;&lt;p&gt;当处理大量计算密集型任务时，为了提高工作效率
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Reverse Proxy</title>
    <link href="https://oceanoverflow.github.io/2018/05/12/ReverseProxy/"/>
    <id>https://oceanoverflow.github.io/2018/05/12/ReverseProxy/</id>
    <published>2018-05-12T13:30:04.000Z</published>
    <updated>2018-05-15T11:57:53.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reverse-Proxy"><a href="#Reverse-Proxy" class="headerlink" title="Reverse Proxy"></a>Reverse Proxy</h1><p>在正常的 <code>HTTP</code> 服务流程中，客户端向服务器发送 <code>HTTP</code> 请求，服务器收到后会向客户端返回一个 <code>HTTP</code> 答复。但在实际生产环境中，真正处理请求的服务器和客户端之间通常还会引入一个中介，也就是反向代理服务器，在引入了反向代理服务器之后，客户端会先将请求发送给反向代理服务器，反向代理收到该 <code>HTTP</code> 请求后，并不会自己亲自处理该请求，而是将请求转发给真正的处理业务逻辑的服务器，让它去处理，业务逻辑服务器处理完之后，会先将答复返回给反向代理服务器，再由反向代理服务器返回给客户端。</p><p>生活中常见的 <code>NGINX</code> 就常常作为反向代理服务器来使用。那么你可能会问，传统 <code>C/S</code> 模型难道不够好吗，还非要引入一个不知道什么鬼的反向代理来捣乱，引入之后只会把架构变得更复杂，有啥好处？（傲娇状）其实原因很简单，第一反向代理服务器可以当作防火墙来用，它为真正的业务逻辑服务器与外界可能的恶意攻击之间提供了一个屏障，尤其是像银行这种对安全性要求极高的金融机构无论加几个这样的防火墙都不会嫌多。第二点就是它可以提供负载均衡功能，通过使用不同的策略将请求转发给不同的服务器，以达到负载均衡的目的。</p><p>幸运的是，引入反向代理，并不会改变传统的 <code>C/S</code> 编程模型，因为客户端无法感知反向代理服务器的存在，他们只会觉得反向代理服务器就是真正处理业务逻辑的服务器。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/67/Reverse_proxy_h2g2bob.svg/1200px-Reverse_proxy_h2g2bob.svg.png" alt="Reverse Proxy"></p><p>下面我们来实现一个简单的反向代理服务器吧，虽然听着很恐怖，但是不用慌，强大的 <code>Golang</code> 标准库已经实现了反向代理的功能了。<code>httputil</code> 中提供的 <code>ReverseProxy</code> 结构体具有将请求重定向的能力（ <code>Director</code> ），也具有将答复修改的能力（ <code>ModifyResponse</code> ），最重要的是，可以通过 <code>Transport</code> 这个 <code>http.RoundTripper</code> 将我们的代理请求发送出去。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReverseProxy <span class="keyword">struct</span> &#123;</span><br><span class="line">    Director      <span class="function"><span class="keyword">func</span><span class="params">(*http.Request)</span></span></span><br><span class="line"><span class="function">    <span class="title">Transport</span>     <span class="title">http</span>.<span class="title">RoundTripper</span></span></span><br><span class="line"><span class="function">    <span class="title">FlushInterval</span> <span class="title">time</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function">    <span class="title">ErrorLog</span>      *<span class="title">log</span>.<span class="title">Logger</span></span></span><br><span class="line"><span class="function">    <span class="title">BufferPool</span>    <span class="title">BufferPool</span></span></span><br><span class="line"><span class="function">    <span class="title">ModifyReponse</span> <span class="title">func</span><span class="params">(*http.Response)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">RoundTripper</span> <span class="title">interface</span></span> &#123;</span><br><span class="line">    RoundTrip(*http.Request) (*http.Response, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为一个代理服务器，虽然不直接处理业务逻辑，但是最基本的对请求的处理和答复的功能还是要有的，与一般的 <code>HTTP</code> 服务器类似，我们的反向代理服务器 <code>ReverseProxy</code> 也需要有 <code>ServeHTTP(http.ResponseWriter, *http.Request)</code> 这样的方法。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(http.ResponseWriter, *http.Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以为了实现代理请求的功能，我们需要定义一个结构体 <code>handler</code> ，使其实现 <code>ServeHTTP(http.ResponseWriter, *http.Request)</code> 方法，在该方法中我们通过 <code>httputil.NewSingleHostReverseProxy</code> 来构造一个反向代理，并将请求通过 <code>proxy.ServeHTTP(w, r)</code> 方法将请求代理到随机的（随机是为了实现负载均衡）服务器上。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">servers := []<span class="keyword">string</span>&#123;</span><br><span class="line">     <span class="string">"111.222.111.222"</span>,</span><br><span class="line">     <span class="string">"222.111.222.111"</span>,</span><br><span class="line">     <span class="string">"111.233.111.233"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> handler <span class="keyword">struct</span> &#123;</span><br><span class="line">    reverseProxy <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *handler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    addr := servers[rand.Intn(<span class="built_in">len</span>(servers))]</span><br><span class="line">    remote, err := url.Parse(<span class="string">"http://"</span> + addr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    proxy := httputil.NewSingleHostReverseProxy(remote)</span><br><span class="line">    proxy.ServeHTTP(w, r)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们申明一个 <code>http.Server</code> ，在 <code>StartServer</code> 中我们监听指定的端口（ <code>bind</code> ），其对应的 <code>Handler</code> 就是我们之前实现的 <code>handler</code> 结构体，用于把请求代理到 <code>remote</code> 上去，这样以来一个基本的反向代理服务器就实现好了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> srv http.Server</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartServer</span><span class="params">(bind <span class="keyword">string</span>, remote <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"Listening on %s, forwarding to %s"</span>, bind, remote)</span><br><span class="line">    h := &amp;handler&#123;reverseProxy: remote&#125;</span><br><span class="line">    srv.Addr = bind</span><br><span class="line">    srv.Handler = h</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := srv.ListenAndServe(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(<span class="string">"ListenAndServe:"</span> err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StopServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := srv.Shutdown(<span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    StartServer(<span class="string">":8080"</span>, <span class="string">"remote:8080"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中的采用的负载均衡算法只用了非常简单的随机选取策略，这只适合每台服务器性能差别不大的情况，如果服务器之间性能差距较大，我们可以使用 <code>Weighted Round Robin</code> 这样的负载均衡算法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Reverse-Proxy&quot;&gt;&lt;a href=&quot;#Reverse-Proxy&quot; class=&quot;headerlink&quot; title=&quot;Reverse Proxy&quot;&gt;&lt;/a&gt;Reverse Proxy&lt;/h1&gt;&lt;p&gt;在正常的 &lt;code&gt;HTTP&lt;/code&gt; 服务流
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Advisory Lock</title>
    <link href="https://oceanoverflow.github.io/2018/05/12/AdvisoryLock/"/>
    <id>https://oceanoverflow.github.io/2018/05/12/AdvisoryLock/</id>
    <published>2018-05-12T05:26:04.000Z</published>
    <updated>2018-05-15T11:33:27.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Advisory-Lock"><a href="#Advisory-Lock" class="headerlink" title="Advisory Lock"></a>Advisory Lock</h1><p>很多时候，在操作系统中，对于特定应用，我们只希望起一个进程实例，但是操作系统并没有限制同一个应用进程的个数，也就是说，在每个应用运行前，我们需要检测进程是否存在。</p><p>那么如何检测进程是否已经存在了呢，我们可以在进程启动时，生成一个以 <code>.pid</code> 结尾的文件，并向这个文件上加一个建议性锁（ <code>advisory lock</code> ），这样如果有第二个这个的进程起来，它会试着去打开这个 <code>.pid</code> 文件，并试着向这个文件加建议性锁，但由于先起来的进程已经加过锁了，所以第二个进程就没有办法再加锁了，第二个进程知道自己不是第一个起起来的，所以就选择退出。</p><p>等等，刚才说的建议性锁又是什么呢，建议性锁就好像人们指定的一系列规则， 例如交通法规建议人们红灯停，绿灯行，这里的红绿灯就是一个建议性锁，但是总有不听话的人不遵守这些规则，也就是说无视建议性锁的存在。建议性锁并不是强制性的，进程可以选择不去遵守它。</p><p>上面进程的例子就是这样，第二个进程如果观测到文件已经上锁了，如果它不是恶意进程，那么它会选择尊重规则选择退出。</p><h2 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h2><p>下面我们来实现一个文件锁，文件锁的本质就是文件，所以我们选择对 <code>os.File</code> 做一层封装，然后对它添加额外的行为使其成为一个真正的文件锁。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LockFile <span class="keyword">struct</span> &#123;</span><br><span class="line">    *os.File</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLockFile</span><span class="params">(file *os.File)</span> *<span class="title">LockFile</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;LockFile&#123;file&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对文件上锁和解锁的过程其实就是利用系统调用 <code>syscall.Flock</code>，下面是c语言中的系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_SH 1 <span class="comment">/* shared lock */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_EX 2 <span class="comment">/* exclusive lock */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_NB 4 <span class="comment">/* don't block when locking */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_UN 8 <span class="comment">/* unlock */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">flock(<span class="keyword">int</span> fd, <span class="keyword">int</span> operation)</span><br></pre></td></tr></table></figure><p>建议性锁分为两大类：共享锁（ <code>SH</code> ）和专有锁（ <code>EX</code> ），这里我们采用专有锁，也就是利用 <code>LOCK_EX</code> 选项，如果文件已经上过锁了，再次尝试对该文件上锁时，操作会被阻塞，为了避免调用此系统调用的进程被阻塞，我们在系统调用时增加一个 <code>LOCK_NB</code> 选项，也就是非阻塞（ <code>non blocking</code> ）的意思，指定该选项后如果尝试上锁时，文件已经上过锁了，此时则则不会发生阻塞而是返回一个 <code>EWOULDBLOCK</code> 错误，当对文件解锁时，只需要在系统调用时指定 <code>LOCK_UN</code> 选项就可以了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ErrWouldBlock = errors.New(<span class="string">"Resource temporarily unavailable"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *LockFile)</span> <span class="title">Lock</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lockFile(file.Fd())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lockFile</span><span class="params">(fd <span class="keyword">uintptr</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    err := syscall.Flock(<span class="keyword">int</span>(fd), syscall.LOCK_EX|syscall.LOCK_NB)</span><br><span class="line">    <span class="keyword">if</span> err == syscall.EWOULDBLOCK &#123;</span><br><span class="line">        err = ERRWouldBlock</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *LockFile)</span> <span class="title">Unlock</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unlockFile(file.Fd())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unlockFile</span><span class="params">(fd <span class="keyword">uintptr</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    err := syscall.Flock(<span class="keyword">int</span>(fd), syscall.LOCK_UN)</span><br><span class="line">    <span class="keyword">if</span> err == syscall.EWouldBLOCK &#123;</span><br><span class="line">        err = ErrWouldBlock</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>OpenLockFile</code> 方法很简单，就是对 <code>os.OpenFile</code> 方法进行了一层封装，将此方法返回的 <code>file</code> 封装为<code>LockFile</code> 返回供接下去使用。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenLockFile</span><span class="params">(name <span class="keyword">string</span>, perm os.FileMode)</span> <span class="params">(lock *LockFile, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> file *os.File</span><br><span class="line">    <span class="keyword">if</span> file, err = os.OpenFile(name, os.O_RWWR|os.O_CREATE, perm); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        lock = &amp;LockFile&#123;file&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程存在性检测"><a href="#进程存在性检测" class="headerlink" title="进程存在性检测"></a>进程存在性检测</h2><p>文件上锁可以用作进程存在性检测，我们在进程创建时生成一个以 <code>.pid</code> 结尾的文件，并向该文件中写入当前进程的进程号，下面的 <code>WritePid</code> 方法就将当前进程的进程号写入文件起始位置，而 <code>ReadPid</code> 则将此文件中存储的 <code>pid</code> 读取出来，注意这里无论是读操作还是写操作都会先将文件的指针定位到最开始的位置（通过 <code>file.Seek(0, os.SEEK_SET)</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *LockFile)</span> <span class="title">WritePid</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err = file.Seek(<span class="number">0</span>, os.SEEK_SET); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fileLen <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> fileLen, err = fmt.Fprint(file, os.Getpid()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = file.Truncate(<span class="keyword">int64</span>(fileLen)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    err = file.Sync()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *LockFile)</span> <span class="title">ReadPid</span><span class="params">()</span> <span class="params">(pid <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err = file.Seek(<span class="number">0</span>, os.SEEK_SET); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    _, err = fmt.Fscan(file, &amp;pid)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *LockFile)</span> <span class="title">Remove</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err := file.Unlock(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os.Remove(file.Name())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们创建一个 <code>pid</code> 文件时候，我们需要检测其他进程是否已经存在，<code>CreatePidFile</code> 方法会使用 <code>Lock</code> 方法尝试对文件上锁，如果上锁失败，则说明已经有进程对该文件上过锁，此时则应该选择退出，如果上锁成功，则说明自己是第一个进程，并将自己的进程号写入该文件中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreatePidFile</span><span class="params">(name <span class="keyword">string</span>, perm os.FileMode)</span> <span class="params">(lock *LockFile, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> lock, err = OpenLockFile(name, perm); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = lock.Lock(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        lock.Remove()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = lock.WritePid(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        lock.Remove()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadPidFile</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(pid <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> file *os.File</span><br><span class="line">    <span class="keyword">if</span> file, err = os.OpenFile(name, os.O_RDONLY, <span class="number">0640</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    lock := &amp;LockFile&#123;file&#125;</span><br><span class="line">    pid, err = lock.ReadPid()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Advisory-Lock&quot;&gt;&lt;a href=&quot;#Advisory-Lock&quot; class=&quot;headerlink&quot; title=&quot;Advisory Lock&quot;&gt;&lt;/a&gt;Advisory Lock&lt;/h1&gt;&lt;p&gt;很多时候，在操作系统中，对于特定应用，我们只希望起一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Token Bucket</title>
    <link href="https://oceanoverflow.github.io/2018/05/11/TokenBucket/"/>
    <id>https://oceanoverflow.github.io/2018/05/11/TokenBucket/</id>
    <published>2018-05-11T14:05:04.000Z</published>
    <updated>2018-05-15T11:42:28.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Token-Bucket"><a href="#Token-Bucket" class="headerlink" title="Token Bucket"></a>Token Bucket</h1><p>学校里的宽带还是有分三六九等的，如果你钱交的多的，对应带宽自然比较高。但你想过他们是如何限制你的最高带宽的吗？其实用令牌桶（ <code>Token Bucket</code> ）这个算法就可以实现速率限制这个功能。</p><p>那么什么又是令牌桶的，简单的说就是假设你有一个专门用于放令牌的桶，桶的最大容量是有上限的，设为C，而该桶自带一个机制就是每隔固定的一段时间会产生一个令牌，一旦令牌充满了桶，桶中的令牌个数就不会再增加了。接下来是重点，如果你要进行某个需要控制速率的操作，在执行这个操作之前，必须先从桶中拿到这个操作对应的令牌个数，比如规定了操作A需要5个令牌，操作B需要10个令牌，那么如果要执行操作A，则需要从桶中拿出5个令牌，如果桶中的令牌数目不够，就需要等到令牌数量足够时才能进行A操作。由于桶中令牌产生的速率是固定的，而在进行相关操作之前，又必须获得足够数量的令牌，这样就到达了速率限制（ <code>Rate Limiting</code> ）的目的。</p><p>除了速率限制之外，令牌桶算法还具有流量整形（ <code>Traffic Shaping</code> ）的功能，因为令牌桶中的令牌是以恒定的速率产生的，所以一段时间内产生的令牌数量是固定的，如果在某一段时间消耗的令牌数量较多，也就是对应操作的数量很多，那么之后的一段时间的操作数量必定会收到限制，从整体上来看，操作的速率会比较均匀，也就是说流量是以比较均衡的速率向外发送的。</p><p><img src="https://community.cambiumnetworks.com/bstrc49894/attachments/bstrc49894/forums_pmp_450/5991/1/TokenBucket.JPG" alt="Token Bucket"></p><p>下面我们来看一下令牌桶算法的实现，由于令牌桶中非常重要的两个属性就是令牌桶的容量和令牌产生的速率，分别用 <code>capacity</code> 和 <code>rate</code> 来表示，我们使用一个通道来存储令牌，因为我们并不关心令牌的内容，所以我们使用 <code>tokens chan struct{}</code> 来表示这个桶。</p><p>在初始化令牌桶的时候，直接起一个 <code>goroutine</code> 来定时向我们的桶中放入令牌，通过 <code>time.NewTicker</code> 用于定时生产令牌，如果令牌桶满了，则<code>b.tokens &lt;- struct{}{}</code> 操作也会被阻塞。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bucket <span class="keyword">struct</span> &#123;</span><br><span class="line">    capacity <span class="keyword">int64</span></span><br><span class="line">    tokens <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    rate time.Duration</span><br><span class="line">    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBucket</span><span class="params">(rate time.Duration, capacity <span class="keyword">int64</span>)</span> *<span class="title">Bucket</span></span> &#123;</span><br><span class="line">    tokens := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, capacity)</span><br><span class="line">    b := &amp;Bucket&#123;</span><br><span class="line">        capacity: capacity,</span><br><span class="line">        tokens: tokens,</span><br><span class="line">        rate: rate,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(b *Bucket)</span></span> &#123;</span><br><span class="line">        ticker := time.NewTicker(rate)</span><br><span class="line">        <span class="keyword">for</span> _ := <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">            b.tokens &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面给出了设置时间间隔（等效为速率）的方法，时间间隔越短，对应的平均速率就越快，二者成反比关系。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span> <span class="title">GetRate</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">    b.Lock()</span><br><span class="line">    tmp := b.rate</span><br><span class="line">    b.Unlock()</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span> <span class="title">SetRate</span><span class="params">(rate time.Duration)</span></span> &#123;</span><br><span class="line">    b.Lock()</span><br><span class="line">    b.rate = rate</span><br><span class="line">    b.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在进行特定操作之前需要取出固定数量的令牌，可以形象的把令牌想象为存在银行里的钱，把令牌桶想象成银行，如果你想要买一台电脑，你就需要从银行拿出足够的钱，如果银行中没有足够的钱，你只能等到你积累了足够的钱才可以买你想要的电脑。也就是说在执行相应操作之前需要有足够多的令牌才能顺利执行。注意到这个函数是阻塞的，只有在 <code>n</code> 次 <code>&lt;-b.tokens</code> 成功之后，该函数才会返回。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span> <span class="title">withdrawTokens</span><span class="params">(n <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">int64</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">        &lt;-b.tokens</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SpendToken</code> 函数会返回一个通道，其函数内部会起一个 <code>goroutine</code> ，在该 <code>goroutine</code> 里会执行上述 <code>withdrawTokens</code> 方法，由于该函数是阻塞的，所以只有它执行完，才能将返回值放入通道 <code>c</code> 中，然后利用 <code>close(c)</code> 操作将该通道关闭，这样以来别处调用该函数的地方就可以顺利返回了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span> <span class="title">SpendToken</span><span class="params">(n <span class="keyword">uint64</span>)</span> &lt;-<span class="title">chan</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(b *Bucket, n <span class="keyword">uint64</span>, c <span class="keyword">chan</span> error)</span></span> &#123;</span><br><span class="line">        c &lt;- b.withdrawTokens(n)</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;(b, n, c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Drain</code> 方法将桶中的所有令牌一次性放光，具体该在哪里使用它要看具体需求。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span> <span class="title">Drain</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-b.tokens:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="令牌桶的使用"><a href="#令牌桶的使用" class="headerlink" title="令牌桶的使用"></a>令牌桶的使用</h2><p>使用令牌桶之前当然需要新建一个令牌桶，并指定令牌桶的容量及其平均速率。因为使用令牌桶的目的之一就是限制速率，在需要被限速的函数（ <code>RegulatedAction()</code> ）前使用 <code>&lt;-bucket.SpendToken(x)</code> ，该 <code>RegulatedAction</code> 只有等到攒满 <code>x</code> 个令牌才会执行，这样就可以达到限制速率的目的了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bucket := NewBucket(<span class="number">1</span> * time.Second, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">&lt;-bucket.SpendToken(<span class="number">10</span>)</span><br><span class="line">RegulatedAction()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Token-Bucket&quot;&gt;&lt;a href=&quot;#Token-Bucket&quot; class=&quot;headerlink&quot; title=&quot;Token Bucket&quot;&gt;&lt;/a&gt;Token Bucket&lt;/h1&gt;&lt;p&gt;学校里的宽带还是有分三六九等的，如果你钱交的多的，对应带宽自
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Stream Cipher</title>
    <link href="https://oceanoverflow.github.io/2018/05/11/StreamCipher/"/>
    <id>https://oceanoverflow.github.io/2018/05/11/StreamCipher/</id>
    <published>2018-05-11T05:10:04.000Z</published>
    <updated>2018-05-15T11:56:52.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stream-Cipher"><a href="#Stream-Cipher" class="headerlink" title="Stream Cipher"></a>Stream Cipher</h1><p>假如我们有一份很重要的文件想要从本地传输到远程客户端，因为并不想让别人看见我们传输的信息，所以需要使用某种手段将传输的数据保护起来，我们可以选择先将文件加密后再进行传输，别人收到之后再进行相应的解密操作。这种方式对于小文件来说问题倒不是很大，但是如果文件体积非常大，本地对文件进行加密和远程对文件进行解密花费的时间就会很长，这样的话时间效率就非常低了，如果我们可以对该文件边加密边传输，远程客户端也可以边接收边解密的话，时间效率就可以大幅度提升了。</p><p>下面我们来引入流加密解决上述问题，流加密有很多模式，例如 <code>CFB</code>，<code>CTR</code> ，<code>OFB</code> 等。而流加密的核心就是异或操作，使用 <code>XORKeyStream</code> 就可以进行加解密了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cipher</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stream <span class="keyword">interface</span> &#123;</span><br><span class="line">    XORKeyStream(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为加密解密肯定涉及到读写操作，所以我们用一个结构体 <code>writer</code> 实现 <code>io.Writer</code> 这个接口，里面封装了一个 <code>io.Writer</code> 和 <code>cipher.Stream</code> ，基本的思路就是将数据经过 <code>cipher.Stream</code> 的 <code>XORKeyStream</code> 方法写入 <code>io.Writer</code> 中。这里 <code>buf</code> 作为中间读操作和加密操作的缓存。</p><p>考虑到通用性，这里和下面我们使用 <code>io.Writer</code> 和 <code>io.Writer</code> 这样的接口进行抽象操作，而非使用具体的 <code>Writer</code> 或者 <code>Reader</code> 来代替。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bufSize = <span class="number">32</span> * <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> writer <span class="keyword">struct</span> &#123;</span><br><span class="line">    io.Writer</span><br><span class="line">    cipher.Stream</span><br><span class="line">    buf []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(w io.Writer, s cipher.Stream)</span> <span class="title">io</span>.<span class="title">Writer</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;writer&#123;Writer: w, Stream: s, buf: <span class="built_in">make</span>([]<span class="keyword">byte</span>, bufSize)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *writer)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    n, err := w.ReadFrom(bytes.NewBuffer(b))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(n), err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReadFrom</code> 方法使我们的 <code>writer</code> 不断从未加密的 <code>io.Reader</code> 中读取数据到 <code>buf</code> 中，再利用 <code>XORKeyStream</code> 将数据加密后写入自己的 <code>io.Writer</code> 中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *writer)</span> <span class="title">ReadFrom</span><span class="params">(r io.Reader)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        buf := w.buf</span><br><span class="line">        nr, er := r.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> nr &gt; <span class="number">0</span> &#123;</span><br><span class="line">            n += <span class="keyword">int64</span>(nr)</span><br><span class="line">            buf = buf[:nr]</span><br><span class="line">            w.XORKeyStream(buf, buf)</span><br><span class="line">            _, ew := w.Writer.Write(buf)</span><br><span class="line">            <span class="keyword">if</span> ew != <span class="literal">nil</span> &#123;</span><br><span class="line">                err = ew</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> er != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> er != io.EOF &#123;</span><br><span class="line">                err = err</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在读方面，和写的时候类似，我们也在自己定义的结构体 <code>reader</code> 中包含一个 <code>io.Reader</code> 和 <code>cipher.Stream</code> ，基本思路也是从 <code>io.Reader</code> 中读取经过加密的数据，然后再用 <code>cipher.Stream</code> 的 <code>XORKeyStream</code> 方法解密。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> reader <span class="keyword">struct</span> &#123;</span><br><span class="line">    io.Reader</span><br><span class="line">    cipher.Stream</span><br><span class="line">    buf []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(r io.Reader, s cipher.Stream)</span> <span class="title">io</span>.<span class="title">Reader</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;reader&#123;Reader: r, Stream: s, buf: <span class="built_in">make</span>([]<span class="keyword">byte</span>, bufSize)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面实现的 <code>Read</code> 方法利用 <code>io.Reader</code> 读取经过加密后的数据，再利用<code>XORKeyStream</code> 进行解密。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *reader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    n, err := r.Reader.Read(b)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    b = b[:n]</span><br><span class="line">    r.XORKeyStream(b, b)</span><br><span class="line">    <span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WriteTo</code> 方法反复使用上面的 <code>Read</code> 方法将数据解密后写入 <code>io.Writer</code> 中直到结束。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *reader)</span> <span class="title">WriteTo</span><span class="params">(w io.Writer)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        buf := r.buf</span><br><span class="line">        nr, er := r.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> nr &gt; <span class="number">0</span> &#123;</span><br><span class="line">            nw, ew := w.Write(buf[:nr])</span><br><span class="line">            n += <span class="keyword">int64</span>(nw)</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span> ew != <span class="literal">nil</span> &#123;</span><br><span class="line">                err = ew</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> er != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> er != io.EOF &#123;</span><br><span class="line">                err = er</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Stream-Cipher&quot;&gt;&lt;a href=&quot;#Stream-Cipher&quot; class=&quot;headerlink&quot; title=&quot;Stream Cipher&quot;&gt;&lt;/a&gt;Stream Cipher&lt;/h1&gt;&lt;p&gt;假如我们有一份很重要的文件想要从本地传输到远程客户端
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Connection Pool</title>
    <link href="https://oceanoverflow.github.io/2018/05/10/ConnectionPool/"/>
    <id>https://oceanoverflow.github.io/2018/05/10/ConnectionPool/</id>
    <published>2018-05-10T03:40:24.000Z</published>
    <updated>2018-05-15T11:38:26.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Connection-Pool"><a href="#Connection-Pool" class="headerlink" title="Connection Pool"></a>Connection Pool</h1><p>因为 <code>TCP</code> 连接都是客户端主动发起的，也就是说需要经过三次握手才能够进行读写操作，如果客户端需要建立连接的次数较少，那么握手需要的开销倒可以忽略不计，但是如果客户端需要建立成千上万个 <code>TCP</code> 连接，那么就需要成千上万次握手了。如果真是这样，势必会导致系统性能低下，我们引入连接池来解决多次握手的问题。</p><p>连接池（ <code>Connection Pool</code> ）在广义上来说算是资源池，我们之前讲过的  <a href="LeakyBuffer.md">LeakyBuffer</a> 也算是资源池的一种，不过 <code>LeakyBuffer</code> 的目的是反复利用内存资源，减少内存分配的次数。而连接池则是为了减少建立连接的次数，重复利用已有的 <code>TCP</code> 连接。</p><p><img src="https://code.aliyun.com/middlewarerace2018/docs/raw/master/assets/system-architecture.png" alt="ConnPool"></p><p>例如在上图中，<code>Consumer Agent</code> 不断收到来自 <code>Consumer</code> 的 <code>HTTP</code> 请求，它解析请求的内容后，<code>Consumer Agent</code> 就要利用 <code>TCP</code> 连接给 <code>Provider Agent</code> 发送消息，那么如果按照传统的方法我们就需要每一个 <code>HTTP</code> 请求都要对应一个新的 <code>TCP</code> 连接，也就对应新的三次握手，这样的话系统开销会非常大。你可能会问为什么不直接用一个 <code>TCP</code> 连接来解决传输数据的问题，这样的话甚至不用这么多握手操作了，这问题不错，但是考虑到由于 <code>TCP</code> 传输的是应用层的数据，它并不了解应用层传输的信息究竟是什么意思，如果多个客户端发起的连接共用一个 <code>TCP</code> 连接，那么我们还需要写逻辑去区分收到的消息究竟需要属于哪个 <code>HTTP</code> 请求，另外还需要考虑<code>TCP</code> 发送和接受时读写竞争的问题，操作起来比较混乱，还不如重复利用多个 <code>TCP</code> 连接来发送和接受数据来的干净利落。</p><p>总的来说，连接池是一种利用空间换时间的技术。下面我们来看一下如何设计一个连接池。连接池中最核心的操作就是获取一个空闲的 <code>TCP</code> 连接，另外还要考虑连接池资源释放的问题，否则可能会导致内存泄漏。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ErrClosed = errors.New(<span class="string">"pool is closed"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get() (net.Conn, error)</span><br><span class="line">    Close()</span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在正常的 <code>TCP</code> 流程中，<code>Close</code> 会关闭本次连接，底层会进行四个挥手操作，但是我们不希望我们调用 <code>Close</code> 时直接关闭这个连接，而是希望能回收这个连接，所以我们对普通的 <code>net.Conn</code> 做了一层封装，来该改变其 <code>Close</code> 行为（其实这就是装饰器模式的应用），我们想要客户端调用 <code>Close</code> 的时候被我们的连接池所回收而非直接关闭，除非该连接被标记为不可用时 <code>unusable</code> （通过 <code>MarkUnusable</code> ）， 我们才决定关闭本次连接。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PooledConn <span class="keyword">struct</span> &#123;</span><br><span class="line">    net.Conn</span><br><span class="line">    mu  sync.RWMutex</span><br><span class="line">    c   *ConnPool</span><br><span class="line">    unusable <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PooledConn)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    p.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> p.mu.Runlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> p.unusable &#123;</span><br><span class="line">        <span class="keyword">if</span> p.Conn != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p.Conn.Close()      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p.c.put(p.Conn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PooledConn)</span> <span class="title">MarkUnusable</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> p.mu.Unlock()</span><br><span class="line">    p.unusable = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConnPool)</span> <span class="title">wrapConn</span><span class="params">(conn net.Conn)</span> <span class="title">net</span>.<span class="title">Conn</span></span> &#123;</span><br><span class="line">    p := &amp;PooledConn&#123;c: c&#125;</span><br><span class="line">    p.Conn = conn</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接池的构建需要考虑两个问题，一个就是连接创建问题，第二就是回收连接问题，创建我们用一个 <code>Factory</code> 工厂方法来表示，而回收连接可以利用 <code>golang</code> 中的通道机制（ <code>chan</code> ）来进行储存。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Factory <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(net.Conn, error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">ConnPool</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">    mu sync.RWMutex</span><br><span class="line">    conns <span class="keyword">chan</span> net.Conn</span><br><span class="line">    factroy Factory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化连接池时，我们先建立 <code>initialCap</code> 个连接用于刚开始时使用，具体创建可以使用 <code>factory</code> 产生 <code>TCP</code> 连接。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConnPool</span><span class="params">(initialCap, maxCap <span class="keyword">int</span>, factory Factory)</span> <span class="params">(Pool, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> initialCap &lt; <span class="number">0</span> || maxCap &lt;= <span class="number">0</span> || initialCap &gt; maxCap &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> , errors.New(<span class="string">"invalid capacity settings"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c := &amp;ConnPool&#123;</span><br><span class="line">        conns: <span class="built_in">make</span>(<span class="keyword">chan</span> net.Conn, maxCap),</span><br><span class="line">        factory: factory,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; initialCap; i++ &#123;</span><br><span class="line">        conn, err := factory()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            c.Close()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"factory is not able to fill the pool: %s"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        c.conns &lt;- conn</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConnPool)</span> <span class="title">getConnsAndFactory</span><span class="params">()</span> <span class="params">(<span class="keyword">chan</span> net.Conn, Factory)</span></span>&#123;</span><br><span class="line">    c.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">    conns := c.conns</span><br><span class="line">    factory := c.factory</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当客户端使用完一次 <code>TCP</code> 连接后，会主动调用 <code>Close</code> 来关闭此次连接，由于我们重新定义了 <code>Close</code> 函数，当调用 <code>Close</code> 时，连接不会直接关闭而是会重新放回连接池中供其他部分代码使用，从而达到重复使用的目的，如果此时连接池已满，则直接释放该连接。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConnPool)</span> <span class="title">put</span><span class="params">(conn net.Conn)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> conn == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"connection is nil, rejecting"</span>)</span><br><span class="line">    &#125; </span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.conns == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> conn.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> c.conns &lt;- conn:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> conn.Close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的结构体 <code>ConnPool</code> 实现了 <code>Pool</code> 接口。在 <code>Get</code> 方法中我们先得到具体用于存储连接的通道 <code>conns</code> 和用于制造连接的工厂方法 <code>factory</code>，然后试着去通道中拿，和 <code>put</code> 方法类似，如果该通道中还有空闲的 <code>TCP</code> 连接，则直接拿出并经过封装后（ <code>wrapConn</code> ）使用，如果没有则使用工厂方法新建一个 <code>TCP</code> 连接再经过封装后使用。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConnPool)</span> <span class="title">Get</span><span class="params">()</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line">    conns, factory := c.getConnsAndFactory()</span><br><span class="line">    <span class="keyword">if</span> conns == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrClosed</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> conn := &lt;- conns:</span><br><span class="line">        <span class="keyword">if</span> conn == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ErrClosed</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c.wrapConn(conn), <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        conn, err := factory()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c.wrapConn(conn), <span class="literal">nil</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConnPool)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    conns := c.conns</span><br><span class="line">    c.conns. = <span class="literal">nil</span></span><br><span class="line">    c.factory = <span class="literal">nil</span></span><br><span class="line">    c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> conns == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(conns)</span><br><span class="line">    <span class="keyword">for</span> conn := <span class="keyword">range</span> conns &#123;</span><br><span class="line">        conn.Close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConnPool)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    conns, _ := c.getConnsAndFactory()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(conns)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接池的使用"><a href="#连接池的使用" class="headerlink" title="连接池的使用"></a>连接池的使用</h2><p>由于具体的连接逻辑是由客户端决定的，所以 <code>factory</code> 应该由使用者定义。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">factory := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(net.Conn, error)</span></span> &#123;<span class="keyword">return</span> net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:8080"</span>)&#125;</span><br></pre></td></tr></table></figure><p>我们通过 <code>pool.NewConnPool</code> 来新建一个连接池，这里我们指定连接池中初始的连接个数为5，而最大的连接个数为30。通过 <code>p.Get</code> 来获得可用的连接，<code>Get</code> 方法会根据当前池中的情况返回连接，如果池中没有可用的连接则用 <code>factory</code> 方法新建一个，此时系统开销较大，但是这种情况并不常见，所以基本可以忽略不计。如果池中有可用连接，则直接返回，此时开销较小。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p, err := pool.NewConnPool(<span class="number">5</span>, <span class="number">30</span>, factory)</span><br><span class="line"></span><br><span class="line">conn, err := p.Get()</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br></pre></td></tr></table></figure><p>下面给出真正关闭该连接的方法，因为我们重载了 <code>Close</code> 方法，直接调用 <code>Close</code> 只会将此连接放回连接池中，所以需要在真正关闭前将此连接设为不可用（ <code>MarkUnusable</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pc, ok := conn.(*pool.PooledConn); ok &#123;</span><br><span class="line">    pc.MarkUnusable()</span><br><span class="line">    pc.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Connection-Pool&quot;&gt;&lt;a href=&quot;#Connection-Pool&quot; class=&quot;headerlink&quot; title=&quot;Connection Pool&quot;&gt;&lt;/a&gt;Connection Pool&lt;/h1&gt;&lt;p&gt;因为 &lt;code&gt;TCP&lt;/code
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Morse Code</title>
    <link href="https://oceanoverflow.github.io/2018/05/09/MorseCode/"/>
    <id>https://oceanoverflow.github.io/2018/05/09/MorseCode/</id>
    <published>2018-05-09T09:07:24.000Z</published>
    <updated>2018-05-15T11:52:34.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="morse-code"><a href="#morse-code" class="headerlink" title="morse code"></a>morse code</h1><p>电影无间道中，陈永仁用摩斯密码向自己老大发送消息那一段真的是精彩，印象非常深刻。其实摩斯密码的本质上就是一种消息编码格式，也就是通信双方用规定好的格式进行交流，由于该编码方式二义性小，所以接受方基本可以准确无误的解析出发送方经过编码的信息。</p><h2 id="摩斯密码"><a href="#摩斯密码" class="headerlink" title="摩斯密码"></a>摩斯密码</h2><p>摩斯密码主要编码英文字母，数字和标点符号，摩斯密码与常用的二进制编码不同，它包含了五个元素， 点、划、点和划之间的停顿、每个词之间中等的停顿以及句子之间长的停顿。</p><p><img src="https://cdn-images-1.medium.com/max/443/1*2WrXJ9lDlC8Q0HCO7H3DBQ.png" alt="Morse Code"></p><p>因为摩斯密码的编码方法不止一种，但其基本原理都是相通的，所以这里我们使用国际电信联盟（International Telecommunication Union）制定的编码标准来书写代码。</p><p>下面使用一个 <code>map</code> 作为字典使用，用于记录英文字母、数字和标点符号到摩斯密码的映射关系，因为文章篇幅原因，这里选择省略对应关系。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    morseITU = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">"a"</span>: <span class="string">".-"</span>,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...    </span></span><br><span class="line"></span><br><span class="line">        <span class="string">"0"</span>:  <span class="string">"-----"</span>,   </span><br><span class="line"></span><br><span class="line">        <span class="string">"="</span>:  <span class="string">"-...-"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>编码的过程就是利用字典将我们要映射的字符转为摩斯密码，并且注意每次转换都要附加一个 <code>letterSep</code> ，也就是字符间的分隔符，当遇到原本需要编码的字符串中的空格，则加上 <code>wordSep</code> ，即字分隔符。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeITU</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Encode(s, morseITU, <span class="string">" "</span>, <span class="string">"/"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(s <span class="keyword">string</span>, alphabet <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, letterSep <span class="keyword">string</span>, wordSep <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    res := <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> _, part := <span class="keyword">range</span> s &#123;</span><br><span class="line">        p := <span class="keyword">string</span>(part)</span><br><span class="line">        <span class="keyword">if</span> p == <span class="string">" "</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> wordSep != <span class="string">""</span> &#123;</span><br><span class="line">                res += wordSep + letterSep</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> morseITU[p] != <span class="string">""</span> &#123;</span><br><span class="line">            res += morseITU[p] + letterSep</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> strings.TrimSpace(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><p>解码是编码的逆过程，因为有字符分隔符（letterSep）的存在，所以我们先用 <code>strings.Split(s, letterSep)</code> 得到一组经过摩斯密码编码的字符数组，然后对于每个经过编码的摩斯密码，我们查询字典中是否有该编码存在，如果存在则与返回结果拼接，如果不存在则检查该元素是否为字分隔符，如果还不是的话则返回错误，最后全部成功返回解码后的结果。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeITU</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Decode(s, morseITU, <span class="string">" "</span>, <span class="string">"/"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">(s <span class="keyword">string</span>, alphabet <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, letterSep <span class="keyword">string</span>, wordSep <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    res := <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> _, part := <span class="keyword">range</span> strings.Split(s, letterSep) &#123;</span><br><span class="line">        found := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> key, val := <span class="keyword">range</span> alphabet &#123;</span><br><span class="line">            <span class="keyword">if</span> val == part &#123;</span><br><span class="line">                res += key</span><br><span class="line">                found = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span>    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> part == wordSep &#123;</span><br><span class="line">            res += <span class="string">" "</span></span><br><span class="line">            found = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> found == <span class="literal">false</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res, fmt.Errorf(<span class="string">"unknown character "</span> + part)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;morse-code&quot;&gt;&lt;a href=&quot;#morse-code&quot; class=&quot;headerlink&quot; title=&quot;morse code&quot;&gt;&lt;/a&gt;morse code&lt;/h1&gt;&lt;p&gt;电影无间道中，陈永仁用摩斯密码向自己老大发送消息那一段真的是精彩，印象非常深
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Circuit Breaker</title>
    <link href="https://oceanoverflow.github.io/2018/05/09/CircuitBreaker/"/>
    <id>https://oceanoverflow.github.io/2018/05/09/CircuitBreaker/</id>
    <published>2018-05-09T01:17:24.000Z</published>
    <updated>2018-05-15T11:35:05.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CircuitBreaker"><a href="#CircuitBreaker" class="headerlink" title="CircuitBreaker"></a>CircuitBreaker</h1><p>我们都知道，如果家中因为启动过多大功率电器而导致电流过大，断路开关就会断开以保护这些电路和电器。在分布式系统中，集群中的某些服务器出现异常还是一件非常正常的事情，如果客户端向这些异常的服务器进行 <code>RPC</code> 请求的话，这些服务器会因为异常而无法向客户端返回远程方法调用的结果，因为一般来说 <code>RPC</code> 是阻塞的，客户端会像执行本地方法一样调用 <code>RPC</code> ，也就是说客户端会阻塞在这里无法执行 直到该方法本地超时，但由于为了得到正确的结果，客户端可能会反复多次调用该 <code>RPC</code> ，由于在这段时间内远程服务器都可能无法恢复正常，所以就会导致客户端一直调用该方法，但却无法得到结果，这样就会导致资源的浪费。</p><p>为了避免上述情况的发生，我们可以在程序设计中借鉴断路开关的模式，也就是允许被保护的函数在规定上限内执行，如果一旦出现错误的次数超过上限，则下次函数再次调用时则直接不让其执行（也就是断路开关直接断开），从而避免系统资源的浪费。但是上述方法存在一个问题，就是一旦总的错误次数超过上限，是不是就说明即使现在远程服务器恢复正常，客户端也无法调用了呢。</p><p>解决上述问题也很简单，通过模仿网络中很常见的 <code>Sliding Window</code> ，也就是移动窗口，允许在一定时间窗口内出现特定上限个错误，如果在该时间窗口内出现错误的次数超过上限，则不再允许该函数执行，直到下一个时间窗口的到来才允许它重新执行。</p><p>下面来设计一个滑动窗口版本的断路开关，我们通过判断一个时间窗口 <code>window</code> 内出现的错误次数 <code>failures</code> 是否超过<code>failureThreshold</code> 来决定断路开关是否应该断开（也就是不让函数继续执行）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CircuitBreaker <span class="keyword">struct</span> &#123;</span><br><span class="line">    lastFailureTime  time.Time</span><br><span class="line">    failures         <span class="keyword">uint64</span></span><br><span class="line">    failureThreshold <span class="keyword">uint64</span></span><br><span class="line">    window           time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCircuitBreaker</span><span class="params">(failureThreshold <span class="keyword">uint64</span>, window time.Duration)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;CircuitBreaker&#123;</span><br><span class="line">        failureThreshold: failureThreshold,</span><br><span class="line">        window:           window,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于是滑动窗口，我们需要观察在现在的窗口出现错误的次数是否超过我们规定的次数，如果超过，则表示该函数还没有 <code>ready</code> ，也就是还不能执行，如果该窗口已经过去，那么我们重置（ <code>reset</code> ）断路开关中记录的出错次数，以让函数可以重新执行。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CircuitBreaker)</span> <span class="title">ready</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> time.Since(cb.lastFailureTIme) &gt; cb.window &#123;</span><br><span class="line">        cb.reset()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    failures := atomic.LoadUint64(&amp;cb.failures)</span><br><span class="line">    <span class="keyword">return</span> failures &lt; cb.failureThreshold</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CircuitBreaker)</span> <span class="title">success</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cb.reset()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CircuitBreaker)</span> <span class="title">fail</span><span class="params">()</span></span> &#123;</span><br><span class="line">    atomic.AddUint64(&amp;cb.failures, <span class="number">1</span>)</span><br><span class="line">    cb.lastFailureTime = time.Now()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CircuitBreaker)</span> <span class="title">reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">    atomic.StoreUint64(&amp;cb.failures, <span class="number">0</span>)</span><br><span class="line">    cb.lastFailureTime = time.Now()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，在 <code>CircuitBreaker</code> 保护下，客户端准备调用函数时，会预先检察其是否具备资格，也就是说过去一个时间窗口没有出现超过上限个错误，如果不具备，就报 <code>ErrBreakerOpen</code> 错误，也就是对应下图中的  <code>circuit open</code> ，因为断路开关断开了，自然没有办法继续执行。</p><p>如果具备，则可以让受保护的函数继续执行，但是钥匙它在规定的时间内还没有返回结果，说明出现超时情况，则报<code>ErrBreakerTimeout</code> 错误，并增加错误次数直到其达到上限为止。</p><p><img src="https://martinfowler.com/bliki/images/circuitBreaker/sketch.png" alt="Circuit Breaker"></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrBreakerOpen = errors.New(<span class="string">"breaker open"</span>)</span><br><span class="line">    ErrBreakerTimeout = errors.New(<span class="string">"breaker time out"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cb *CircuitBreaker)</span> <span class="title">Call</span><span class="params">(fn <span class="keyword">func</span>()</span> <span class="title">error</span>, <span class="title">d</span> <span class="title">time</span>.<span class="title">Duration</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">if</span> !cb.ready() &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> d == <span class="number">0</span> &#123;</span><br><span class="line">        err = fn()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            c &lt;- fn()</span><br><span class="line">            <span class="built_in">close</span>(c)</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        t := time.NewTicker(d)</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> e := &lt;-c:</span><br><span class="line">            err = e</span><br><span class="line">        <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">            err = ErrBreakerTimeout</span><br><span class="line">        &#125;</span><br><span class="line">        t.Stop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        cb.success()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cb.fail()</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CircuitBreaker&quot;&gt;&lt;a href=&quot;#CircuitBreaker&quot; class=&quot;headerlink&quot; title=&quot;CircuitBreaker&quot;&gt;&lt;/a&gt;CircuitBreaker&lt;/h1&gt;&lt;p&gt;我们都知道，如果家中因为启动过多大功率电器而
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Colorful Printing</title>
    <link href="https://oceanoverflow.github.io/2018/05/08/ColorfulPrinting/"/>
    <id>https://oceanoverflow.github.io/2018/05/08/ColorfulPrinting/</id>
    <published>2018-05-08T11:48:24.000Z</published>
    <updated>2018-05-15T11:35:50.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Colorful-Printing"><a href="#Colorful-Printing" class="headerlink" title="Colorful Printing"></a>Colorful Printing</h1><p>平时在使用一些命令行工具时，是否经常注意到彩色的 <code>log</code> 打出来呢，然而自己写的命令行工具永远都是清一色白底黑字（或者黑底白字）的输出，是不是会怀疑别人施了黑魔法才让输出变得五彩斑斓，其实要让命令行输出彩色字体并没有那么难，关键就在对其规则的把握。</p><p>为了让字符变色，我们需要规定其伴随的属性，一般来说属性有以下几类。</p><ul><li>基本属性，例如字体粗细，是否为斜体等等</li><li>前景字体颜色</li><li>前景字体颜色（强烈版）</li><li>背景字体颜色</li><li>背景字体颜色（强烈版）</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base attributes</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Reset Attribute = <span class="literal">iota</span></span><br><span class="line">    Bold</span><br><span class="line">    Faint</span><br><span class="line">    Italic</span><br><span class="line">    Underline</span><br><span class="line">    BlinkSlow</span><br><span class="line">    BlinkRapid</span><br><span class="line">    ReverseVideo</span><br><span class="line">    Concealed</span><br><span class="line">    CrossedOut</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Foreground text colors</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    FgBlack Attribute = <span class="literal">iota</span> + <span class="number">30</span></span><br><span class="line">    FgRed</span><br><span class="line">    FgGreen</span><br><span class="line">    FgYellow</span><br><span class="line">    FgBlue</span><br><span class="line">    FgMagenta</span><br><span class="line">    FgCyan</span><br><span class="line">    FgWhite</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Foreground Hi-Intensity text colors</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    FgHiBlack Attribute = <span class="literal">iota</span> + <span class="number">90</span></span><br><span class="line">    FgHiRed</span><br><span class="line">    FgHiGreen</span><br><span class="line">    FgHiYellow</span><br><span class="line">    FgHiBlue</span><br><span class="line">    FgHiMagenta</span><br><span class="line">    FgHiCyan</span><br><span class="line">    FgHiWhite</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Background text colors</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    BgBlack Attribute = <span class="literal">iota</span> + <span class="number">40</span></span><br><span class="line">    BgRed</span><br><span class="line">    BgGreen</span><br><span class="line">    BgYellow</span><br><span class="line">    BgBlue</span><br><span class="line">    BgMagenta</span><br><span class="line">    BgCyan</span><br><span class="line">    BgWhite</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Background Hi-Intensity text colors</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    BgHiBlack Attribute = <span class="literal">iota</span> + <span class="number">100</span></span><br><span class="line">    BgHiRed</span><br><span class="line">    BgHiGreen</span><br><span class="line">    BgHiYellow</span><br><span class="line">    BgHiBlue</span><br><span class="line">    BgHiMagenta</span><br><span class="line">    BgHiCyan</span><br><span class="line">    BgHiWhite</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>让字符变色的关键在于转义字符的使用，转义字符对每个程序员来说肯定都不陌生，它的作用就是让紧随其后的字符变成其他含义，所谓转义转义就是这个意思，我们这里要使用的转义字符是 <code>\x1b</code> ，或者写作  <code>\033</code> ，二者都是可以的，因为十六进制的 <code>1b</code> 和八进制的 <code>33</code> 相等。</p><p>下面我们定义一个 <code>Color</code> 结构体，里面包含一个属性数组，规定了我们的文字会变化成什么样。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> escape = <span class="string">"\x1b"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Attribute <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Color <span class="keyword">struct</span> &#123;</span><br><span class="line">    params []Attribute</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(value ...Attribute)</span> *<span class="title">Color</span></span> &#123;</span><br><span class="line">    c := &amp;Color&#123;params: <span class="built_in">make</span>([]Attribute, <span class="number">0</span>)&#125;</span><br><span class="line">    c.params = <span class="built_in">append</span>(c.params, value...)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如一段文字 <code>how are you?</code> ，我们想要把把中间的 <code>are</code> 变为绿色，我们应该怎么办呢，其实就是分别在 <code>are</code> 的前后加上一些修饰符。</p><p>在 <code>are</code> 的前面加上 <code>\x1b[32m</code> 表示从这之后将后面的字变为绿色。<br>而在 <code>are</code> 的后面加上 <code>\x1b[0m</code> 则表示结束属性变化。</p><p>所以我们在开始变化的时候加上 <code>fmt.Sprintf(&quot;%s[%sm&quot;, escape, c.sequence())</code> ，这里的 <code>escape</code> 就是我们之前提过的转义字符，而 <code>c.sequence()</code> 就是我们规定的属性。</p><p>在变化结束的时候加上 <code>fmt.Sprintf(&quot;%s[%dm&quot;, escape, Reset)</code> ，这里 <code>Reset</code> 就表示重置变化，其值为0。</p><p>注意如果有多个属性，我们使用 <code>;</code> 连接就可以了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Color)</span> <span class="title">sequence</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    format := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(c.params))</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> c.params &#123;</span><br><span class="line">        format[i] = strconv.Itoa(<span class="keyword">int</span>(v))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strings.Join(format, <span class="string">";"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Color)</span> <span class="title">format</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s[%sm"</span>, escape, c.sequence())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Color)</span> <span class="title">unformat</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s[%dm"</span>, escape, Reset)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Color)</span> <span class="title">wrap</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.format() + s + c.unformat() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们对常见的几个函数作一层封装。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Color)</span> <span class="title">Sprint</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.wrap(fmt.Sprint(a...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Color)</span> <span class="title">Sprintln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.wrap(fmt.Sprintln(a...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Color)</span> <span class="title">Sprintf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.wrap(fmt.Sprintf(format, a...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>理清了基本思路，使用它就变的非常简单了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := New(Bold, FgGreen)</span><br><span class="line">    fmt.Println(c.Sprintln(<span class="string">"hello world"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Colorful-Printing&quot;&gt;&lt;a href=&quot;#Colorful-Printing&quot; class=&quot;headerlink&quot; title=&quot;Colorful Printing&quot;&gt;&lt;/a&gt;Colorful Printing&lt;/h1&gt;&lt;p&gt;平时在使用一些命令行
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Weighted Round Robin</title>
    <link href="https://oceanoverflow.github.io/2018/05/08/SmoothWeightedRoundRobin/"/>
    <id>https://oceanoverflow.github.io/2018/05/08/SmoothWeightedRoundRobin/</id>
    <published>2018-05-08T02:29:04.000Z</published>
    <updated>2018-05-15T12:04:29.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Smooth-Weighted-Round-Robin"><a href="#Smooth-Weighted-Round-Robin" class="headerlink" title="Smooth Weighted Round Robin"></a>Smooth Weighted Round Robin</h1><p>我们在之前的文章中就讲过负载均衡，但是那篇文章中的例子比较简单，仅仅是利用随机算法来进行负载均衡，并没有考虑服务器的实际情况，在很多情况下，服务器的性能可能存在显著差异，这时候如果采用随机算法，那么性能较差的服务器会承受过多的压力，而性能较好的服务器则大部分时间处于空闲状态，系统整体的吞吐量就无法上来。</p><p>例如服务器的性能比例如下：<code>{a:3, b: 2, c:1}</code> ，一般来说可以使用加权的轮询算法（ <code>Weighted Round Robin</code> ）进行负载均衡，但是普通的加权轮询会得出类似这样的序列， <code>a a a b b c</code> ，这样的序列有一个问题，就是它并不够平滑，我们更希望得到像这样的序列 <code>a b a c b a</code> 。也就是说一般的轮询调度在调度的过程中并没有考虑瞬时的情况，所以会导致对某一台服务器的瞬时访问。</p><p>下面我们就来介绍一下平滑版本的加权轮询算法，来解决上述瞬时访问可能出现的问题。我们对每个节点赋予两个权重， <code>Weight</code> ，这是一个较为固定的值，就是前面给出的 <code>{a:3, b: 2, c:1}</code> ，还需要一个 <code>CurrentWeight</code> 来记录当前的权重，初始时均为0，这个权重是在每次选择节点时动态变化的。</p><p>例如现在有三台服务器，其权重比值为 <code>{a:3, b: 2, c:1}</code> ，刚开始时它们的 <code>CurrentWeight</code> 均为0，按照下面的算法，每一回合中各个节点的 <code>CurrentWeight</code> 都会加上它相应的的 <code>Weight</code> ，<code>total</code> 变量则用于记录每一个节点增加的 <code>Weight</code> 的总和，并记录当前权重最高的那一个节点，也就是我们的 <code>best</code> ，在一轮计算之后，再让 <code>best</code> 节点的 <code>CurrentWeight</code> 减去 <code>total</code> 值。</p><p>也就是说开始时每台服务器的 <code>CurrentWeight</code> 为 <code>{a:0, b: 0, c:0}</code> ，在选择节点的过程中，每个节点均会加上自己对应的 <code>Weight</code> ，这样就变成 <code>{a:3, b: 2, c:1}</code> ， 此时 <code>best=a</code> ， 最后 a 对应的 <code>CurrentWeight</code> 要减去 <code>total</code> ，也就是 <code>{a:-3, b: 2, c:1}</code>  。</p><p>然后 <code>{a:-3, b: 2, c:1}</code> 作为下一轮挑选节点时的初始状态，以此类推，最后可以得到下面这样的序列  <code>a b a c b a</code> ，这样就不会导致对服务器 <code>a</code> 集中访问的情况，也就是说访问序列更加平滑了。</p><p>整个周期计算的流程如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a   b   c</span><br><span class="line">0   0   0</span><br><span class="line"></span><br><span class="line">3   2   1   Next() : a</span><br><span class="line">-3  2   1</span><br><span class="line"></span><br><span class="line">0   4   2   Next() : b</span><br><span class="line">0  -2   2</span><br><span class="line"></span><br><span class="line">3   0   3   Next() : a</span><br><span class="line">-3  0   3</span><br><span class="line"></span><br><span class="line">0   2   4   Next() : c</span><br><span class="line">0   2   -2 </span><br><span class="line"></span><br><span class="line">3   4   -1  Next() : b</span><br><span class="line">3  -2   -1</span><br><span class="line"></span><br><span class="line">6   0   0   Next() : a</span><br><span class="line">0   0   0</span><br></pre></td></tr></table></figure><h2 id="普通版本平滑轮询调度算法"><a href="#普通版本平滑轮询调度算法" class="headerlink" title="普通版本平滑轮询调度算法"></a>普通版本平滑轮询调度算法</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Weighted <span class="keyword">struct</span> &#123;</span><br><span class="line">    Server <span class="keyword">string</span></span><br><span class="line">    Weight <span class="keyword">int</span></span><br><span class="line">    CurrentWeight <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通版本的算法，每次选择结点的时候，我们为每个候选结点的 <code>CurrentWeight</code> 增加 <code>Weight</code> ，选取 <code>CurrentWeight</code> 最大的节点作为我们最后返回的结果，然后将该节点减去所有节点增加的 <code>Weight</code> 之和。 </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Next</span><span class="params">(servers []*Weighted)</span> <span class="params">(best *Weight)</span></span> &#123;</span><br><span class="line">    total := <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(servers); i++ &#123;</span><br><span class="line">        w := servers[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> w == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        w.CurrentWeight += w.Weight</span><br><span class="line">        total += w.CurrentWeight </span><br><span class="line">        <span class="keyword">if</span> best == <span class="literal">nil</span> || w.CurrentWeight &gt; best.CurrentWeight &#123;</span><br><span class="line">            best = w</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> best == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    best.CurrentWeight -= total</span><br><span class="line">    <span class="keyword">return</span> best</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="考虑节点失效情况时的算法"><a href="#考虑节点失效情况时的算法" class="headerlink" title="考虑节点失效情况时的算法"></a>考虑节点失效情况时的算法</h2><p>上面那种算法不能很好的应对节点失效的情况，为了解决节点失效时的这种突发情况，我们多引入一个权重也就是 <code>EffectiveWeight</code> ，该权重初始时与 <code>Weight</code> 的值相同，例如上述的例子中都是  <code>{a:3, b: 2, c:1}</code> ，但是 <code>EffectiveWeight</code> 会在节点失败的时候清0，当节点恢复正常时再慢慢递增直到达到原本的 <code>Weight</code> ，这样就能很好地考虑了节点失效再重启时的真实情况。因为引入了 <code>EffectiveWeight</code> ， 我们在相应计算的时候就不直接采用 <code>Weight</code> 而是直接使用<code>EffectiveWeight</code> 来代替计算。 </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Weighted <span class="keyword">struct</span> &#123;</span><br><span class="line">    Server <span class="keyword">string</span></span><br><span class="line">    Weight <span class="keyword">int</span></span><br><span class="line">    CurrentWeight <span class="keyword">int</span></span><br><span class="line">    EffectiveWeight <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Weighted)</span> <span class="title">fail</span><span class="params">()</span></span> &#123;</span><br><span class="line">    w.EffetiveWeight -= w.Weight</span><br><span class="line">    <span class="keyword">if</span> w.EffectiveWeight &lt; <span class="number">0</span> &#123;</span><br><span class="line">        w.EffectiveWeight = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Next</span><span class="params">(servers []*Weighted)</span> <span class="params">(best *Weight)</span></span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(servers); i++ &#123;</span><br><span class="line">        w := servers[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> w == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        w.CurrentWeight += w.EffectiveWeight</span><br><span class="line">        total += w.EffectiveWeight</span><br><span class="line">        <span class="keyword">if</span> w.EffectiveWeight &lt; w.Weight &#123;</span><br><span class="line">            w.EffectiveWeight++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> best == <span class="literal">nil</span> || w.CurrentWeight &gt; best.CurrentWeight &#123;</span><br><span class="line">            best = w</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> best == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    best.CurrentWeight -= total</span><br><span class="line">    <span class="keyword">return</span> best</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Smooth-Weighted-Round-Robin&quot;&gt;&lt;a href=&quot;#Smooth-Weighted-Round-Robin&quot; class=&quot;headerlink&quot; title=&quot;Smooth Weighted Round Robin&quot;&gt;&lt;/a&gt;Smoot
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Magnet Link</title>
    <link href="https://oceanoverflow.github.io/2018/05/07/MagnetLink/"/>
    <id>https://oceanoverflow.github.io/2018/05/07/MagnetLink/</id>
    <published>2018-05-07T07:15:24.000Z</published>
    <updated>2018-05-15T11:50:46.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Magnet-Link"><a href="#Magnet-Link" class="headerlink" title="Magnet Link"></a>Magnet Link</h1><p>相信大部分人都使用过磁力链接来下载过网上的文件吧，但是估计很少人会去关心那稀奇古怪的磁力链接究竟是什么鬼，今天就让我们来解析一下磁力链接，看一下它里面隐藏的信息吧。</p><p>其实类似下面这种看似复杂的链接地址也就是由几个部分组成，开头的 <code>magnet</code> 我们把它称为 <code>scheme</code> 或者说是协议名，就像一般的 <code>http</code> 地址一样，<code>http</code> 也算是一种协议名，紧接着 <code>magnet:?</code> 后面就是几对键值对了，一般键值对之间以 <code>&amp;</code> 符号划分，常见的键有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">magnet:?xt=urn:btih:0FF55426B9713084FF5229A16D21712B1E6C1625&amp;dn=%e5%8d%97%e5%be%81%e5%8c%97%e6%88%98%20-%206415&amp;tr=http%3a%2f%2ftracker.nexushd.org%2fannounce.php%3fpasskey%3d346ae8170f8427b078512150f3683285</span><br></pre></td></tr></table></figure><ul><li><code>xt</code> ：eXact Topic 的缩写，其实本质上就是一个文件的哈希值，用于唯一标示这个文件而存在的，这是整个磁力链接中不可或缺的一部分，少了它，基本上链接地址就无法解析了。</li><li><code>dn</code> ：Display Name 的缩写，这个是用于向用户展示的文件的名称，这一项可以没有。</li><li><code>tr</code> ： Tracker 的缩写，表示Tracker服务器的地址，取决于使用的技术，这一项也是选填的。</li><li><code>ws</code> ： Web Seed 的缩写，表示网络种子，选填。</li><li><code>urn</code> ：Uniform Resource Name 的缩写，也就是统一资源名称。</li><li><code>btih</code> ： BitTorrent Info Hash 的缩写，表示种子的散列函数。</li></ul><p>知道了磁力链接地址中的关键信息，也就基本可以看懂链接地址中的各个部分分别代表什么含义了，但是由于其中一些信息还是经过特殊编码的，人类读起来还是比较费劲<br>的，所以我们还是实现代码来解析它吧。</p><p>首先，来定义一个结构体来定义一下磁力链接中的组成部分，这里只选了几个重要的，<code>InfoHash</code> 代表的就是 <code>&quot;urn:btih:&quot;</code> 后面那一部分玩意儿，<code>Trackers</code> 数组代表的就是 <code>Tracker</code> 服务器的地址，<code>DisplayName</code> 就对应磁力链接中的 <code>dn</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Magnet <span class="keyword">struct</span> &#123;</span><br><span class="line">    InfoHash Hash</span><br><span class="line">    Trackers []<span class="keyword">string</span></span><br><span class="line">    DisplayName <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xtPrefix = <span class="string">"urn:btih:"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m Magnet)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    ret : = <span class="string">"magnet:?xt="</span></span><br><span class="line">    ret += xtPrefix + hex.EncodeToString(m.InfoHash[:])</span><br><span class="line">    <span class="keyword">if</span> m.DisplayName != <span class="string">""</span> &#123;</span><br><span class="line">        ret += <span class="string">"&amp;dn="</span> + url.QueryEscape(m.DisplayName)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, tr := <span class="keyword">range</span> m.Trackers &#123;</span><br><span class="line">        ret += <span class="string">"&amp;tr="</span> + url.QueryEscape(tr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析磁力链接的过程和解析一般的 <code>url</code> 的过程非常类似，关键的部分是哈希值部分的解析，由于 <code>BTIH</code> 这个部分的哈希值可能用 <code>Hex</code> 编码也可能用 <code>Base32</code> 编码，所以我们要根据其哈希长度选择解码的方式，这里定义了一个函数变量 <code>var decode func(dst, src []byte) (int, error)</code> 用于接受我们具体的解码函数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseMagnetURI</span><span class="params">(uri <span class="keyword">string</span>)</span> <span class="params">(m Magnet, err eror)</span></span> &#123;</span><br><span class="line">    u, err := url.Parse(uri)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        err = fmt.Errorf(<span class="string">"error parsing uri : %s"</span>, err) </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> u.Scheme != <span class="string">"magnet"</span> &#123;</span><br><span class="line">        err = fmt.Errorf(<span class="string">"unexpected scheme: %q"</span>, u.Scheme)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    xt := u.Query().Get(<span class="string">"xt"</span>)</span><br><span class="line">    <span class="keyword">if</span> !strings.HasPrefix(xtPrefix) &#123;</span><br><span class="line">        err = fmt.Errorf(<span class="string">"bad xt parameter"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    infoHash := xt[<span class="built_in">len</span>(xtPrefix):]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> decode <span class="function"><span class="keyword">func</span><span class="params">(dst, src []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="function">    <span class="title">switch</span> <span class="title">len</span><span class="params">(infoHash)</span></span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">40</span>:</span><br><span class="line">        decode = hex.Decode</span><br><span class="line">    <span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">        decode = base32.StdEncoding.Decode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> decode == <span class="literal">nil</span> &#123;</span><br><span class="line">        err = fmt.Errorf(<span class="string">"unhandled xt parameter encoding: encoded lenght"</span>, <span class="built_in">len</span>(infoHash))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    n, err := decode(m.InfoHash[:], []<span class="keyword">byte</span>(infoHash))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        err = fmt.Errorf(<span class="string">"error decoding xt: %s"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n != <span class="number">20</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(n)</span><br><span class="line">    &#125;</span><br><span class="line">    m.DisplayName = u.Query().Get(<span class="string">"dn"</span>)</span><br><span class="line">    m.Trackers = u.Query()[<span class="string">"tr"</span>]</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Magnet-Link&quot;&gt;&lt;a href=&quot;#Magnet-Link&quot; class=&quot;headerlink&quot; title=&quot;Magnet Link&quot;&gt;&lt;/a&gt;Magnet Link&lt;/h1&gt;&lt;p&gt;相信大部分人都使用过磁力链接来下载过网上的文件吧，但是估计很少人会去
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PubSub</title>
    <link href="https://oceanoverflow.github.io/2018/05/06/PubSub/"/>
    <id>https://oceanoverflow.github.io/2018/05/06/PubSub/</id>
    <published>2018-05-06T11:08:04.000Z</published>
    <updated>2018-05-15T11:57:24.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PubSub"><a href="#PubSub" class="headerlink" title="PubSub"></a>PubSub</h1><p>消息的发布和订阅这种设计模式在大型开源项目中还是会经常被使用到的，它的要点是一堆消息订阅者（ <code>Subscriber</code> ）会订阅某个自己感兴趣的 <code>topic</code> ，一旦发布者（ <code>Publisher</code> ）向这个 <code>topic</code> 发布消息，消息的订阅者就能收到该消息。</p><p>这种设计模式的灵感其实就来自于现实生活之中，我们（ <code>Subscriber</code> ）向我们感兴趣的杂志社订阅想要阅读的月刊，那么我们订阅的消息（算一个 <code>subscription</code> ）就会被杂志社（ <code>Publisher</code> ）记录下来，一旦杂志可以上市发行了，杂志社就会主动向我们推送（ <code>Publish</code> ）杂志消息。</p><p><img src="https://docs.oracle.com/cd/E19575-01/819-3669/images/jms-publishSubscribe.gif" alt="PubSub"></p><p>下面我们来实现一个简单的发布者订阅者模型吧。</p><p>由于这个模型的核心就在于很多 <code>subscriber</code> 会向某一个 <code>topic</code> 订阅消息，所以需要一个结构体来记录特定的 <code>topic</code> 对应的所有 <code>subscriber</code> ，这里 <code>subscriber</code> 用一个集合（ <code>Set</code> ）来表示。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PubSub <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    subscriptions <span class="keyword">map</span>[<span class="keyword">string</span>]*Set</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Set <span class="keyword">struct</span> &#123;</span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    lock *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPubSub</span><span class="params">()</span> *<span class="title">PubSub</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;PubSub&#123;</span><br><span class="line">        subscriptions: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*Set),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Subscription</code> 应该具有监听行为，通过 <code>Listen</code> 来获取 <code>Publisher</code> 发布的消息。而结构体 <code>subscription</code> 则相当于一个订阅的注册信息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Subscription <span class="keyword">interface</span> &#123;</span><br><span class="line">    Listen() (<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> subscription <span class="keyword">struct</span> &#123;</span><br><span class="line">    topic <span class="keyword">string</span></span><br><span class="line">    ttl   time.Duration</span><br><span class="line">    c     <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (s *subscription) Listen() (<span class="keyword">interface</span>&#123;&#125;, error) &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(s.ttl):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"timed out"</span>)</span><br><span class="line">    <span class="keyword">case</span> iterm := &lt;-s.c:</span><br><span class="line">        <span class="keyword">return</span> item, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实订阅和取消订阅的本质就是将自己从订阅名单（ <code>subscriptions map[string]*Set</code> ）里面进行增加或删除的操作，因为我们向杂志社订阅了某本杂志，那么关于我们的订阅信息一定会在杂志出版商那里存在。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PubSub)</span> <span class="title">Subscribe</span><span class="params">(topic <span class="keyword">string</span>, ttl time.Duration)</span> <span class="title">Subscription</span></span> &#123;</span><br><span class="line">    sub := &amp;subscription&#123;</span><br><span class="line">        topic: topic.</span><br><span class="line">        ttl:   ttl,</span><br><span class="line">        c:     <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, subscriptionBuffSize),</span><br><span class="line">    &#125;</span><br><span class="line">    ps.Lock()</span><br><span class="line">    s, exists := ps.subscriptions[topic]</span><br><span class="line">    <span class="keyword">if</span> !exists &#123;</span><br><span class="line">        s = NewSet()</span><br><span class="line">        ps.subscriptions[topic] = s</span><br><span class="line">    &#125;</span><br><span class="line">    ps.Unlock()</span><br><span class="line"></span><br><span class="line">    s.Add(sub)</span><br><span class="line">    time.AfterFunc(ttl, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ps.unSubscribe(sub)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PubSub)</span> <span class="title">unSubscribe</span><span class="params">(sub *subscription)</span></span> &#123;</span><br><span class="line">    ps.Lock()</span><br><span class="line">    <span class="keyword">defer</span> ps.Unlock()</span><br><span class="line">    ps.subscriptions[sub.topic].Remove(sub)</span><br><span class="line">    <span class="keyword">if</span> ps.subscriptions[sub.topic].Size() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">delete</span>(ps.subscriptions, sub.topic)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们订阅的杂志终于要发布了，杂志的出版社会根据自己手中的订阅名单，逐一向订阅该 <code>topic</code> 的订阅者发送杂志，当然只有订阅了的人才能收到。但是由于订阅者可能出去旅游了，也就是说他最近并没有调用 <code>Listen</code> 将收到的订阅消息拿出，而我们接受订阅消息的邮箱大小是有上限的（ <code>c: make(chan interface{}, subscriptionBuffSize)</code> ，我们设置了<code>subscriptionBuffSize</code> 来表示一个通道中最多可以存放的消息数量），如果该邮箱内已有的消息超出这个限制，则选择不将消息放入邮箱中，否则则将消息放入这个邮箱中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PubSub)</span> <span class="title">Publish</span><span class="params">(topic <span class="keyword">string</span>, item <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ps.RLock()</span><br><span class="line">    <span class="keyword">defer</span> ps.RUnlock()</span><br><span class="line">    s, subscribed := ps.subscriptions[topic]</span><br><span class="line">    <span class="keyword">if</span> !subscribed &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"no subscribers"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, sub := <span class="keyword">range</span> s.ToArray() &#123;</span><br><span class="line">        c := sub.(*subscription).c</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(c) == subscriptionBuffSize &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        c &lt;- item</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PubSub&quot;&gt;&lt;a href=&quot;#PubSub&quot; class=&quot;headerlink&quot; title=&quot;PubSub&quot;&gt;&lt;/a&gt;PubSub&lt;/h1&gt;&lt;p&gt;消息的发布和订阅这种设计模式在大型开源项目中还是会经常被使用到的，它的要点是一堆消息订阅者（ &lt;code&gt;S
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WebSocket</title>
    <link href="https://oceanoverflow.github.io/2018/05/05/WebSocket/"/>
    <id>https://oceanoverflow.github.io/2018/05/05/WebSocket/</id>
    <published>2018-05-05T02:52:04.000Z</published>
    <updated>2018-05-15T12:05:17.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>如果服务器会定期地更新消息，但是具体的时间间隔并不确定，客户端为了能够及时拿取最新的消息，就得不断的发送 <code>HTTP</code> 请求来轮询服务器，也就是说为了能够及时获取最新资讯，由于 <code>HTTP</code> 本身的特点，服务请求的发起方只能是客户端，服务器本身并没有消息推送的功能，这样就导致了资源浪费的问题，很多客户端发送的请求都是无效的，当客户端和服务器一对一交流时倒还好，如果很多客户端向服务器以这样的形式咨询，服务器将会承受非常大的压力了。</p><p>所以，为了避免资源浪费，我们来引入 <code>WebSocket</code> 解决上述问题，<code>WebSocket</code> 可以说是 <code>HTTP</code> 协议的一个升级，它同样基于 <code>TCP</code> 之上，但与传输层的 <code>socket</code> 不同，它的 <code>socket</code> 是应用层的概念。要想使用 <code>WebSocket</code> ，客户端和服务器必须同时支持才可以使用。</p><p><code>WebSocket</code> 中比较重要的一个阶段就是握手阶段了，如下图所示，客户端向服务器发送一个协议升级的 <code>HTTP</code> 请求，并且附带上一些其他的元信息用于握手。</p><p><img src="http://www.cuelogic.com/blog/wp-content/uploads/2013/11/websocketlifecycle_30624_l.png" alt="WebSocket"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Request headers from client</span><br><span class="line"></span><br><span class="line">GET /mychat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure><p>服务器收到该协议升级的 <code>HTTP</code> 请求后，会返回一个 <code>HTTP</code> 答复，向客户端确认同意建立 <code>WebSocket</code> 连接，从此之后，它们之间就不再用 <code>HTTP</code> 的形式交流了，而是直接改用 <code>WebSocket</code> 格式的报文进行交流，服务器也具备了相应推送消息的能力了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Response headers from server</span><br><span class="line"></span><br><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><p>下面我们来看一下使用 <code>&quot;github.com/gorilla/websocket&quot;</code> 时各个步骤对应的代码吧。</p><p>客户端代码的风格和使用 <code>TCP</code> 进行编程非常类似，第一步，客户端向服务器发送协议升级请求，对应<br><code>websocket.DefaultDialer.Dial(u.string(), nil)</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addr = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:8080"</span>, <span class="string">"http service addr"</span>)</span><br><span class="line">u := url.URL&#123;Scheme: <span class="string">"ws"</span>, Host: *addr, Path: <span class="string">"/echo"</span>&#125;</span><br><span class="line">log.Printf(<span class="string">"connecting to %s"</span>, u.String())</span><br><span class="line"></span><br><span class="line">c, _, err := websocket.DefaultDialer.Dial(u.<span class="keyword">string</span>(), <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">"dial:"</span>, err)</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br></pre></td></tr></table></figure><p>在服务端处理 <code>WebSocket</code> 请求与处理 <code>HTTP</code> 请求类似，我们同样需要定义一个 <code>handler</code> ，但与普通处理 <code>HTTP</code> 请求不同的是，此 <code>handler</code> 会对协议进行升级，也就是 <code>upgrader.Upgrade(w, r, nil)</code> ，这段代码相当于服务端向客户端发送一个协议升级的确认消息。在这之后，服务器就可以一直读取客户端发来的请求和向客户端返回答复了（代码的逻辑在 <code>for</code> 循环之中），也就是说服务器只起了一个 <code>handler</code> 来处理这段 <code>session</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    c, err := upgrader.Upgrade(w, r, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Print(<span class="string">"upgrade:"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> c.Close()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        mt, message, err := c.ReadMessage()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">"read:"</span>, err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        log.Printf(<span class="string">"recv: %s"</span>, message)</span><br><span class="line">        err = c.WriteMessage(mt, message)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">"write:"</span>, err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"echo"</span>, echo)</span><br><span class="line">    log.Fatal(http.ListenAndServe(*addr, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端在握手之后就可以读取和发送数据，在这里，由于在 <code>WebSocket</code> 中服务器可以主动向客户端推送数据，所以我们起一个 <code>goroutine</code> 专门用于接受服务器主动推送的数据（ <code>c.ReadMessage()</code> ）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        _, message, err := c.ReadMessage()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">"read:"</span>, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        log.Printf(<span class="string">"recv:"</span>, message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是客户端发送数据的逻辑，这里我们每隔一秒钟向服务器发送当前的时间，<code>c.WriteMessage(websocket.TextMessage, []byte(t.string()))</code> ，这里我们注意到，<code>WebSocket</code> 中的消息是有类型的，这个函数的第一个参数就是指明该消息的类型，这里我们使用 <code>websocket.TextMessage</code> 。</p><p>那么如何让这段 <code>session</code> 结束呢，结束会话一般来说都是客户端主动发起的，客户端主要发送一个结束对话的消息类型就可以了，<br><code>c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, &quot;&quot;))</code> ，这里注意该结束对话的消息类型为 <code>websocket.CloseMessage</code> 。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ticker := time.NewTicker(time.Second)</span><br><span class="line"><span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">interrupt := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(interrupt, os.Interrupt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">case</span> t := &lt;-ticker.C:</span><br><span class="line">        err := c.WriteMessage(websocket.TextMessage, []<span class="keyword">byte</span>(t.String()))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">"write:"</span>, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> &lt;-interrupt:</span><br><span class="line">        log.Println(<span class="string">"interrupt"</span>)</span><br><span class="line">        </span><br><span class="line">        err := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, <span class="string">""</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">"write close:"</span>, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;WebSocket&quot;&gt;&lt;a href=&quot;#WebSocket&quot; class=&quot;headerlink&quot; title=&quot;WebSocket&quot;&gt;&lt;/a&gt;WebSocket&lt;/h1&gt;&lt;p&gt;如果服务器会定期地更新消息，但是具体的时间间隔并不确定，客户端为了能够及时拿取最新的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>dep</title>
    <link href="https://oceanoverflow.github.io/2018/05/05/dep/"/>
    <id>https://oceanoverflow.github.io/2018/05/05/dep/</id>
    <published>2018-05-05T02:47:24.000Z</published>
    <updated>2018-05-15T11:44:24.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dep"><a href="#dep" class="headerlink" title="dep"></a>dep</h1><p>在写大型工程项目的时候，难免会依赖第三方的库（自己重复造轮子肯定不现实），如果依赖的库数量非常多时，自己去手动管理肯定是不现实的，所以我们需要一个依赖管理工具帮助我们管理依赖的库。就像 <code>node</code> 有 <code>npm</code> ，<code>java</code> 有 <code>maven</code> 。而 <code>golang</code> 之前一直没有一个官方推荐的依赖管理工具，所以第三方的依赖管理工具 <code>glide</code> ，<code>govendor</code> 之类的就应运而生，但由于不是官方出品的，自己用起来心里总有些毛毛的，后来，<code>golang</code> 官方终于推出了 <code>dep</code> 这个依赖管理工具，终于给我们这些强迫症患者安了一个心。下面我们就以一个demo为例子，看看<code>dep</code> 如何使用吧。</p><p><img src="https://github.com/golang/dep/raw/master/docs/assets/DigbyShadows.png" alt="godep"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>由于 <code>dep</code> 是一个命令行工具，安装起来也非常的方便，下面给出两种安装方式。</p><h4 id="二进制安装"><a href="#二进制安装" class="headerlink" title="二进制安装"></a>二进制安装</h4><p>这种安装方法通用型比较强，下面的命令会根据你的操作系统直接安装相应的二进制。</p><p><code>$ curl https://raw.githubusercontent.com/golang/dep/master/install.sh | sh</code></p><h4 id="macOS-安装"><a href="#macOS-安装" class="headerlink" title="macOS 安装"></a>macOS 安装</h4><p>但是 <code>macOS</code> 用户一般还是比较习惯于使用<code>brew</code> 的，使用 <code>brew</code> 也是<code>no-brainer</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew install dep</span><br><span class="line">$ brew upgrade dep</span><br></pre></td></tr></table></figure><h2 id="vendor-机制"><a href="#vendor-机制" class="headerlink" title="vendor 机制"></a>vendor 机制</h2><p>要了解 <code>dep</code> 存在的必要性就不得不提 <code>vendor</code> 机制了，我们都知道如果我们在 <code>go</code> 文件中导入一个非标准库，在编译时 <code>go</code> 会在 <code>$GOPATH</code> 下面去寻找它，但是这就导致一个问题，如果两个项目A和B同时用到了这个库，但是A和B对这个库的版本需求是不同的，这样就很难办了，毕竟在 <code>$GOPATH</code> 下面只能存在一个版本的库，所以为了解决这种情况，在<code>Go1.5</code>的时候，就出现 <code>vendor</code> 文件夹这个机制，也就是说，<code>go</code> 在编译项目的时候，会去这个项目目录下面寻找是否存在 <code>vendor</code> 这个文件夹，并且 <code>vendor</code> 下面是否存在我们需要的库，如果有则使用它，如果没有则去 <code>$GOPATH</code> 下去寻找。</p><p>例如项目C依赖 <code>github.com/aaa/bbb</code> 这个库，那么 <code>go</code> 在编译时回去查看当前项目目录下有没有<code>vendor/github.com/aaa/bbb</code> 这个文件夹目录，如果有则使用这个版本，如果没有再去 <code>$GOPATH</code> 下面去找。而 <code>dep</code> 就是为了帮我们管理 <code>vendor</code> 这个目录下面的依赖而存在的。</p><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>例如我们要写一个与 <code>WebSocket</code> 相关的项目，无奈 <code>golang</code> 的标准库里实现的 <code>WebSocket</code> 我们并不是非常满意，所以我们去 <code>github</code> 上面搜了一下，最后发现 <code>girilla</code> 家的 <code>websocket</code> 库还是比较符合我们项目的需求的，所以决定使用它。</p><p>第一步就是新建一个 <code>dep</code> 项目，使用 <code>dep init</code> 命令，会帮我们生成两个文件和一个空的 <code>vendor</code> 文件夹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ dep init</span><br><span class="line">$ ls</span><br><span class="line">Gopkg.toml Gopkg.lock vendor/</span><br></pre></td></tr></table></figure><p>然后我们写了一个 <code>main.go</code> 文件用于存放我们项目的所有逻辑（bad practice），这个文件除了标准库之外当然还导入了我们需要的 <code>websocket</code> 依赖。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"html/template"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">"github.com/gorilla/websocket"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>编辑完之后，在命令行中输入 <code>dep ensure</code> ，<code>dep</code> 会扫描我们当前项目中所有的依赖，并找出我们依赖的三方库，然后更新相应的文件（Gopkg.toml 和 Gopkg.lock），并更新我们的 <code>vendor</code> 文件夹，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Gopkg.lock</span><br><span class="line">├── Gopkg.toml</span><br><span class="line">├── main.go</span><br><span class="line">└── vendor</span><br><span class="line">    └── github.com</span><br><span class="line">        └── gorilla</span><br><span class="line">            └── websocket</span><br><span class="line">                ├── AUTHORS</span><br><span class="line">                ├── LICENSE</span><br><span class="line">                ├── README.md</span><br><span class="line">                ├── client.go</span><br><span class="line">                ├── client_clone.go</span><br><span class="line">                ├── client_clone_legacy.go</span><br><span class="line">                ├── compression.go</span><br><span class="line">                ├── conn.go</span><br><span class="line">                ├── conn_read.go</span><br><span class="line">                ├── conn_read_legacy.go</span><br><span class="line">                ├── doc.go</span><br><span class="line">                ├── json.go</span><br><span class="line">                ├── mask.go</span><br><span class="line">                ├── mask_safe.go</span><br><span class="line">                ├── prepared.go</span><br><span class="line">                ├── server.go</span><br><span class="line">                └── util.go</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>反正以后用 <code>dep</code> 作为go项目的依赖管理工具准没错的，如果你用 <code>glide</code> 或者 <code>govendor</code> 之类的还是趁早投靠 <code>dep</code> 吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;dep&quot;&gt;&lt;a href=&quot;#dep&quot; class=&quot;headerlink&quot; title=&quot;dep&quot;&gt;&lt;/a&gt;dep&lt;/h1&gt;&lt;p&gt;在写大型工程项目的时候，难免会依赖第三方的库（自己重复造轮子肯定不现实），如果依赖的库数量非常多时，自己去手动管理肯定是不现实的，所
      
    
    </summary>
    
    
  </entry>
  
</feed>
